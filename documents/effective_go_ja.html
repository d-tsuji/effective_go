
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="ja">
  <head>
    <meta charset="utf-8" />
    <title>Effective Go &#8212; Effective Go  ドキュメント</title>
    <link rel="stylesheet" href="../_static/traditional.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="検索" href="../search.html" />
    <link rel="prev" title="Effective Go" href="../index.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../index.html" title="Effective Go"
             accesskey="P">前へ</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">Effective Go  ドキュメント</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="effective-go">
<h1>Effective Go<a class="headerlink" href="#effective-go" title="このヘッドラインへのパーマリンク">¶</a></h1>
<div class="section" id="id1">
<h2>イントロダクション<a class="headerlink" href="#id1" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Goは新しい言語です。既存の言語からアイデアを借りていますが、その言語の特徴で書かれたプログラムとは異なる、Goのプログラムを効果的にする興味深い特徴を持っています。C++やJavaで書かれたプログラムをそのままGoに移植しても、満足な結果は得られないでしょう。JavaのプログラムはGoではなく、Javaで書かれます。一方、Goの特徴を用いると、元のプログラムとは全く異なりますが、良いものが生まれるかもしれません。Goを適切に書くのは、その特徴とイディオムを理解することが重要です。そして、他のGoプログラマーが理解しやすいように、命名規則やフォーマット、プログラムの構成といったGoの慣習を知ることも重要です。</p>
<p>このドキュメントは明確で慣用的なGoのコードを書くためのヒントを示します。<a class="reference external" href="/ref/spec">言語仕様</a> や <a class="reference external" href="//tour.golang.org/">Tour of Go</a> や <a class="reference external" href="/doc/code.html">How to Write Go Code</a> を補強するもので、最初に読むべきものです。</p>
<div class="section" id="id3">
<h3>例<a class="headerlink" href="#id3" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Go本体のパッケージのソースはコアライブラリとしてだけではなく、Goをどのように扱うかというサンプルでもあります。さらに、多くのパッケージでは <a class="reference external" href="//golang.org">golang.org</a> から直接実行できる、動作する自己完結型の実行可能サンプルが含まれています。 <a class="reference external" href="//golang.org/pkg/strings/#example_Map">この</a> ようなものです。必要に応じて &quot;Example&quot; のボタンを押すと開きます。問題へのアプローチ方法や実装方法について質問がある場合は、ライブラリのドキュメントやコード、サンプルから回答やアイデア、背景を知ることができるでしょう。</p>
</div>
</div>
<div class="section" id="id5">
<h2>フォーマット<a class="headerlink" href="#id5" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>フォーマッティングは最も議論の多い問題ですが、それほど重要な問題ではありません。開発者はさまざまなフォーマッティングスタイルに適応できますが、同じスタイルを守っている場合は、この話題に費やす時間を短縮できます。問題は、長い規範的なスタイルガイドを用いずにこのユートピアにアプローチする方法です。</p>
<p>Goでは、通常とは異なるアプローチを採用し、ほとんどのフォーマットの問題をマシンに任せます。<strong>gofmt</strong> プログラム（ソースファイルレベルではなくパッケージレベルで動作する <strong>go fmt</strong> としても利用可能）は、Goプログラムを読み取り、標準スタイルのインデントと垂直方向の配置でソースを出力し、コメントを保持し、必要に応じて再フォーマットします。 新しいレイアウトの状況を処理する方法を知りたい場合は、 <strong>gofmt</strong> を実行します。 答えが正しくないと思われる場合は、プログラムを再配置（またはgofmtに関するバグを報告）してください。そのまま使わないでください。</p>
<p>例として、構造体のフィールドにコメントを並べるのに時間を費やす必要はありません。 Gofmtがそれを行います。以下に示します。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">T</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">name</span> <span class="kt">string</span> <span class="c1">// name of the object</span>
    <span class="nx">value</span> <span class="kt">int</span> <span class="c1">// its value</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong>gofmt</strong> カラムをフォーマットします:</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">T</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">name</span>    <span class="kt">string</span> <span class="c1">// name of the object</span>
    <span class="nx">value</span>   <span class="kt">int</span>    <span class="c1">// its value</span>
<span class="p">}</span>
</pre></div>
</div>
<p>標準パッケージのすべてのGoのコードは <strong>gofmt</strong> でフォーマットされています。</p>
<p>その他の書式設定の詳細が残っています。 簡潔に説明します。</p>
<dl class="simple">
<dt>インデント</dt><dd><p>インデントにタブを使用し <strong>gofmt</strong> はデフォルトでタブを出力します。必要な場合にのみスペースを使用してください。</p>
</dd>
<dt>行の長さ</dt><dd><p>Goには行の長さの制限はありません。パンチされたカードがあふれる心配はありません。行が長すぎると感じる場合は、それを折り返し、追加のタブでインデントします。</p>
</dd>
<dt>括弧</dt><dd><p>Goでは、CやJavaよりも括弧が少なくてすみます。制御構造( <strong>if</strong>, <strong>for</strong>, <strong>switch</strong> )の構文に括弧がありません。また、演算子の優先順位の階層は短く明確です。</p>
</dd>
</dl>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">x</span><span class="o">&lt;&lt;</span><span class="mi">8</span> <span class="o">+</span> <span class="nx">y</span><span class="o">&lt;&lt;</span><span class="mi">16</span>
</pre></div>
</div>
<p>他の言語とは異なり、スペースが意味することを意味します。</p>
</div>
<div class="section" id="id6">
<h2>コメント<a class="headerlink" href="#id6" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Go provides C-style <strong>/* */</strong> block comments and C++-style <strong>//</strong> line
comments. Line comments are the norm; block comments appear mostly as
package comments, but are useful within an expression or to disable
large swaths of code.</p>
<p>The program—and web server—<strong>godoc</strong> processes Go source files to
extract documentation about the contents of the package. Comments that
appear before top-level declarations, with no intervening newlines, are
extracted along with the declaration to serve as explanatory text for
the item. The nature and style of these comments determines the quality
of the documentation <strong>godoc</strong> produces.</p>
<p>Every package should have a <em>package comment</em>, a block comment preceding
the package clause. For multi-file packages, the package comment only
needs to be present in one file, and any one will do. The package
comment should introduce the package and provide information relevant to
the package as a whole. It will appear first on the <strong>godoc</strong> page and
should set up the detailed documentation that follows.</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm">Package regexp implements a simple library for regular expressions.</span>

<span class="cm">The syntax of the regular expressions accepted is:</span>

<span class="cm">    regexp:</span>
<span class="cm">        concatenation { &#39;|&#39; concatenation }</span>
<span class="cm">    concatenation:</span>
<span class="cm">        { closure }</span>
<span class="cm">    closure:</span>
<span class="cm">        term [ &#39;*&#39; | &#39;+&#39; | &#39;?&#39; ]</span>
<span class="cm">    term:</span>
<span class="cm">        &#39;^&#39;</span>
<span class="cm">        &#39;$&#39;</span>
<span class="cm">        &#39;.&#39;</span>
<span class="cm">        character</span>
<span class="cm">        &#39;[&#39; [ &#39;^&#39; ] character-ranges &#39;]&#39;</span>
<span class="cm">        &#39;(&#39; regexp &#39;)&#39;</span>
<span class="cm">*/</span>
<span class="kn">package</span> <span class="nx">regexp</span>
</pre></div>
</div>
<p>If the package is simple, the package comment can be brief.</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// Package path implements utility routines for</span>
<span class="c1">// manipulating slash-separated filename paths.</span>
</pre></div>
</div>
<p>Comments do not need extra formatting such as banners of stars. The
generated output may not even be presented in a fixed-width font, so
don't depend on spacing for alignment—<strong>godoc</strong>, like <strong>gofmt</strong>, takes
care of that. The comments are uninterpreted plain text, so HTML and
other annotations such as <strong>_this_</strong> will reproduce <em>verbatim</em> and
should not be used. One adjustment <strong>godoc</strong> does do is to display
indented text in a fixed-width font, suitable for program snippets. The
package comment for the <strong>`fmt</strong> package &lt;/pkg/fmt/&gt;`__ uses this to
good effect.</p>
<p>Depending on the context, <strong>godoc</strong> might not even reformat comments, so
make sure they look good straight up: use correct spelling, punctuation,
and sentence structure, fold long lines, and so on.</p>
<p>Inside a package, any comment immediately preceding a top-level
declaration serves as a <em>doc comment</em> for that declaration. Every
exported (capitalized) name in a program should have a doc comment.</p>
<p>Doc comments work best as complete sentences, which allow a wide variety
of automated presentations. The first sentence should be a one-sentence
summary that starts with the name being declared.</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// Compile parses a regular expression and returns, if successful,</span>
<span class="c1">// a Regexp that can be used to match against text.</span>
<span class="kd">func</span> <span class="nx">Compile</span><span class="p">(</span><span class="nx">str</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">Regexp</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</pre></div>
</div>
<p>If every doc comment begins with the name of the item it describes, you
can use the
<a class="reference external" href="/cmd/go/#hdr-Show_documentation_for_package_or_symbol">doc</a>
subcommand of the <a class="reference external" href="/cmd/go/">go</a> tool and run the output through
<strong>grep</strong>. Imagine you couldn't remember the name &quot;Compile&quot; but were
looking for the parsing function for regular expressions, so you ran the
command,</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span>$ go doc -all regexp | grep -i parse
</pre></div>
</div>
<p>If all the doc comments in the package began, &quot;This function...&quot;,
<strong>grep</strong> wouldn't help you remember the name. But because the package
starts each doc comment with the name, you'd see something like this,
which recalls the word you're looking for.</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span>$ go doc -all regexp | grep -i parse
    Compile parses a regular expression and returns, if successful, a Regexp
    MustCompile is like Compile but panics if the expression cannot be parsed.
    parsed. It simplifies safe initialization of global variables holding
$
</pre></div>
</div>
<p>Go's declaration syntax allows grouping of declarations. A single doc
comment can introduce a group of related constants or variables. Since
the whole declaration is presented, such a comment can often be
perfunctory.</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// Error codes returned by failures to parse an expression.</span>
<span class="kd">var</span> <span class="p">(</span>
    <span class="nx">ErrInternal</span>      <span class="p">=</span> <span class="nx">errors</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="s">&quot;regexp: internal error&quot;</span><span class="p">)</span>
    <span class="nx">ErrUnmatchedLpar</span> <span class="p">=</span> <span class="nx">errors</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="s">&quot;regexp: unmatched &#39;(&#39;&quot;</span><span class="p">)</span>
    <span class="nx">ErrUnmatchedRpar</span> <span class="p">=</span> <span class="nx">errors</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="s">&quot;regexp: unmatched &#39;)&#39;&quot;</span><span class="p">)</span>
    <span class="o">...</span>
<span class="p">)</span>
</pre></div>
</div>
<p>Grouping can also indicate relationships between items, such as the fact
that a set of variables is protected by a mutex.</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="p">(</span>
    <span class="nx">countLock</span>   <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>
    <span class="nx">inputCount</span>  <span class="kt">uint32</span>
    <span class="nx">outputCount</span> <span class="kt">uint32</span>
    <span class="nx">errorCount</span>  <span class="kt">uint32</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id7">
<h2>命名<a class="headerlink" href="#id7" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>命名は他の言語と同様にGoでも重要です。セマンティックな効果もあります。外部パッケージから参照可視性は、その最小の文字が大文字かどうかで決まります。したがって、Goプログラムの命名規則について少し話をする価値があります。</p>
<div class="section" id="id8">
<h3>パッケージ名<a class="headerlink" href="#id8" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>パッケージがインポートされるとき、パッケージ名がコンテンツのアクセッサーになります。</p>
<p>以下のように</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="s">&quot;bytes&quot;</span>
</pre></div>
</div>
<p>とパッケージをインポートすると、 <strong>bytes.Buffer</strong> としてパッケージを使うことができます。パッケージを使う人が同じ名前でパッケージのコンテンツを参照すると便利です。これはパッケージ名が適切であることを意味します。短く完結で分かりやすくあるべきです。慣例としてパッケージ名は小文字の単一の単語名にします。アンダースコアやmixedCapsである必要はありません。多くの人がパッケージ名を打ち込むことを考えて、簡潔すぎるほど簡潔にしてしまう場合があります。その場合でも衝突を心配する必要はありません。パッケージ名はインポートするときのデフォルトでしかないからです。ソースコード全体で唯一である必要はありません。衝突するようなまれな場合、インポートするパッケージ名に異なる名前をつけることができます。どのような場合でも、インポート機能においてファイル名がどのパッケージで使用されるかを決めるので、混乱することはまれです。別の慣例として、パッケージ名はソースディレクトリの名前であるこということです。 <strong>src/encoding/base64</strong> にあるパッケージは <strong>&quot;encoding/base64&quot;</strong> としてインポートされます。名前は <strong>base64</strong> であって、 <strong>encoding_base64</strong> でも <strong>encodingBase64</strong> でもありません。</p>
<p>The importer of a package will use the name to refer to its contents, so
exported names in the package can use that fact to avoid stutter. (Don't
use the <strong>import .</strong> notation, which can simplify tests that must run
outside the package they are testing, but should otherwise be avoided.)
For instance, the buffered reader type in the <strong>bufio</strong> package is
called <strong>Reader</strong>, not <strong>BufReader</strong>, because users see it as
<strong>bufio.Reader</strong>, which is a clear, concise name. Moreover, because
imported entities are always addressed with their package name,
<strong>bufio.Reader</strong> does not conflict with <strong>io.Reader</strong>. Similarly, the
function to make new instances of <strong>ring.Ring</strong>—which is the definition
of a <em>constructor</em> in Go—would normally be called <strong>NewRing</strong>, but since
<strong>Ring</strong> is the only type exported by the package, and since the package
is called <strong>ring</strong>, it's called just <strong>New</strong>, which clients of the
package see as <strong>ring.New</strong>. Use the package structure to help you
choose good names.</p>
<p>Another short example is <strong>once.Do</strong>; <strong>once.Do(setup)</strong> reads well and
would not be improved by writing <strong>once.DoOrWaitUntilDone(setup)</strong>. Long
names don't automatically make things more readable. A helpful doc
comment can often be more valuable than an extra long name.</p>
</div>
<div class="section" id="getters">
<span id="id9"></span><h3>ゲッター<a class="headerlink" href="#getters" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Go doesn't provide automatic support for getters and setters. There's
nothing wrong with providing getters and setters yourself, and it's
often appropriate to do so, but it's neither idiomatic nor necessary to
put <strong>Get</strong> into the getter's name. If you have a field called <strong>owner</strong>
(lower case, unexported), the getter method should be called <strong>Owner</strong>
(upper case, exported), not <strong>GetOwner</strong>. The use of upper-case names
for export provides the hook to discriminate the field from the method.
A setter function, if needed, will likely be called <strong>SetOwner</strong>. Both
names read well in practice:</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">owner</span> <span class="o">:=</span> <span class="nx">obj</span><span class="p">.</span><span class="nx">Owner</span><span class="p">()</span>
<span class="k">if</span> <span class="nx">owner</span> <span class="o">!=</span> <span class="nx">user</span> <span class="p">{</span>
    <span class="nx">obj</span><span class="p">.</span><span class="nx">SetOwner</span><span class="p">(</span><span class="nx">user</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id10">
<h3>インターフェース名<a class="headerlink" href="#id10" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>By convention, one-method interfaces are named by the method name plus
an -er suffix or similar modification to construct an agent noun:
<strong>Reader</strong>, <strong>Writer</strong>, <strong>Formatter</strong>, <strong>CloseNotifier</strong> etc.</p>
<p>There are a number of such names and it's productive to honor them and
the function names they capture. <strong>Read</strong>, <strong>Write</strong>, <strong>Close</strong>,
<strong>Flush</strong>, <strong>String</strong> and so on have canonical signatures and meanings.
To avoid confusion, don't give your method one of those names unless it
has the same signature and meaning. Conversely, if your type implements
a method with the same meaning as a method on a well-known type, give it
the same name and signature; call your string-converter method
<strong>String</strong> not <strong>ToString</strong>.</p>
</div>
<div class="section" id="mixedcaps">
<span id="mixed-caps"></span><h3>MixedCaps<a class="headerlink" href="#mixedcaps" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Finally, the convention in Go is to use <strong>MixedCaps</strong> or <strong>mixedCaps</strong>
rather than underscores to write multiword names.</p>
</div>
</div>
<div class="section" id="id11">
<h2>セミコロン<a class="headerlink" href="#id11" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Like C, Go's formal grammar uses semicolons to terminate statements, but
unlike in C, those semicolons do not appear in the source. Instead the
lexer uses a simple rule to insert semicolons automatically as it scans,
so the input text is mostly free of them.</p>
<p>The rule is this. If the last token before a newline is an identifier
(which includes words like <strong>int</strong> and <strong>float64</strong>), a basic literal
such as a number or string constant, or one of the tokens</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="k">break</span> <span class="k">continue</span> <span class="k">fallthrough</span> <span class="k">return</span> <span class="o">++</span> <span class="o">--</span> <span class="p">)</span> <span class="p">}</span>
</pre></div>
</div>
<p>the lexer always inserts a semicolon after the token. This could be
summarized as, “if the newline comes after a token that could end a
statement, insert a semicolon”.</p>
<p>A semicolon can also be omitted immediately before a closing brace, so a
statement such as</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="k">for</span> <span class="p">{</span> <span class="nx">dst</span> <span class="o">&lt;-</span> <span class="o">&lt;-</span><span class="nx">src</span> <span class="p">}</span> <span class="p">}()</span>
</pre></div>
</div>
<p>needs no semicolons. Idiomatic Go programs have semicolons only in
places such as <strong>for</strong> loop clauses, to separate the initializer,
condition, and continuation elements. They are also necessary to
separate multiple statements on a line, should you write code that way.</p>
<p>One consequence of the semicolon insertion rules is that you cannot put
the opening brace of a control structure (<strong>if</strong>, <strong>for</strong>, <strong>switch</strong>,
or <strong>select</strong>) on the next line. If you do, a semicolon will be inserted
before the brace, which could cause unwanted effects. Write them like
this</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">f</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">g</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>
</div>
<p>not like this</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">f</span><span class="p">()</span>  <span class="c1">// wrong!</span>
<span class="p">{</span>           <span class="c1">// wrong!</span>
    <span class="nx">g</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="control-structures">
<h2>制御構造(Control structures)<a class="headerlink" href="#control-structures" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>The control structures of Go are related to those of C but differ in
important ways. There is no <strong>do</strong> or <strong>while</strong> loop, only a slightly
generalized <strong>for</strong>; <strong>switch</strong> is more flexible; <strong>if</strong> and <strong>switch</strong>
accept an optional initialization statement like that of <strong>for</strong>;
<strong>break</strong> and <strong>continue</strong> statements take an optional label to identify
what to break or continue; and there are new control structures
including a type switch and a multiway communications multiplexer,
<strong>select</strong>. The syntax is also slightly different: there are no
parentheses and the bodies must always be brace-delimited.</p>
<div class="section" id="if">
<h3>If<a class="headerlink" href="#if" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>In Go a simple <strong>if</strong> looks like this:</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="nx">x</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">y</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Mandatory braces encourage writing simple <strong>if</strong> statements on multiple
lines. It's good style to do so anyway, especially when the body
contains a control statement such as a <strong>return</strong> or <strong>break</strong>.</p>
<p>Since <strong>if</strong> and <strong>switch</strong> accept an initialization statement, it's
common to see one used to set up a local variable.</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">file</span><span class="p">.</span><span class="nx">Chmod</span><span class="p">(</span><span class="mo">0664</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nx">Print</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">err</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In the Go libraries, you'll find that when an <strong>if</strong> statement doesn't
flow into the next statement—that is, the body ends in <strong>break</strong>,
<strong>continue</strong>, <strong>goto</strong>, or <strong>return</strong>—the unnecessary <strong>else</strong> is
omitted.</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">f</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Open</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">err</span>
<span class="p">}</span>
<span class="nx">codeUsing</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span>
</pre></div>
</div>
<p>This is an example of a common situation where code must guard against a
sequence of error conditions. The code reads well if the successful flow
of control runs down the page, eliminating error cases as they arise.
Since error cases tend to end in <strong>return</strong> statements, the resulting
code needs no <strong>else</strong> statements.</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">f</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Open</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">err</span>
<span class="p">}</span>
<span class="nx">d</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">f</span><span class="p">.</span><span class="nx">Stat</span><span class="p">()</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">f</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>
    <span class="k">return</span> <span class="nx">err</span>
<span class="p">}</span>
<span class="nx">codeUsing</span><span class="p">(</span><span class="nx">f</span><span class="p">,</span> <span class="nx">d</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="redeclaration-and-reassignment">
<span id="redeclaration"></span><h3>Redeclaration and reassignment<a class="headerlink" href="#redeclaration-and-reassignment" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>An aside: The last example in the previous section demonstrates a detail
of how the <strong>:=</strong> short declaration form works. The declaration that
calls <strong>os.Open</strong> reads,</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">f</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Open</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span>
</pre></div>
</div>
<p>This statement declares two variables, <strong>f</strong> and <strong>err</strong>. A few lines
later, the call to <strong>f.Stat</strong> reads,</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">d</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">f</span><span class="p">.</span><span class="nx">Stat</span><span class="p">()</span>
</pre></div>
</div>
<p>which looks as if it declares <strong>d</strong> and <strong>err</strong>. Notice, though, that
<strong>err</strong> appears in both statements. This duplication is legal: <strong>err</strong>
is declared by the first statement, but only <em>re-assigned</em> in the
second. This means that the call to <strong>f.Stat</strong> uses the existing <strong>err</strong>
variable declared above, and just gives it a new value.</p>
<p>In a <strong>:=</strong> declaration a variable <strong>v</strong> may appear even if it has
already been declared, provided:</p>
<ul class="simple">
<li><p>this declaration is in the same scope as the existing declaration of
<strong>v</strong> (if <strong>v</strong> is already declared in an outer scope, the
declaration will create a new variable §),</p></li>
<li><p>the corresponding value in the initialization is assignable to <strong>v</strong>,
and</p></li>
<li><p>there is at least one other variable that is created by the
declaration.</p></li>
</ul>
<p>This unusual property is pure pragmatism, making it easy to use a single
<strong>err</strong> value, for example, in a long <strong>if-else</strong> chain. You'll see it
used often.</p>
<p>§ It's worth noting here that in Go the scope of function parameters and
return values is the same as the function body, even though they appear
lexically outside the braces that enclose the body.</p>
</div>
<div class="section" id="for">
<h3>For<a class="headerlink" href="#for" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>The Go <strong>for</strong> loop is similar to—but not the same as—C's. It unifies
<strong>for</strong> and <strong>while</strong> and there is no <strong>do-while</strong>. There are three
forms, only one of which has semicolons.</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// Like a C for</span>
<span class="k">for</span> <span class="nx">init</span><span class="p">;</span> <span class="nx">condition</span><span class="p">;</span> <span class="nx">post</span> <span class="p">{</span> <span class="p">}</span>

<span class="c1">// Like a C while</span>
<span class="k">for</span> <span class="nx">condition</span> <span class="p">{</span> <span class="p">}</span>

<span class="c1">// Like a C for(;;)</span>
<span class="k">for</span> <span class="p">{</span> <span class="p">}</span>
</pre></div>
</div>
<p>Short declarations make it easy to declare the index variable right in
the loop.</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">sum</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
    <span class="nx">sum</span> <span class="o">+=</span> <span class="nx">i</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If you're looping over an array, slice, string, or map, or reading from
a channel, a <strong>range</strong> clause can manage the loop.</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">value</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">oldMap</span> <span class="p">{</span>
    <span class="nx">newMap</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="p">=</span> <span class="nx">value</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If you only need the first item in the range (the key or index), drop
the second:</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="nx">key</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">m</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">key</span><span class="p">.</span><span class="nx">expired</span><span class="p">()</span> <span class="p">{</span>
        <span class="nb">delete</span><span class="p">(</span><span class="nx">m</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If you only need the second item in the range (the value), use the
<em>blank identifier</em>, an underscore, to discard the first:</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">sum</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">value</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">array</span> <span class="p">{</span>
    <span class="nx">sum</span> <span class="o">+=</span> <span class="nx">value</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The blank identifier has many uses, as described in <a class="reference external" href="#blank">a later
section</a>.</p>
<p>For strings, the <strong>range</strong> does more work for you, breaking out
individual Unicode code points by parsing the UTF-8. Erroneous encodings
consume one byte and produce the replacement rune U+FFFD. (The name
(with associated builtin type) <strong>rune</strong> is Go terminology for a single
Unicode code point. See <a class="reference external" href="/ref/spec#Rune_literals">the language
specification</a> for details.) The loop</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="nx">pos</span><span class="p">,</span> <span class="nx">char</span> <span class="o">:=</span> <span class="k">range</span> <span class="s">&quot;日本\x80語&quot;</span> <span class="p">{</span> <span class="c1">// \x80 is an illegal UTF-8 encoding</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;character %#U starts at byte position %d\n&quot;</span><span class="p">,</span> <span class="nx">char</span><span class="p">,</span> <span class="nx">pos</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>prints</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">character</span> <span class="nx">U</span><span class="o">+</span><span class="mf">65E5</span> <span class="sc">&#39;日&#39;</span> <span class="nx">starts</span> <span class="nx">at</span> <span class="kt">byte</span> <span class="nx">position</span> <span class="mi">0</span>
<span class="nx">character</span> <span class="nx">U</span><span class="o">+</span><span class="mi">672</span><span class="nx">C</span> <span class="sc">&#39;本&#39;</span> <span class="nx">starts</span> <span class="nx">at</span> <span class="kt">byte</span> <span class="nx">position</span> <span class="mi">3</span>
<span class="nx">character</span> <span class="nx">U</span><span class="o">+</span><span class="nx">FFFD</span> <span class="sc">&#39;�&#39;</span> <span class="nx">starts</span> <span class="nx">at</span> <span class="kt">byte</span> <span class="nx">position</span> <span class="mi">6</span>
<span class="nx">character</span> <span class="nx">U</span><span class="o">+</span><span class="mi">8</span><span class="nx">A9E</span> <span class="sc">&#39;語&#39;</span> <span class="nx">starts</span> <span class="nx">at</span> <span class="kt">byte</span> <span class="nx">position</span> <span class="mi">7</span>
</pre></div>
</div>
<p>Finally, Go has no comma operator and <strong>++</strong> and <strong>--</strong> are statements
not expressions. Thus if you want to run multiple variables in a <strong>for</strong>
you should use parallel assignment (although that precludes <strong>++</strong> and
<strong>--</strong>).</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// Reverse a</span>
<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">j</span><span class="p">;</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="p">=</span> <span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nx">j</span><span class="o">-</span><span class="mi">1</span> <span class="p">{</span>
    <span class="nx">a</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">a</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">a</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span> <span class="nx">a</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="switch">
<h3>Switch<a class="headerlink" href="#switch" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Go's <strong>switch</strong> is more general than C's. The expressions need not be
constants or even integers, the cases are evaluated top to bottom until
a match is found, and if the <strong>switch</strong> has no expression it switches on
<strong>true</strong>. It's therefore possible—and idiomatic—to write an
<strong>if</strong>-<strong>else</strong>-<strong>if</strong>-<strong>else</strong> chain as a <strong>switch</strong>.</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">unhex</span><span class="p">(</span><span class="nx">c</span> <span class="kt">byte</span><span class="p">)</span> <span class="kt">byte</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="p">{</span>
    <span class="k">case</span> <span class="sc">&#39;0&#39;</span> <span class="o">&lt;=</span> <span class="nx">c</span> <span class="o">&amp;&amp;</span> <span class="nx">c</span> <span class="o">&lt;=</span> <span class="sc">&#39;9&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="nx">c</span> <span class="o">-</span> <span class="sc">&#39;0&#39;</span>
    <span class="k">case</span> <span class="sc">&#39;a&#39;</span> <span class="o">&lt;=</span> <span class="nx">c</span> <span class="o">&amp;&amp;</span> <span class="nx">c</span> <span class="o">&lt;=</span> <span class="sc">&#39;f&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="nx">c</span> <span class="o">-</span> <span class="sc">&#39;a&#39;</span> <span class="o">+</span> <span class="mi">10</span>
    <span class="k">case</span> <span class="sc">&#39;A&#39;</span> <span class="o">&lt;=</span> <span class="nx">c</span> <span class="o">&amp;&amp;</span> <span class="nx">c</span> <span class="o">&lt;=</span> <span class="sc">&#39;F&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="nx">c</span> <span class="o">-</span> <span class="sc">&#39;A&#39;</span> <span class="o">+</span> <span class="mi">10</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span>
<span class="p">}</span>
</pre></div>
</div>
<p>There is no automatic fall through, but cases can be presented in
comma-separated lists.</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">shouldEscape</span><span class="p">(</span><span class="nx">c</span> <span class="kt">byte</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="nx">c</span> <span class="p">{</span>
    <span class="k">case</span> <span class="sc">&#39; &#39;</span><span class="p">,</span> <span class="sc">&#39;?&#39;</span><span class="p">,</span> <span class="sc">&#39;&amp;&#39;</span><span class="p">,</span> <span class="sc">&#39;=&#39;</span><span class="p">,</span> <span class="sc">&#39;#&#39;</span><span class="p">,</span> <span class="sc">&#39;+&#39;</span><span class="p">,</span> <span class="sc">&#39;%&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">true</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="kc">false</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Although they are not nearly as common in Go as some other C-like
languages, <strong>break</strong> statements can be used to terminate a <strong>switch</strong>
early. Sometimes, though, it's necessary to break out of a surrounding
loop, not the switch, and in Go that can be accomplished by putting a
label on the loop and &quot;breaking&quot; to that label. This example shows both
uses.</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">Loop</span><span class="p">:</span>
    <span class="k">for</span> <span class="nx">n</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">n</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">src</span><span class="p">);</span> <span class="nx">n</span> <span class="o">+=</span> <span class="nx">size</span> <span class="p">{</span>
        <span class="k">switch</span> <span class="p">{</span>
        <span class="k">case</span> <span class="nx">src</span><span class="p">[</span><span class="nx">n</span><span class="p">]</span> <span class="p">&lt;</span> <span class="nx">sizeOne</span><span class="p">:</span>
            <span class="k">if</span> <span class="nx">validateOnly</span> <span class="p">{</span>
                <span class="k">break</span>
            <span class="p">}</span>
            <span class="nx">size</span> <span class="p">=</span> <span class="mi">1</span>
            <span class="nx">update</span><span class="p">(</span><span class="nx">src</span><span class="p">[</span><span class="nx">n</span><span class="p">])</span>

        <span class="k">case</span> <span class="nx">src</span><span class="p">[</span><span class="nx">n</span><span class="p">]</span> <span class="p">&lt;</span> <span class="nx">sizeTwo</span><span class="p">:</span>
            <span class="k">if</span> <span class="nx">n</span><span class="o">+</span><span class="mi">1</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">src</span><span class="p">)</span> <span class="p">{</span>
                <span class="nx">err</span> <span class="p">=</span> <span class="nx">errShortInput</span>
                <span class="k">break</span> <span class="nx">Loop</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="nx">validateOnly</span> <span class="p">{</span>
                <span class="k">break</span>
            <span class="p">}</span>
            <span class="nx">size</span> <span class="p">=</span> <span class="mi">2</span>
            <span class="nx">update</span><span class="p">(</span><span class="nx">src</span><span class="p">[</span><span class="nx">n</span><span class="p">]</span> <span class="o">+</span> <span class="nx">src</span><span class="p">[</span><span class="nx">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="nx">shift</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
</pre></div>
</div>
<p>Of course, the <strong>continue</strong> statement also accepts an optional label but
it applies only to loops.</p>
<p>To close this section, here's a comparison routine for byte slices that
uses two <strong>switch</strong> statements:</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// Compare returns an integer comparing the two byte slices,</span>
<span class="c1">// lexicographically.</span>
<span class="c1">// The result will be 0 if a == b, -1 if a &lt; b, and +1 if a &gt; b</span>
<span class="kd">func</span> <span class="nx">Compare</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">b</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="k">switch</span> <span class="p">{</span>
        <span class="k">case</span> <span class="nx">a</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">&gt;</span> <span class="nx">b</span><span class="p">[</span><span class="nx">i</span><span class="p">]:</span>
            <span class="k">return</span> <span class="mi">1</span>
        <span class="k">case</span> <span class="nx">a</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">&lt;</span> <span class="nx">b</span><span class="p">[</span><span class="nx">i</span><span class="p">]:</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">switch</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nb">len</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="p">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">b</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="k">case</span> <span class="nb">len</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">b</span><span class="p">):</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="type-switch">
<span id="id12"></span><h3>Type switch<a class="headerlink" href="#type-switch" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>A switch can also be used to discover the dynamic type of an interface
variable. Such a <em>type switch</em> uses the syntax of a type assertion with
the keyword <strong>type</strong> inside the parentheses. If the switch declares a
variable in the expression, the variable will have the corresponding
type in each clause. It's also idiomatic to reuse the name in such
cases, in effect declaring a new variable with the same name but a
different type in each case.</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">t</span> <span class="kd">interface</span><span class="p">{}</span>
<span class="nx">t</span> <span class="p">=</span> <span class="nx">functionOfSomeType</span><span class="p">()</span>
<span class="k">switch</span> <span class="nx">t</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.(</span><span class="kd">type</span><span class="p">)</span> <span class="p">{</span>
<span class="k">default</span><span class="p">:</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;unexpected type %T\n&quot;</span><span class="p">,</span> <span class="nx">t</span><span class="p">)</span>     <span class="c1">// %T prints whatever type t has</span>
<span class="k">case</span> <span class="kt">bool</span><span class="p">:</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;boolean %t\n&quot;</span><span class="p">,</span> <span class="nx">t</span><span class="p">)</span>             <span class="c1">// t has type bool</span>
<span class="k">case</span> <span class="kt">int</span><span class="p">:</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;integer %d\n&quot;</span><span class="p">,</span> <span class="nx">t</span><span class="p">)</span>             <span class="c1">// t has type int</span>
<span class="k">case</span> <span class="o">*</span><span class="kt">bool</span><span class="p">:</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;pointer to boolean %t\n&quot;</span><span class="p">,</span> <span class="o">*</span><span class="nx">t</span><span class="p">)</span> <span class="c1">// t has type *bool</span>
<span class="k">case</span> <span class="o">*</span><span class="kt">int</span><span class="p">:</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;pointer to integer %d\n&quot;</span><span class="p">,</span> <span class="o">*</span><span class="nx">t</span><span class="p">)</span> <span class="c1">// t has type *int</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id13">
<h2>関数<a class="headerlink" href="#id13" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="multiple-returns">
<span id="id14"></span><h3>多値返却<a class="headerlink" href="#multiple-returns" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>One of Go's unusual features is that functions and methods can return
multiple values. This form can be used to improve on a couple of clumsy
idioms in C programs: in-band error returns such as <strong>-1</strong> for <strong>EOF</strong>
and modifying an argument passed by address.</p>
<p>In C, a write error is signaled by a negative count with the error code
secreted away in a volatile location. In Go, <strong>Write</strong> can return a
count <em>and</em> an error: “Yes, you wrote some bytes but not all of them
because you filled the device”. The signature of the <strong>Write</strong> method on
files from package <strong>os</strong> is:</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="p">(</span><span class="nx">file</span> <span class="o">*</span><span class="nx">File</span><span class="p">)</span> <span class="nx">Write</span><span class="p">(</span><span class="nx">b</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
</pre></div>
</div>
<p>and as the documentation says, it returns the number of bytes written
and a non-nil <strong>error</strong> when <strong>n</strong> <strong>!=</strong> <strong>len(b)</strong>. This is a common
style; see the section on error handling for more examples.</p>
<p>A similar approach obviates the need to pass a pointer to a return value
to simulate a reference parameter. Here's a simple-minded function to
grab a number from a position in a byte slice, returning the number and
the next position.</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">nextInt</span><span class="p">(</span><span class="nx">b</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">i</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">isDigit</span><span class="p">(</span><span class="nx">b</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
    <span class="p">}</span>
    <span class="nx">x</span> <span class="o">:=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">isDigit</span><span class="p">(</span><span class="nx">b</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="nx">x</span> <span class="p">=</span> <span class="nx">x</span><span class="o">*</span><span class="mi">10</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="nx">b</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span> <span class="o">-</span> <span class="sc">&#39;0&#39;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">i</span>
<span class="p">}</span>
</pre></div>
</div>
<p>You could use it to scan the numbers in an input slice <strong>b</strong> like this:</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">b</span><span class="p">);</span> <span class="p">{</span>
    <span class="nx">x</span><span class="p">,</span> <span class="nx">i</span> <span class="p">=</span> <span class="nx">nextInt</span><span class="p">(</span><span class="nx">b</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="named-result-parameters">
<span id="named-results"></span><h3>名前付き結果変数(Named result parameters)<a class="headerlink" href="#named-result-parameters" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>The return or result &quot;parameters&quot; of a Go function can be given names
and used as regular variables, just like the incoming parameters. When
named, they are initialized to the zero values for their types when the
function begins; if the function executes a <strong>return</strong> statement with no
arguments, the current values of the result parameters are used as the
returned values.</p>
<p>The names are not mandatory but they can make code shorter and clearer:
they're documentation. If we name the results of <strong>nextInt</strong> it becomes
obvious which returned <strong>int</strong> is which.</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">nextInt</span><span class="p">(</span><span class="nx">b</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">pos</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="nx">value</span><span class="p">,</span> <span class="nx">nextPos</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</pre></div>
</div>
<p>Because named results are initialized and tied to an unadorned return,
they can simplify as well as clarify. Here's a version of
<strong>io.ReadFull</strong> that uses them well:</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">ReadFull</span><span class="p">(</span><span class="nx">r</span> <span class="nx">Reader</span><span class="p">,</span> <span class="nx">buf</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nb">len</span><span class="p">(</span><span class="nx">buf</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">nr</span> <span class="kt">int</span>
        <span class="nx">nr</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Read</span><span class="p">(</span><span class="nx">buf</span><span class="p">)</span>
        <span class="nx">n</span> <span class="o">+=</span> <span class="nx">nr</span>
        <span class="nx">buf</span> <span class="p">=</span> <span class="nx">buf</span><span class="p">[</span><span class="nx">nr</span><span class="p">:]</span>
    <span class="p">}</span>
    <span class="k">return</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="defer">
<h3>Defer<a class="headerlink" href="#defer" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Go's <strong>defer</strong> statement schedules a function call (the <em>deferred</em>
function) to be run immediately before the function executing the
<strong>defer</strong> returns. It's an unusual but effective way to deal with
situations such as resources that must be released regardless of which
path a function takes to return. The canonical examples are unlocking a
mutex or closing a file.</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// Contents returns the file&#39;s contents as a string.</span>
<span class="kd">func</span> <span class="nx">Contents</span><span class="p">(</span><span class="nx">filename</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">f</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Open</span><span class="p">(</span><span class="nx">filename</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="nx">err</span>
    <span class="p">}</span>
    <span class="k">defer</span> <span class="nx">f</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>  <span class="c1">// f.Close will run when we&#39;re finished.</span>

    <span class="kd">var</span> <span class="nx">result</span> <span class="p">[]</span><span class="kt">byte</span>
    <span class="nx">buf</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
    <span class="k">for</span> <span class="p">{</span>
        <span class="nx">n</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">f</span><span class="p">.</span><span class="nx">Read</span><span class="p">(</span><span class="nx">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">:])</span>
        <span class="nx">result</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span> <span class="nx">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="nx">n</span><span class="p">]</span><span class="o">...</span><span class="p">)</span> <span class="c1">// append is discussed later.</span>
        <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">io</span><span class="p">.</span><span class="nx">EOF</span> <span class="p">{</span>
                <span class="k">break</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="nx">err</span>  <span class="c1">// f will be closed if we return here.</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">string</span><span class="p">(</span><span class="nx">result</span><span class="p">),</span> <span class="kc">nil</span> <span class="c1">// f will be closed if we return here.</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Deferring a call to a function such as <strong>Close</strong> has two advantages.
First, it guarantees that you will never forget to close the file, a
mistake that's easy to make if you later edit the function to add a new
return path. Second, it means that the close sits near the open, which
is much clearer than placing it at the end of the function.</p>
<p>The arguments to the deferred function (which include the receiver if
the function is a method) are evaluated when the <em>defer</em> executes, not
when the <em>call</em> executes. Besides avoiding worries about variables
changing values as the function executes, this means that a single
deferred call site can defer multiple function executions. Here's a
silly example.</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
    <span class="k">defer</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%d &quot;</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Deferred functions are executed in LIFO order, so this code will cause
<strong>4 3 2 1 0</strong> to be printed when the function returns. A more plausible
example is a simple way to trace function execution through the program.
We could write a couple of simple tracing routines like this:</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">trace</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span>   <span class="p">{</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;entering:&quot;</span><span class="p">,</span> <span class="nx">s</span><span class="p">)</span> <span class="p">}</span>
<span class="kd">func</span> <span class="nx">untrace</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;leaving:&quot;</span><span class="p">,</span> <span class="nx">s</span><span class="p">)</span> <span class="p">}</span>

<span class="c1">// Use them like this:</span>
<span class="kd">func</span> <span class="nx">a</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">trace</span><span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">)</span>
    <span class="k">defer</span> <span class="nx">untrace</span><span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">)</span>
    <span class="c1">// do something....</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We can do better by exploiting the fact that arguments to deferred
functions are evaluated when the <strong>defer</strong> executes. The tracing routine
can set up the argument to the untracing routine. This example:</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">trace</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;entering:&quot;</span><span class="p">,</span> <span class="nx">s</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">s</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">un</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;leaving:&quot;</span><span class="p">,</span> <span class="nx">s</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">a</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">defer</span> <span class="nx">un</span><span class="p">(</span><span class="nx">trace</span><span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">))</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;in a&quot;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">b</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">defer</span> <span class="nx">un</span><span class="p">(</span><span class="nx">trace</span><span class="p">(</span><span class="s">&quot;b&quot;</span><span class="p">))</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;in b&quot;</span><span class="p">)</span>
    <span class="nx">a</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">b</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>
</div>
<p>prints</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">entering</span><span class="p">:</span> <span class="nx">b</span>
<span class="nx">in</span> <span class="nx">b</span>
<span class="nx">entering</span><span class="p">:</span> <span class="nx">a</span>
<span class="nx">in</span> <span class="nx">a</span>
<span class="nx">leaving</span><span class="p">:</span> <span class="nx">a</span>
<span class="nx">leaving</span><span class="p">:</span> <span class="nx">b</span>
</pre></div>
</div>
<p>For programmers accustomed to block-level resource management from other
languages, <strong>defer</strong> may seem peculiar, but its most interesting and
powerful applications come precisely from the fact that it's not
block-based but function-based. In the section on <strong>panic</strong> and
<strong>recover</strong> we'll see another example of its possibilities.</p>
</div>
</div>
<div class="section" id="id15">
<h2>データ<a class="headerlink" href="#id15" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="new">
<h3><strong>new</strong> によるアロケーション<a class="headerlink" href="#new" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Goは2つのメモリアロケーションのプリミティブを持っています。組み込み関数である <strong>new</strong> と <strong>make</strong> です。それらは異なることを行い、異なる型に適用するため困惑するかもしれません。しかしルールはシンプルです。まず <strong>new</strong> について説明しましょう。これはメモリをアロケーションする組み込み関数ですが、他のいくつかの言語の同じ関数名のそれとは異なり、メモリを <strong>初期化</strong> せず、ゼロにするだけです。つまり <strong>new(T)</strong> は、型Tの新しい要素にゼロ化されたメモリを割り当て、型*Tの値であるアドレスを返します。 Goの用語では、型Tとして新しく割り当てられたゼロ値へのポインターを返します。</p>
<p><strong>new</strong> によって返されるメモリはゼロ化されます。これはデータ構造を設計する際に、各タイプのゼロ値をさらに初期化せずに使用できるように設計すると役立ちます。 データ構造を用いる開発者が <strong>new</strong> で変数を作成し、適切に動作できることを意味します。 たとえば、 <strong>bytes.Buffer</strong> のドキュメントには、「Bufferのゼロ値はすぐに使用できる空のバッファーです」と記載されています。 同様に <strong>sync.Mutex</strong> には明示的なコンストラクターまたは <strong>Init</strong> メソッドがありません。 代わりに <strong>sync.Mutex</strong> のゼロ値は非ロック状態のミューテックスとして定義されます。</p>
<p>ゼロ値の性質は推移的に機能します。以下の型宣言について考えてください。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">SyncedBuffer</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">lock</span>    <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>
    <span class="nx">buffer</span>  <span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span>
<span class="p">}</span>
</pre></div>
</div>
<p>型 <strong>SyncedBuffer</strong> の値も <strong>new</strong> によるメモリアロケーションや変数の宣言だけですぐに使用できます。次のスニペットでは <strong>p</strong> と <strong>v</strong> の両方が、追加のメソッドなどを用いることなく正しく機能します。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">p</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">SyncedBuffer</span><span class="p">)</span>  <span class="c1">// type *SyncedBuffer</span>
<span class="kd">var</span> <span class="nx">v</span> <span class="nx">SyncedBuffer</span>      <span class="c1">// type  SyncedBuffer</span>
</pre></div>
</div>
</div>
<div class="section" id="id16">
<h3>コンストラクタと複合リテラル<a class="headerlink" href="#id16" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>パッケージ <strong>os</strong> から派生したこの例のように、ゼロ値では不十分な場合があり、初期化コンストラクターが必要になる場合があります。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">NewFile</span><span class="p">(</span><span class="nx">fd</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">name</span> <span class="kt">string</span><span class="p">)</span> <span class="o">*</span><span class="nx">File</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">fd</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">nil</span>
    <span class="p">}</span>
    <span class="nx">f</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">File</span><span class="p">)</span>
    <span class="nx">f</span><span class="p">.</span><span class="nx">fd</span> <span class="p">=</span> <span class="nx">fd</span>
    <span class="nx">f</span><span class="p">.</span><span class="nx">name</span> <span class="p">=</span> <span class="nx">name</span>
    <span class="nx">f</span><span class="p">.</span><span class="nx">dirinfo</span> <span class="p">=</span> <span class="kc">nil</span>
    <span class="nx">f</span><span class="p">.</span><span class="nx">nepipe</span> <span class="p">=</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="nx">f</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上記はたくさんのボイラープレートがあり冗長です。複合リテラルを使用して単純化できます。複合リテラルは、評価されるたびに新しいインスタンスを作成する式です。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">NewFile</span><span class="p">(</span><span class="nx">fd</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">name</span> <span class="kt">string</span><span class="p">)</span> <span class="o">*</span><span class="nx">File</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">fd</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">nil</span>
    <span class="p">}</span>
    <span class="nx">f</span> <span class="o">:=</span> <span class="nx">File</span><span class="p">{</span><span class="nx">fd</span><span class="p">,</span> <span class="nx">name</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="mi">0</span><span class="p">}</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="nx">f</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Cとは異なり、ローカル変数のアドレスを返すことはまったく問題ありません。 変数に関連付けられたアドレスは、関数がreturnされた後も生き残ります。 実際、複合リテラルのアドレスを取得すると、評価されるたびに新しいインスタンスが割り当てられるため、これらの最後の2行を結合できます。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="k">return</span> <span class="o">&amp;</span><span class="nx">File</span><span class="p">{</span><span class="nx">fd</span><span class="p">,</span> <span class="nx">name</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="mi">0</span><span class="p">}</span>
</pre></div>
</div>
<p>複合リテラルのフィールドは順番に配置され、すべて存在する必要があります。 ただし、要素に <strong>field：value</strong> のペアとして明示的にラベルを付けることができます。その場合、フィールドは任意の順序で表示でき、指定されていないフィールドはゼロ値で初期化されます。 したがって、上記の例は以下のように書きかえることができます。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="k">return</span> <span class="o">&amp;</span><span class="nx">File</span><span class="p">{</span><span class="nx">fd</span><span class="p">:</span> <span class="nx">fd</span><span class="p">,</span> <span class="nx">name</span><span class="p">:</span> <span class="nx">name</span><span class="p">}</span>
</pre></div>
</div>
<p>稀なケースとして、複合リテラルにフィールドがまったく含まれていない場合、その型のゼロ値が作成されます。式 <strong>new(File)**と **&amp;File{}</strong> は同等です。</p>
<p>複合リテラルは配列、スライス、マップも作成できます。フィールドラベルは、必要に応じてインデックスまたはマップのキーになります。 以下の例では、初期化は <code class="docutils literal notranslate"><span class="pre">Eonee</span></code>, <code class="docutils literal notranslate"><span class="pre">Eio</span></code> および <code class="docutils literal notranslate"><span class="pre">Einval</span></code> が相異なっていれば、値に関係なく機能します。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">a</span> <span class="o">:=</span> <span class="p">[</span><span class="o">...</span><span class="p">]</span><span class="kt">string</span>   <span class="p">{</span><span class="nx">Enone</span><span class="p">:</span> <span class="s">&quot;no error&quot;</span><span class="p">,</span> <span class="nx">Eio</span><span class="p">:</span> <span class="s">&quot;Eio&quot;</span><span class="p">,</span> <span class="nx">Einval</span><span class="p">:</span> <span class="s">&quot;invalid argument&quot;</span><span class="p">}</span>
<span class="nx">s</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">string</span>      <span class="p">{</span><span class="nx">Enone</span><span class="p">:</span> <span class="s">&quot;no error&quot;</span><span class="p">,</span> <span class="nx">Eio</span><span class="p">:</span> <span class="s">&quot;Eio&quot;</span><span class="p">,</span> <span class="nx">Einval</span><span class="p">:</span> <span class="s">&quot;invalid argument&quot;</span><span class="p">}</span>
<span class="nx">m</span> <span class="o">:=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">string</span><span class="p">{</span><span class="nx">Enone</span><span class="p">:</span> <span class="s">&quot;no error&quot;</span><span class="p">,</span> <span class="nx">Eio</span><span class="p">:</span> <span class="s">&quot;Eio&quot;</span><span class="p">,</span> <span class="nx">Einval</span><span class="p">:</span> <span class="s">&quot;invalid argument&quot;</span><span class="p">}</span>
</pre></div>
</div>
<p>訳注: <a class="reference external" href="https://play.golang.org/p/2DaYxFnjE6X">https://play.golang.org/p/2DaYxFnjE6X</a></p>
</div>
<div class="section" id="make">
<h3><strong>make</strong> によるアロケーション<a class="headerlink" href="#make" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>メモリのアロケーションの話題に戻ります。 組み込み関数 <strong>make(T, args)</strong> は、<strong>new(T)</strong> とは異なる目的で用います。 スライス、マップ、およびチャンネルのみを作成し、型 <strong>T</strong> (*T ではなく）で初期化された（ゼロではない）値を返します。<strong>new(T)</strong> と区別している理由は、これらの3つの型が、使用前に初期化する必要があるデータ構造への参照を内部的に表しているためです。 たとえば、スライスは、データ（配列内）へのポインター、長さ、および容量の3つの項目を持っています。これらの項目が初期化されるまで、スライスはnilです。 スライス、マップ、およびチャネルの場合 <strong>make</strong> は内部データ構造を初期化し、使用する値を準備します。 例えば、</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
</pre></div>
</div>
<p>100個のintの配列を割り当て、長さ10、配列の最初の10要素を指す容量100のスライス構造を作成します。 （スライスを作成するとき、容量は省略できます。詳細については、スライスに関するセクションを参照してください。）一方 <code class="docutils literal notranslate"><span class="pre">new([]int)</span></code> は、新しく割り当てられたゼロ化されたスライスへのポインター、つまり <strong>nil</strong> スライスのポインターを返します。</p>
<p>以下のサンプルは、 <strong>new</strong> と <strong>make</strong> の違いを示しています。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">p</span> <span class="o">*</span><span class="p">[]</span><span class="kt">int</span> <span class="p">=</span> <span class="nb">new</span><span class="p">([]</span><span class="kt">int</span><span class="p">)</span>       <span class="c1">// allocates slice structure; *p == nil; rarely useful</span>
<span class="kd">var</span> <span class="nx">v</span>  <span class="p">[]</span><span class="kt">int</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span> <span class="c1">// the slice v now refers to a new array of 100 ints</span>

<span class="c1">// Unnecessarily complex:</span>
<span class="kd">var</span> <span class="nx">p</span> <span class="o">*</span><span class="p">[]</span><span class="kt">int</span> <span class="p">=</span> <span class="nb">new</span><span class="p">([]</span><span class="kt">int</span><span class="p">)</span>
<span class="o">*</span><span class="nx">p</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>

<span class="c1">// Idiomatic:</span>
<span class="nx">v</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>make</strong> はマップ、スライス、およびチャンネルにのみ適用され、ポインターを返さないことに注意してください。明示的なポインタを取得するには、newで割り当てるか、変数のアドレスを明示的に取得します。</p>
</div>
<div class="section" id="id17">
<h3>配列<a class="headerlink" href="#id17" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>配列は、メモリレイアウトの詳細がわかっているときに役立ち、割り当てを回避するのに役立つ場合があります。しかし、主に次のセクションの主題であるスライスの素材として使われます。 そのスライスの基礎を築くために、配列に関するいくつかの言葉を以下に示します。</p>
<p>GoとCで配列が機能する方法には大きな違いがあります。Goでは</p>
<ul class="simple">
<li><p>配列は値です。ある配列を別の配列に割り当てると、すべての要素がコピーされます。</p></li>
<li><p>特に、関数に配列を渡すと、配列へのポインターではなく配列のコピーを受け取ります。</p></li>
<li><p>配列のサイズはその型の一部です。型 <strong>[10]int</strong> と <strong>[20]int</strong> は区別されます。</p></li>
</ul>
<p>配列が値である性質は便利ですが、高コストでもあります。 Cのような動作と効率が必要な場合は、配列のポインターを渡すことができます。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">Sum</span><span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="kt">float64</span><span class="p">)</span> <span class="p">(</span><span class="nx">sum</span> <span class="kt">float64</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="o">*</span><span class="nx">a</span> <span class="p">{</span>
        <span class="nx">sum</span> <span class="o">+=</span> <span class="nx">v</span>
    <span class="p">}</span>
    <span class="k">return</span>
<span class="p">}</span>

<span class="nx">array</span> <span class="o">:=</span> <span class="p">[</span><span class="o">...</span><span class="p">]</span><span class="kt">float64</span><span class="p">{</span><span class="mf">7.0</span><span class="p">,</span> <span class="mf">8.5</span><span class="p">,</span> <span class="mf">9.1</span><span class="p">}</span>
<span class="nx">x</span> <span class="o">:=</span> <span class="nx">Sum</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">array</span><span class="p">)</span>  <span class="c1">// Note the explicit address-of operator</span>
</pre></div>
</div>
<p>しかしこの書き方はGoらしくありません。代わりにスライスを使います。</p>
</div>
<div class="section" id="id18">
<h3>スライス<a class="headerlink" href="#id18" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>スライスは配列をラップして、連続データへのより一般的で強力かつ便利なインターフェイスを提供します。変換行列などの明示的な次元を持つ項目を除き、Goのほとんどの配列プログラミングは、単純な配列ではなくスライスを使用して行われます。</p>
<p>スライスは、基礎となる配列への参照を保持します。あるスライスを別のスライスに割り当てると、両方とも同じ配列を参照します。 関数がスライスを引数を取る場合、スライスの要素に加えられた変更は呼び出し元に表示されます。これは、基礎となる配列へのポインターの受け渡しに似ています。 したがって <code class="docutils literal notranslate"><span class="pre">Read</span></code> 関数の引数には、ポインターと要素数の値ではなくスライスを受け入れることができます。 スライス内の長さは、読み取るデータ量の上限を設定します。 パッケージ <code class="docutils literal notranslate"><span class="pre">os</span></code> の型 <code class="docutils literal notranslate"><span class="pre">File</span></code> の <code class="docutils literal notranslate"><span class="pre">Read</span></code> メソッドのシグネチャは次のとおりです。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="o">*</span><span class="nx">File</span><span class="p">)</span> <span class="nx">Read</span><span class="p">(</span><span class="nx">buf</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
</pre></div>
</div>
<p>このメソッドは、読み取られたバイト数とエラー値（存在する場合）を返します。大きなバッファー <code class="docutils literal notranslate"><span class="pre">buf</span></code> の最初の32バイトに読み込むには、バッファーを小さくスライスします。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">n</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">f</span><span class="p">.</span><span class="nx">Read</span><span class="p">(</span><span class="nx">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">32</span><span class="p">])</span>
</pre></div>
</div>
<p>このようなスライスは一般的で効率的です。実際、効率性を無視すれば、次のスニペットはバッファーの最初の32バイトを読み取ります。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">n</span> <span class="kt">int</span>
<span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">32</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
    <span class="nx">nbytes</span><span class="p">,</span> <span class="nx">e</span> <span class="o">:=</span> <span class="nx">f</span><span class="p">.</span><span class="nx">Read</span><span class="p">(</span><span class="nx">buf</span><span class="p">[</span><span class="nx">i</span><span class="p">:</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>  <span class="c1">// Read one byte.</span>
    <span class="nx">n</span> <span class="o">+=</span> <span class="nx">nbytes</span>
    <span class="k">if</span> <span class="nx">nbytes</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">e</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">err</span> <span class="p">=</span> <span class="nx">e</span>
        <span class="k">break</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>スライスの長さは、もとになる配列の制限内に収まる限り変更できます。 それを自分自身のスライスに割り当てるだけです。 組み込み関数 <strong>cap</strong> でアクセス可能なスライスの容量は、スライスが想定できる最大長を報告します。 以下の <strong>append</strong> はスライスにデータを追加する関数です。 データが容量を超える場合、再割り当てされたスライスが返されます。 この関数は <strong>nil</strong> スライスに適用されるときに <strong>len</strong> と <strong>cap</strong> が有効であることを使用し、0を返します。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">Append</span><span class="p">(</span><span class="nx">slice</span><span class="p">,</span> <span class="nx">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">{</span>
    <span class="nx">l</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">slice</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">l</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">&gt;</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">slice</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// reallocate</span>
        <span class="c1">// Allocate double what&#39;s needed, for future growth.</span>
        <span class="nx">newSlice</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="p">(</span><span class="nx">l</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="nx">data</span><span class="p">))</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span>
        <span class="c1">// The copy function is predeclared and works for any slice type.</span>
        <span class="nb">copy</span><span class="p">(</span><span class="nx">newSlice</span><span class="p">,</span> <span class="nx">slice</span><span class="p">)</span>
        <span class="nx">slice</span> <span class="p">=</span> <span class="nx">newSlice</span>
    <span class="p">}</span>
    <span class="nx">slice</span> <span class="p">=</span> <span class="nx">slice</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="nx">l</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="nx">data</span><span class="p">)]</span>
    <span class="nb">copy</span><span class="p">(</span><span class="nx">slice</span><span class="p">[</span><span class="nx">l</span><span class="p">:],</span> <span class="nx">data</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">slice</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Appendはスライスの要素を変更できますが、スライス自体（ポインター、長さ、および容量を保持する実行時のデータ構造）は値によって渡されるため、あとからスライスを返すべきです。</p>
<p>スライスに追加するという考え方は非常に便利で、組み込みの <strong>append</strong> 関数によって実現できます。 ただし、その関数の設計を理解するには、もう少し情報が必要なので、後で説明します。</p>
</div>
<div class="section" id="id19">
<h3>二次元スライス<a class="headerlink" href="#id19" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Goの配列とスライスは1次元です。 二次元配列またはスライスに相当するものを作成するには、次のように配列の配列またはスライスのスライスを定義する必要があります。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">Transform</span> <span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span><span class="kt">float64</span>  <span class="c1">// A 3x3 array, really an array of arrays.</span>
<span class="kd">type</span> <span class="nx">LinesOfText</span> <span class="p">[][]</span><span class="kt">byte</span>     <span class="c1">// A slice of byte slices.</span>
</pre></div>
</div>
<p>スライスは可変長であるため、スライスの中にあるスライスを異なる長さにすることができます。 <code class="docutils literal notranslate"><span class="pre">LinesOfText</span></code> の例のように、これは一般的な状況です。各行には独立した長さがあります。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">text</span> <span class="o">:=</span> <span class="nx">LinesOfText</span><span class="p">{</span>
    <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&quot;Now is the time&quot;</span><span class="p">),</span>
    <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&quot;for all good gophers&quot;</span><span class="p">),</span>
    <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&quot;to bring some fun to the party.&quot;</span><span class="p">),</span>
<span class="p">}</span>
</pre></div>
</div>
<p>場合によっては、二次元スライスを割り当てる必要があります。これは、たとえば、ピクセル行をスキャンするときに発生する可能性がある状況です。 これを達成するには2つの方法があります。 1つは、各スライスを個別に割り当てることです。 もう1つは、単一の配列を割り当て、個々のスライスをその配列に向けることです。 どちらを使用するかは、アプリケーションによって異なります。 スライスが拡大または縮小する可能性がある場合は、次の行を上書きしないように、個別に割り当てる必要があります。 そうでない場合は、単一の割り当てでオブジェクトを構築する方が効率的です。 参考のために、2つの方法の概要を以下に示します。 まず、1行ずつことなる長さを割り当てる場合です。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// Allocate the top-level slice.</span>
<span class="nx">picture</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([][]</span><span class="kt">uint8</span><span class="p">,</span> <span class="nx">YSize</span><span class="p">)</span> <span class="c1">// One row per unit of y.</span>
<span class="c1">// Loop over the rows, allocating the slice for each row.</span>
<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">picture</span> <span class="p">{</span>
    <span class="nx">picture</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">uint8</span><span class="p">,</span> <span class="nx">XSize</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>次に、1つのスライスに行を割り当てる方法です。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// Allocate the top-level slice, the same as before.</span>
<span class="nx">picture</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([][]</span><span class="kt">uint8</span><span class="p">,</span> <span class="nx">YSize</span><span class="p">)</span> <span class="c1">// One row per unit of y.</span>
<span class="c1">// Allocate one large slice to hold all the pixels.</span>
<span class="nx">pixels</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">uint8</span><span class="p">,</span> <span class="nx">XSize</span><span class="o">*</span><span class="nx">YSize</span><span class="p">)</span> <span class="c1">// Has type []uint8 even though picture is [][]uint8.</span>
<span class="c1">// Loop over the rows, slicing each row from the front of the remaining pixels slice.</span>
<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">picture</span> <span class="p">{</span>
    <span class="nx">picture</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">pixels</span> <span class="p">=</span> <span class="nx">pixels</span><span class="p">[:</span><span class="nx">XSize</span><span class="p">],</span> <span class="nx">pixels</span><span class="p">[</span><span class="nx">XSize</span><span class="p">:]</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id20">
<h3>マップ<a class="headerlink" href="#id20" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>マップは、ある型（キー）の値を別の型（要素または値）の値に関連付ける便利で強力な組み込みのデータ構造です。 キーは、整数、浮動小数点および複素数、文字列、ポインター、インターフェイス（動的な型が等価をサポートしている限り）、構造体、配列など、等号演算子が定義されている任意の型にすることができます。 スライスは等価が定義されていないため、マップのキーとして使用できません。 スライスと同様に、マップは背後にあるデータ構造への参照を保持します。 マップの内容を変更する関数にマップを渡すと、変更は呼び出し元に表示されます。</p>
<p>マップは、コロンで区切られたキーと値のペアを使用した通常の複合リテラル構文を使用して構築できるため、簡単に初期化することができます。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">timeZone</span> <span class="p">=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span>
    <span class="s">&quot;UTC&quot;</span><span class="p">:</span>  <span class="mi">0</span><span class="o">*</span><span class="mi">60</span><span class="o">*</span><span class="mi">60</span><span class="p">,</span>
    <span class="s">&quot;EST&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">5</span><span class="o">*</span><span class="mi">60</span><span class="o">*</span><span class="mi">60</span><span class="p">,</span>
    <span class="s">&quot;CST&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">6</span><span class="o">*</span><span class="mi">60</span><span class="o">*</span><span class="mi">60</span><span class="p">,</span>
    <span class="s">&quot;MST&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">7</span><span class="o">*</span><span class="mi">60</span><span class="o">*</span><span class="mi">60</span><span class="p">,</span>
    <span class="s">&quot;PST&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">8</span><span class="o">*</span><span class="mi">60</span><span class="o">*</span><span class="mi">60</span><span class="p">,</span>
<span class="p">}</span>
</pre></div>
</div>
<p>マップへの値の割り当てと取得は、キーが整数でなくてもよいことを除いて、配列とスライスの場合と同じような構文に見えます。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">offset</span> <span class="o">:=</span> <span class="nx">timeZone</span><span class="p">[</span><span class="s">&quot;EST&quot;</span><span class="p">]</span>
</pre></div>
</div>
<p>マップに存在しないキーを使用してマップから値を取得しようとすると、マップ内のエントリの型のゼロ値が返されます。 たとえば、マップの値として整数が含まれている場合、存在しないキーを検索すると0が返されます。Setのデータ構造は、boolを値として保持するマップとして実装できます。 マップエントリをtrueに設定して値をセットに入れてから、単純なインデックス作成によってテストします。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">attended</span> <span class="o">:=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">bool</span><span class="p">{</span>
    <span class="s">&quot;Ann&quot;</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
    <span class="s">&quot;Joe&quot;</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
    <span class="o">...</span>
<span class="p">}</span>

<span class="k">if</span> <span class="nx">attended</span><span class="p">[</span><span class="nx">person</span><span class="p">]</span> <span class="p">{</span> <span class="c1">// will be false if person is not in the map</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">person</span><span class="p">,</span> <span class="s">&quot;was at the meeting&quot;</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>存在しないエントリをゼロ値と区別する必要がある場合があります。 「UTC」のエントリはあるか、マップに存在せずゼロ値になるかのどちらかです。 多値を同時に割り当てる形式で区別できます。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">seconds</span> <span class="kt">int</span>
<span class="kd">var</span> <span class="nx">ok</span> <span class="kt">bool</span>
<span class="nx">seconds</span><span class="p">,</span> <span class="nx">ok</span> <span class="p">=</span> <span class="nx">timeZone</span><span class="p">[</span><span class="nx">tz</span><span class="p">]</span>
</pre></div>
</div>
<p>自明な理由により、上記は「コンマOK」イディオムと呼ばれます。 この例では、tzのエントリが存在する場合、秒が適切に設定され、okがtrueになります。 そうでない場合、秒はゼロに設定され、okはfalseになります。 以下は、素晴らしいエラーメッセージと一緒に機能する関数です。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">offset</span><span class="p">(</span><span class="nx">tz</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">seconds</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">timeZone</span><span class="p">[</span><span class="nx">tz</span><span class="p">];</span> <span class="nx">ok</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">seconds</span>
    <span class="p">}</span>
    <span class="nx">log</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;unknown time zone:&quot;</span><span class="p">,</span> <span class="nx">tz</span><span class="p">)</span>
    <span class="k">return</span> <span class="mi">0</span>
<span class="p">}</span>
</pre></div>
</div>
<p>実際の値を気にせずにマップ内の存在をテストするには、値の変数として通常の変数の代わりに <a class="reference external" href="#blank">空白の識別子</a> を使用できます。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">_</span><span class="p">,</span> <span class="nx">present</span> <span class="o">:=</span> <span class="nx">timeZone</span><span class="p">[</span><span class="nx">tz</span><span class="p">]</span>
</pre></div>
</div>
<p>マップエントリを削除するには組み込み関数である <strong>delete</strong> を使用します。この組み込み関数の引数は、マップと削除するキーです。キーがマップに既に存在しない場合でも、これを行うのは安全です。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nb">delete</span><span class="p">(</span><span class="nx">timeZone</span><span class="p">,</span> <span class="s">&quot;PDT&quot;</span><span class="p">)</span>  <span class="c1">// Now on Standard Time</span>
</pre></div>
</div>
</div>
<div class="section" id="id22">
<h3>プリント<a class="headerlink" href="#id22" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Goの書式付きプリントでは、Cのprintfファミリーに似たスタイルが使用されますが、より機能的で一般的です。 関数は <strong>fmt</strong> パッケージに存在し、大文字の名前が付いています。<code class="docutils literal notranslate"><span class="pre">fmt.Printf</span></code> , <code class="docutils literal notranslate"><span class="pre">fmt.Fprintf</span></code> , <code class="docutils literal notranslate"><span class="pre">fmt.Sprintf</span></code> などです。文字列関数( <a href="#id23"><span class="problematic" id="id24">``</span></a>Sprintf``など) は、提供されたバッファを埋めるのではなく、文字列を返します。</p>
<p>書式文字列を提供する必要はありません。<code class="docutils literal notranslate"><span class="pre">Printf</span></code> , <code class="docutils literal notranslate"><span class="pre">Fprintf</span></code> , <code class="docutils literal notranslate"><span class="pre">Sprintf</span></code> のそれぞれについて、別のペアの関数、たとえば <code class="docutils literal notranslate"><span class="pre">Print</span></code> と <code class="docutils literal notranslate"><span class="pre">Println</span></code> があります。 これらの関数はフォーマット文字列を取りませんが、代わりに各引数のデフォルトフォーマットを生成します。また <code class="docutils literal notranslate"><span class="pre">Println</span></code> 版は引数の間に空白を挿入し、出力に改行を追加します。しかし <code class="docutils literal notranslate"><span class="pre">Print</span></code> 版は隣り合うどちらの側のオペランドも <code class="docutils literal notranslate"><span class="pre">string</span></code> でない場合にのみ空白を追加します。 この例では、各行は同じ出力を生成します。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;Hello %d\n&quot;</span><span class="p">,</span> <span class="mi">23</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprint</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span><span class="p">,</span> <span class="s">&quot;Hello &quot;</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="s">&quot;\n&quot;</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;Hello&quot;</span><span class="p">,</span> <span class="mi">23</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprint</span><span class="p">(</span><span class="s">&quot;Hello &quot;</span><span class="p">,</span> <span class="mi">23</span><span class="p">))</span>
</pre></div>
</div>
<p>フォーマットされたプリント関数 <strong>fmt.Fprint</strong> と類似する関数は <strong>io.Writer</strong> インターフェイスを実装するオブジェクトを最初の引数として受け取ります。変数 <strong>os.Stdout</strong> と <strong>os.Stderr</strong> はよく知られたインスタンスです。</p>
<p>ここからCと異なります。最初に <strong>%d</strong> などの数値形式は、符号付きまたは大きさのフラグを取りません。 代わりに、プリントルーチンは引数の型を使用してこれらのプロパティを決定します。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">x</span> <span class="kt">uint64</span> <span class="p">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">64</span> <span class="o">-</span> <span class="mi">1</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%d %x; %d %x\n&quot;</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">x</span><span class="p">),</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">x</span><span class="p">))</span>
</pre></div>
</div>
<p>上記は以下のように表示されます。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="mi">18446744073709551615</span> <span class="nx">ffffffffffffffff</span><span class="p">;</span> <span class="o">-</span><span class="mi">1</span> <span class="o">-</span><span class="mi">1</span>
</pre></div>
</div>
<p>整数の小数など、デフォルトの変換だけが必要な場合は、すべてで用いることのできる形式 <strong>%v</strong> を使用できます。 結果はPrintとPrintlnが生成するものとまったく同じです。 さらに、その形式では、配列、スライス、構造体、マップなど、任意の値を出力できます。 これは、前のセクションで定義したタイムゾーンマップのprintステートメントです。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%v\n&quot;</span><span class="p">,</span> <span class="nx">timeZone</span><span class="p">)</span>  <span class="c1">// or just fmt.Println(timeZone)</span>
</pre></div>
</div>
<p>以下のように表示されます。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">map</span><span class="p">[</span><span class="nx">CST</span><span class="p">:</span><span class="o">-</span><span class="mi">21600</span> <span class="nx">EST</span><span class="p">:</span><span class="o">-</span><span class="mi">18000</span> <span class="nx">MST</span><span class="p">:</span><span class="o">-</span><span class="mi">25200</span> <span class="nx">PST</span><span class="p">:</span><span class="o">-</span><span class="mi">28800</span> <span class="nx">UTC</span><span class="p">:</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<p>マップの場合、 <strong>Printf</strong> や周辺の関数は、キーの辞書順でソートして表示します。</p>
<p>構造体をプリントする場合、拡張された形式 <strong>%+v</strong> は構造体のフィールドに名前を付けて注釈を付けます。値があれば代替の形式 <strong>%#v</strong> は値を完全なGo構文でプリントします。</p>
<p>When printing a struct, the modified format <strong>%+v</strong> annotates the fields
of the structure with their names, and for any value the alternate
format <strong>%#v</strong> prints the value in full Go syntax.</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">T</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">a</span> <span class="kt">int</span>
    <span class="nx">b</span> <span class="kt">float64</span>
    <span class="nx">c</span> <span class="kt">string</span>
<span class="p">}</span>
<span class="nx">t</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">T</span><span class="p">{</span> <span class="mi">7</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.35</span><span class="p">,</span> <span class="s">&quot;abc\tdef&quot;</span> <span class="p">}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%v\n&quot;</span><span class="p">,</span> <span class="nx">t</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%+v\n&quot;</span><span class="p">,</span> <span class="nx">t</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%#v\n&quot;</span><span class="p">,</span> <span class="nx">t</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%#v\n&quot;</span><span class="p">,</span> <span class="nx">timeZone</span><span class="p">)</span>
</pre></div>
</div>
<p>以下のように表示されます。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="o">&amp;</span><span class="p">{</span><span class="mi">7</span> <span class="o">-</span><span class="mf">2.35</span> <span class="nx">abc</span>   <span class="nx">def</span><span class="p">}</span>
<span class="o">&amp;</span><span class="p">{</span><span class="nx">a</span><span class="p">:</span><span class="mi">7</span> <span class="nx">b</span><span class="p">:</span><span class="o">-</span><span class="mf">2.35</span> <span class="nx">c</span><span class="p">:</span><span class="nx">abc</span>     <span class="nx">def</span><span class="p">}</span>
<span class="o">&amp;</span><span class="nx">main</span><span class="p">.</span><span class="nx">T</span><span class="p">{</span><span class="nx">a</span><span class="p">:</span><span class="mi">7</span><span class="p">,</span> <span class="nx">b</span><span class="p">:</span><span class="o">-</span><span class="mf">2.35</span><span class="p">,</span> <span class="nx">c</span><span class="p">:</span><span class="s">&quot;abc\tdef&quot;</span><span class="p">}</span>
<span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="s">&quot;CST&quot;</span><span class="p">:</span><span class="o">-</span><span class="mi">21600</span><span class="p">,</span> <span class="s">&quot;EST&quot;</span><span class="p">:</span><span class="o">-</span><span class="mi">18000</span><span class="p">,</span> <span class="s">&quot;MST&quot;</span><span class="p">:</span><span class="o">-</span><span class="mi">25200</span><span class="p">,</span> <span class="s">&quot;PST&quot;</span><span class="p">:</span><span class="o">-</span><span class="mi">28800</span><span class="p">,</span> <span class="s">&quot;UTC&quot;</span><span class="p">:</span><span class="mi">0</span><span class="p">}</span>
</pre></div>
</div>
<p>（アンパサンド <code class="docutils literal notranslate"><span class="pre">&amp;</span></code> に注意してください。）この引用符付き文字列形式は <strong>string</strong> 型または <strong>[]byte</strong> 型の値に適用される場合 <strong>%q</strong> でも使用できます。 別の書式 <strong>%#q</strong> は、可能であれば代わりにバッククォートを使用します。 ( <strong>%q</strong> 形式は、整数とルーンにも適用され、単一引用符で囲まれたルーン定数を生成します。）また <strong>%x</strong> は、文字列、バイト配列、バイトスライス、および整数で機能し、長い16進数文字列を生成し、スペースを使用します フォーマット( <strong>%x</strong> )では、バイト間にスペースを入れます。</p>
<p>もう1つの便利な形式は <strong>%T</strong> です。これは、値の型を出力します。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%T\n&quot;</span><span class="p">,</span> <span class="nx">timeZone</span><span class="p">)</span>
</pre></div>
</div>
<p>以下のように表示されます。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span>
</pre></div>
</div>
<p>デフォルトの書式を拡張したい場合 <strong>String() string</strong> のシグネチャを持つメソッドを型に定義する必要があります。以下のシンプルな型Tは以下のようになります。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">T</span><span class="p">)</span> <span class="nx">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&quot;%d/%g/%q&quot;</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nx">a</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nx">b</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nx">c</span><span class="p">)</span>
<span class="p">}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%v\n&quot;</span><span class="p">,</span> <span class="nx">t</span><span class="p">)</span>
</pre></div>
</div>
<p>フォーマットの出力をします。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="mi">7</span><span class="o">/-</span><span class="mf">2.35</span><span class="o">/</span><span class="s">&quot;abc\tdef&quot;</span>
</pre></div>
</div>
<p>（T型と*T型でプリントする必要がある場合、Stringのレシーバーは値型でなければなりません。この例では、構造体型の方が効率的で慣用的であるため、ポインターを使用しました。 詳細については <a class="reference external" href="#pointers_vs_values">ポインター vs 値のレシーバ</a> をご覧ください。）</p>
<p>String() メソッドは、プリントルーチンが完全にリエントラントであり、このようにラップできるため、Sprintfを呼び出すことができます。 ただし、このアプローチについて理解する必要がある重要な詳細が1つあります。Sprintfを呼び出してStringメソッドを無期限に再帰する方法で実装しないでください。 これは、Sprintfの呼び出しがレシーバーを文字列として直接プリントしようとした場合に発生する可能性があり、その結果、メソッドが再度呼び出されます。 この例が示すように、これはよくある間違いです。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">MyString</span> <span class="kt">string</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="nx">MyString</span><span class="p">)</span> <span class="nx">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&quot;MyString=%s&quot;</span><span class="p">,</span> <span class="nx">m</span><span class="p">)</span> <span class="c1">// Error: will recur forever.</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition-todo admonition" id="id25">
<p class="admonition-title">課題</p>
<p>詳細を示す</p>
</div>
<p>修正も簡単です。引数をメソッドを持たない基本的なstring型に変換します。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">MyString</span> <span class="kt">string</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="nx">MyString</span><span class="p">)</span> <span class="nx">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&quot;MyString=%s&quot;</span><span class="p">,</span> <span class="nb">string</span><span class="p">(</span><span class="nx">m</span><span class="p">))</span> <span class="c1">// OK: note conversion.</span>
<span class="p">}</span>
</pre></div>
</div>
<p>初期化セクションでは、この再帰を回避する別の手法を紹介します。</p>
<p>別のプリントするテクニックは、プリントルーチンの引数を別のルーチンに直接渡すことです。 Printfのシグネチャは、最後の引数に型 <strong>...interface{}</strong> を使用して、フォーマットの後に任意の数のパラメーター（任意の型）を表示できることを指定します。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">Printf</span><span class="p">(</span><span class="nx">format</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">v</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</pre></div>
</div>
<p>Printf関数内では v は <strong>[]interface{}</strong> 型の変数のように機能しますが、別の可変長引数を持つ関数に渡されると、通常の引数リストのように機能します。 上記で使用した <code class="docutils literal notranslate"><span class="pre">log.Println</span></code> 関数の実装を次に示します。 実際の書式設定のために、引数をfmt.Sprintlnに直接渡します。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// Println prints to the standard logger in the manner of fmt.Println.</span>
<span class="kd">func</span> <span class="nx">Println</span><span class="p">(</span><span class="nx">v</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
    <span class="nx">std</span><span class="p">.</span><span class="nx">Output</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintln</span><span class="p">(</span><span class="nx">v</span><span class="o">...</span><span class="p">))</span>  <span class="c1">// Output takes parameters (int, string)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Sprintlnへのネストされた呼び出しでvの後に <strong>...</strong> を記述して、vを引数のリストとして扱うようコンパイラーに指示します。それ以外の場合は、vを単一のスライス引数として渡します。</p>
<p>ここで説明した以外にも、プリントにはさらに多くの機能があります。詳細については、パッケージfmtのgodocドキュメントを参照してください。</p>
<p>ちなみに <strong>...</strong> パラメータは型として指定することができます。たとえば、整数のリストの最小のものを選択するmin関数の場合、パラメータの引数の型は <strong>...int</strong> です。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">Min</span><span class="p">(</span><span class="nx">a</span> <span class="o">...</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="nx">min</span> <span class="o">:=</span> <span class="nb">int</span><span class="p">(^</span><span class="nb">uint</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1">// largest int</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">a</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">min</span> <span class="p">{</span>
            <span class="nx">min</span> <span class="p">=</span> <span class="nx">i</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">min</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="append">
<h3>Append<a class="headerlink" href="#append" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Now we have the missing piece we needed to explain the design of the
<strong>append</strong> built-in function. The signature of <strong>append</strong> is different
from our custom <strong>Append</strong> function above. Schematically, it's like
this:</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nb">append</span><span class="p">(</span><span class="nx">slice</span> <span class="p">[]</span><span class="nx">T</span><span class="p">,</span> <span class="nx">elements</span> <span class="o">...</span><span class="nx">T</span><span class="p">)</span> <span class="p">[]</span><span class="nx">T</span>
</pre></div>
</div>
<p>where <em>T</em> is a placeholder for any given type. You can't actually write
a function in Go where the type <strong>T</strong> is determined by the caller.
That's why <strong>append</strong> is built in: it needs support from the compiler.</p>
<p>What <strong>append</strong> does is append the elements to the end of the slice and
return the result. The result needs to be returned because, as with our
hand-written <strong>Append</strong>, the underlying array may change. This simple
example</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">x</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">}</span>
<span class="nx">x</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>
</pre></div>
</div>
<p>prints <strong>[1 2 3 4 5 6]</strong>. So <strong>append</strong> works a little like <strong>Printf</strong>,
collecting an arbitrary number of arguments.</p>
<p>But what if we wanted to do what our <strong>Append</strong> does and append a slice
to a slice? Easy: use <strong>...</strong> at the call site, just as we did in the
call to <strong>Output</strong> above. This snippet produces identical output to the
one above.</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">x</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">}</span>
<span class="nx">y</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">}</span>
<span class="nx">x</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="o">...</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>
</pre></div>
</div>
<p>Without that <strong>...</strong>, it wouldn't compile because the types would be
wrong; <strong>y</strong> is not of type <strong>int</strong>.</p>
</div>
</div>
<div class="section" id="initialization">
<h2>初期化(Initialization)<a class="headerlink" href="#initialization" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Although it doesn't look superficially very different from
initialization in C or C++, initialization in Go is more powerful.
Complex structures can be built during initialization and the ordering
issues among initialized objects, even among different packages, are
handled correctly.</p>
<div class="section" id="id26">
<h3>定数<a class="headerlink" href="#id26" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Constants in Go are just that—constant. They are created at compile
time, even when defined as locals in functions, and can only be numbers,
characters (runes), strings or booleans. Because of the compile-time
restriction, the expressions that define them must be constant
expressions, evaluatable by the compiler. For instance, <strong>1&lt;&lt;3</strong> is a
constant expression, while <strong>math.Sin(math.Pi/4)</strong> is not because the
function call to <strong>math.Sin</strong> needs to happen at run time.</p>
<p>In Go, enumerated constants are created using the <strong>iota</strong> enumerator.
Since <strong>iota</strong> can be part of an expression and expressions can be
implicitly repeated, it is easy to build intricate sets of values.</p>
<p>{{code &quot;/doc/progs/eff_bytesize.go&quot; `/^type ByteSize/` `/^)/<a href="#id27"><span class="problematic" id="id28">`</span></a>}}</p>
<p>The ability to attach a method such as <strong>String</strong> to any user-defined
type makes it possible for arbitrary values to format themselves
automatically for printing. Although you'll see it most often applied to
structs, this technique is also useful for scalar types such as
floating-point types like <strong>ByteSize</strong>.</p>
<p>{{code &quot;/doc/progs/eff_bytesize.go&quot; `/^func.*ByteSize.*String/`
`/^}/<a href="#id29"><span class="problematic" id="id30">`</span></a>}}</p>
<p>The expression <strong>YB</strong> prints as <strong>1.00YB</strong>, while <strong>ByteSize(1e13)</strong>
prints as <strong>9.09TB</strong>.</p>
<p>The use here of <strong>Sprintf</strong> to implement <strong>ByteSize</strong>'s <strong>String</strong>
method is safe (avoids recurring indefinitely) not because of a
conversion but because it calls <strong>Sprintf</strong> with <strong>%f</strong>, which is not a
string format: <strong>Sprintf</strong> will only call the <strong>String</strong> method when it
wants a string, and <strong>%f</strong> wants a floating-point value.</p>
</div>
<div class="section" id="id31">
<h3>変数<a class="headerlink" href="#id31" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Variables can be initialized just like constants but the initializer can
be a general expression computed at run time.</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="p">(</span>
    <span class="nx">home</span>   <span class="p">=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Getenv</span><span class="p">(</span><span class="s">&quot;HOME&quot;</span><span class="p">)</span>
    <span class="nx">user</span>   <span class="p">=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Getenv</span><span class="p">(</span><span class="s">&quot;USER&quot;</span><span class="p">)</span>
    <span class="nx">gopath</span> <span class="p">=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Getenv</span><span class="p">(</span><span class="s">&quot;GOPATH&quot;</span><span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="init">
<span id="id32"></span><h3>init関数<a class="headerlink" href="#init" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Finally, each source file can define its own niladic <strong>init</strong> function
to set up whatever state is required. (Actually each file can have
multiple <strong>init</strong> functions.) And finally means finally: <strong>init</strong> is
called after all the variable declarations in the package have evaluated
their initializers, and those are evaluated only after all the imported
packages have been initialized.</p>
<p>Besides initializations that cannot be expressed as declarations, a
common use of <strong>init</strong> functions is to verify or repair correctness of
the program state before real execution begins.</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">init</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">user</span> <span class="o">==</span> <span class="s">&quot;&quot;</span> <span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="s">&quot;$USER not set&quot;</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">home</span> <span class="o">==</span> <span class="s">&quot;&quot;</span> <span class="p">{</span>
        <span class="nx">home</span> <span class="p">=</span> <span class="s">&quot;/home/&quot;</span> <span class="o">+</span> <span class="nx">user</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">gopath</span> <span class="o">==</span> <span class="s">&quot;&quot;</span> <span class="p">{</span>
        <span class="nx">gopath</span> <span class="p">=</span> <span class="nx">home</span> <span class="o">+</span> <span class="s">&quot;/go&quot;</span>
    <span class="p">}</span>
    <span class="c1">// gopath may be overridden by --gopath flag on command line.</span>
    <span class="nx">flag</span><span class="p">.</span><span class="nx">StringVar</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gopath</span><span class="p">,</span> <span class="s">&quot;gopath&quot;</span><span class="p">,</span> <span class="nx">gopath</span><span class="p">,</span> <span class="s">&quot;override default GOPATH&quot;</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id33">
<h2>メソッド<a class="headerlink" href="#id33" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="pointers-vs-values">
<span id="id34"></span><h3>ポインター vs 値<a class="headerlink" href="#pointers-vs-values" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>As we saw with <strong>ByteSize</strong>, methods can be defined for any named type
(except a pointer or an interface); the receiver does not have to be a
struct.</p>
<p>In the discussion of slices above, we wrote an <strong>Append</strong> function. We
can define it as a method on slices instead. To do this, we first
declare a named type to which we can bind the method, and then make the
receiver for the method a value of that type.</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">ByteSlice</span> <span class="p">[]</span><span class="kt">byte</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">slice</span> <span class="nx">ByteSlice</span><span class="p">)</span> <span class="nx">Append</span><span class="p">(</span><span class="nx">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">{</span>
    <span class="c1">// Body exactly the same as the Append function defined above.</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This still requires the method to return the updated slice. We can
eliminate that clumsiness by redefining the method to take a <em>pointer</em>
to a <strong>ByteSlice</strong> as its receiver, so the method can overwrite the
caller's slice.</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">ByteSlice</span><span class="p">)</span> <span class="nx">Append</span><span class="p">(</span><span class="nx">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">slice</span> <span class="o">:=</span> <span class="o">*</span><span class="nx">p</span>
    <span class="c1">// Body as above, without the return.</span>
    <span class="o">*</span><span class="nx">p</span> <span class="p">=</span> <span class="nx">slice</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In fact, we can do even better. If we modify our function so it looks
like a standard <strong>Write</strong> method, like this,</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">ByteSlice</span><span class="p">)</span> <span class="nx">Write</span><span class="p">(</span><span class="nx">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">slice</span> <span class="o">:=</span> <span class="o">*</span><span class="nx">p</span>
    <span class="c1">// Again as above.</span>
    <span class="o">*</span><span class="nx">p</span> <span class="p">=</span> <span class="nx">slice</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nx">data</span><span class="p">),</span> <span class="kc">nil</span>
<span class="p">}</span>
</pre></div>
</div>
<p>then the type <strong>*ByteSlice</strong> satisfies the standard interface
<strong>io.Writer</strong>, which is handy. For instance, we can print into one.</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">b</span> <span class="nx">ByteSlice</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">b</span><span class="p">,</span> <span class="s">&quot;This hour has %d days\n&quot;</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>
</pre></div>
</div>
<p>We pass the address of a <strong>ByteSlice</strong> because only <strong>*ByteSlice</strong>
satisfies <strong>io.Writer</strong>. The rule about pointers vs. values for
receivers is that value methods can be invoked on pointers and values,
but pointer methods can only be invoked on pointers.</p>
<p>This rule arises because pointer methods can modify the receiver;
invoking them on a value would cause the method to receive a copy of the
value, so any modifications would be discarded. The language therefore
disallows this mistake. There is a handy exception, though. When the
value is addressable, the language takes care of the common case of
invoking a pointer method on a value by inserting the address operator
automatically. In our example, the variable <strong>b</strong> is addressable, so we
can call its <strong>Write</strong> method with just <strong>b.Write</strong>. The compiler will
rewrite that to <strong>(&amp;b).Write</strong> for us.</p>
<p>By the way, the idea of using <strong>Write</strong> on a slice of bytes is central
to the implementation of <strong>bytes.Buffer</strong>.</p>
</div>
</div>
<div class="section" id="interfaces-and-types">
<span id="id35"></span><h2>インターフェースとその他の型<a class="headerlink" href="#interfaces-and-types" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="id36">
<h3>インターフェース<a class="headerlink" href="#id36" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Interfaces in Go provide a way to specify the behavior of an object: if
something can do <em>this</em>, then it can be used <em>here</em>. We've seen a couple
of simple examples already; custom printers can be implemented by a
<strong>String</strong> method while <strong>Fprintf</strong> can generate output to anything with
a <strong>Write</strong> method. Interfaces with only one or two methods are common
in Go code, and are usually given a name derived from the method, such
as <strong>io.Writer</strong> for something that implements <strong>Write</strong>.</p>
<p>A type can implement multiple interfaces. For instance, a collection can
be sorted by the routines in package <strong>sort</strong> if it implements
<strong>sort.Interface</strong>, which contains <strong>Len()</strong>, <strong>Less(i, j int) bool</strong>,
and <strong>Swap(i, j int)</strong>, and it could also have a custom formatter. In
this contrived example <strong>Sequence</strong> satisfies both.</p>
<p>{{code &quot;/doc/progs/eff_sequence.go&quot; `/^type/` &quot;$&quot;}}</p>
</div>
<div class="section" id="conversions">
<h3>Conversions<a class="headerlink" href="#conversions" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>The <strong>String</strong> method of <strong>Sequence</strong> is recreating the work that
<strong>Sprint</strong> already does for slices. (It also has complexity O(N²), which
is poor.) We can share the effort (and also speed it up) if we convert
the <strong>Sequence</strong> to a plain <strong>[]int</strong> before calling <strong>Sprint</strong>.</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="nx">Sequence</span><span class="p">)</span> <span class="nx">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="nx">s</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">Copy</span><span class="p">()</span>
    <span class="nx">sort</span><span class="p">.</span><span class="nx">Sort</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprint</span><span class="p">([]</span><span class="nb">int</span><span class="p">(</span><span class="nx">s</span><span class="p">))</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This method is another example of the conversion technique for calling
<strong>Sprintf</strong> safely from a <strong>String</strong> method. Because the two types
(<strong>Sequence</strong> and <strong>[]int</strong>) are the same if we ignore the type name,
it's legal to convert between them. The conversion doesn't create a new
value, it just temporarily acts as though the existing value has a new
type. (There are other legal conversions, such as from integer to
floating point, that do create a new value.)</p>
<p>It's an idiom in Go programs to convert the type of an expression to
access a different set of methods. As an example, we could use the
existing type <strong>sort.IntSlice</strong> to reduce the entire example to this:</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">Sequence</span> <span class="p">[]</span><span class="kt">int</span>

<span class="c1">// Method for printing - sorts the elements before printing</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="nx">Sequence</span><span class="p">)</span> <span class="nx">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="nx">s</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">Copy</span><span class="p">()</span>
    <span class="nx">sort</span><span class="p">.</span><span class="nx">IntSlice</span><span class="p">(</span><span class="nx">s</span><span class="p">).</span><span class="nx">Sort</span><span class="p">()</span>
    <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprint</span><span class="p">([]</span><span class="nb">int</span><span class="p">(</span><span class="nx">s</span><span class="p">))</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Now, instead of having <strong>Sequence</strong> implement multiple interfaces
(sorting and printing), we're using the ability of a data item to be
converted to multiple types (<strong>Sequence</strong>, <strong>sort.IntSlice</strong> and
<strong>[]int</strong>), each of which does some part of the job. That's more unusual
in practice but can be effective.</p>
</div>
<div class="section" id="interface-conversions-and-type-assertions">
<span id="interface-conversions"></span><h3>Interface conversions and type assertions<a class="headerlink" href="#interface-conversions-and-type-assertions" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><a class="reference external" href="#type_switch">Type switches</a> are a form of conversion: they take an
interface and, for each case in the switch, in a sense convert it to the
type of that case. Here's a simplified version of how the code under
<strong>fmt.Printf</strong> turns a value into a string using a type switch. If it's
already a string, we want the actual string value held by the interface,
while if it has a <strong>String</strong> method we want the result of calling the
method.</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">Stringer</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nx">String</span><span class="p">()</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">value</span> <span class="kd">interface</span><span class="p">{}</span> <span class="c1">// Value provided by caller.</span>
<span class="k">switch</span> <span class="nx">str</span> <span class="o">:=</span> <span class="nx">value</span><span class="p">.(</span><span class="kd">type</span><span class="p">)</span> <span class="p">{</span>
<span class="k">case</span> <span class="kt">string</span><span class="p">:</span>
    <span class="k">return</span> <span class="nx">str</span>
<span class="k">case</span> <span class="nx">Stringer</span><span class="p">:</span>
    <span class="k">return</span> <span class="nx">str</span><span class="p">.</span><span class="nx">String</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The first case finds a concrete value; the second converts the interface
into another interface. It's perfectly fine to mix types this way.</p>
<p>What if there's only one type we care about? If we know the value holds
a <strong>string</strong> and we just want to extract it? A one-case type switch
would do, but so would a <em>type assertion</em>. A type assertion takes an
interface value and extracts from it a value of the specified explicit
type. The syntax borrows from the clause opening a type switch, but with
an explicit type rather than the <strong>type</strong> keyword:</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">value</span><span class="p">.(</span><span class="nx">typeName</span><span class="p">)</span>
</pre></div>
</div>
<p>and the result is a new value with the static type <strong>typeName</strong>. That
type must either be the concrete type held by the interface, or a second
interface type that the value can be converted to. To extract the string
we know is in the value, we could write:</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">str</span> <span class="o">:=</span> <span class="nx">value</span><span class="p">.(</span><span class="kt">string</span><span class="p">)</span>
</pre></div>
</div>
<p>But if it turns out that the value does not contain a string, the
program will crash with a run-time error. To guard against that, use the
&quot;comma, ok&quot; idiom to test, safely, whether the value is a string:</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">str</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">value</span><span class="p">.(</span><span class="kt">string</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">ok</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;string value is: %q\n&quot;</span><span class="p">,</span> <span class="nx">str</span><span class="p">)</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;value is not a string\n&quot;</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If the type assertion fails, <strong>str</strong> will still exist and be of type
string, but it will have the zero value, an empty string.</p>
<p>As an illustration of the capability, here's an <strong>if</strong>-<strong>else</strong>
statement that's equivalent to the type switch that opened this section.</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="nx">str</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">value</span><span class="p">.(</span><span class="kt">string</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">str</span>
<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">str</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">value</span><span class="p">.(</span><span class="nx">Stringer</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">str</span><span class="p">.</span><span class="nx">String</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="generality">
<h3>Generality<a class="headerlink" href="#generality" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>If a type exists only to implement an interface and will never have
exported methods beyond that interface, there is no need to export the
type itself. Exporting just the interface makes it clear the value has
no interesting behavior beyond what is described in the interface. It
also avoids the need to repeat the documentation on every instance of a
common method.</p>
<p>In such cases, the constructor should return an interface value rather
than the implementing type. As an example, in the hash libraries both
<strong>crc32.NewIEEE</strong> and <strong>adler32.New</strong> return the interface type
<strong>hash.Hash32</strong>. Substituting the CRC-32 algorithm for Adler-32 in a Go
program requires only changing the constructor call; the rest of the
code is unaffected by the change of algorithm.</p>
<p>A similar approach allows the streaming cipher algorithms in the various
<strong>crypto</strong> packages to be separated from the block ciphers they chain
together. The <strong>Block</strong> interface in the <strong>crypto/cipher</strong> package
specifies the behavior of a block cipher, which provides encryption of a
single block of data. Then, by analogy with the <strong>bufio</strong> package,
cipher packages that implement this interface can be used to construct
streaming ciphers, represented by the <strong>Stream</strong> interface, without
knowing the details of the block encryption.</p>
<p>The <strong>crypto/cipher</strong> interfaces look like this:</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">Block</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nx">BlockSize</span><span class="p">()</span> <span class="kt">int</span>
    <span class="nx">Encrypt</span><span class="p">(</span><span class="nx">dst</span><span class="p">,</span> <span class="nx">src</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span>
    <span class="nx">Decrypt</span><span class="p">(</span><span class="nx">dst</span><span class="p">,</span> <span class="nx">src</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Stream</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nx">XORKeyStream</span><span class="p">(</span><span class="nx">dst</span><span class="p">,</span> <span class="nx">src</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Here's the definition of the counter mode (CTR) stream, which turns a
block cipher into a streaming cipher; notice that the block cipher's
details are abstracted away:</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// NewCTR returns a Stream that encrypts/decrypts using the given Block in</span>
<span class="c1">// counter mode. The length of iv must be the same as the Block&#39;s block size.</span>
<span class="kd">func</span> <span class="nx">NewCTR</span><span class="p">(</span><span class="nx">block</span> <span class="nx">Block</span><span class="p">,</span> <span class="nx">iv</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="nx">Stream</span>
</pre></div>
</div>
<p><strong>NewCTR</strong> applies not just to one specific encryption algorithm and
data source but to any implementation of the <strong>Block</strong> interface and any
<strong>Stream</strong>. Because they return interface values, replacing CTR
encryption with other encryption modes is a localized change. The
constructor calls must be edited, but because the surrounding code must
treat the result only as a <strong>Stream</strong>, it won't notice the difference.</p>
</div>
<div class="section" id="interface-methods">
<span id="id37"></span><h3>インターフェースとメソッド<a class="headerlink" href="#interface-methods" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Since almost anything can have methods attached, almost anything can
satisfy an interface. One illustrative example is in the <strong>http</strong>
package, which defines the <strong>Handler</strong> interface. Any object that
implements <strong>Handler</strong> can serve HTTP requests.</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">Handler</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nx">ServeHTTP</span><span class="p">(</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="o">*</span><span class="nx">Request</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong>ResponseWriter</strong> is itself an interface that provides access to the
methods needed to return the response to the client. Those methods
include the standard <strong>Write</strong> method, so an <strong>http.ResponseWriter</strong> can
be used wherever an <strong>io.Writer</strong> can be used. <strong>Request</strong> is a struct
containing a parsed representation of the request from the client.</p>
<p>For brevity, let's ignore POSTs and assume HTTP requests are always
GETs; that simplification does not affect the way the handlers are set
up. Here's a trivial but complete implementation of a handler to count
the number of times the page is visited.</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// Simple counter server.</span>
<span class="kd">type</span> <span class="nx">Counter</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">n</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">ctr</span> <span class="o">*</span><span class="nx">Counter</span><span class="p">)</span> <span class="nx">ServeHTTP</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">req</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">ctr</span><span class="p">.</span><span class="nx">n</span><span class="o">++</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="s">&quot;counter = %d\n&quot;</span><span class="p">,</span> <span class="nx">ctr</span><span class="p">.</span><span class="nx">n</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>(Keeping with our theme, note how <strong>Fprintf</strong> can print to an
<strong>http.ResponseWriter</strong>.) For reference, here's how to attach such a
server to a node on the URL tree.</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="s">&quot;net/http&quot;</span>
<span class="o">...</span>
<span class="nx">ctr</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">Counter</span><span class="p">)</span>
<span class="nx">http</span><span class="p">.</span><span class="nx">Handle</span><span class="p">(</span><span class="s">&quot;/counter&quot;</span><span class="p">,</span> <span class="nx">ctr</span><span class="p">)</span>
</pre></div>
</div>
<p>But why make <strong>Counter</strong> a struct? An integer is all that's needed. (The
receiver needs to be a pointer so the increment is visible to the
caller.)</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// Simpler counter server.</span>
<span class="kd">type</span> <span class="nx">Counter</span> <span class="kt">int</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">ctr</span> <span class="o">*</span><span class="nx">Counter</span><span class="p">)</span> <span class="nx">ServeHTTP</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">req</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">*</span><span class="nx">ctr</span><span class="o">++</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="s">&quot;counter = %d\n&quot;</span><span class="p">,</span> <span class="o">*</span><span class="nx">ctr</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>What if your program has some internal state that needs to be notified
that a page has been visited? Tie a channel to the web page.</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// A channel that sends a notification on each visit.</span>
<span class="c1">// (Probably want the channel to be buffered.)</span>
<span class="kd">type</span> <span class="nx">Chan</span> <span class="kd">chan</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">ch</span> <span class="nx">Chan</span><span class="p">)</span> <span class="nx">ServeHTTP</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">req</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">ch</span> <span class="o">&lt;-</span> <span class="nx">req</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprint</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="s">&quot;notification sent&quot;</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Finally, let's say we wanted to present on <strong>/args</strong> the arguments used
when invoking the server binary. It's easy to write a function to print
the arguments.</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">ArgServer</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Args</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>How do we turn that into an HTTP server? We could make <strong>ArgServer</strong> a
method of some type whose value we ignore, but there's a cleaner way.
Since we can define a method for any type except pointers and
interfaces, we can write a method for a function. The <strong>http</strong> package
contains this code:</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// The HandlerFunc type is an adapter to allow the use of</span>
<span class="c1">// ordinary functions as HTTP handlers.  If f is a function</span>
<span class="c1">// with the appropriate signature, HandlerFunc(f) is a</span>
<span class="c1">// Handler object that calls f.</span>
<span class="kd">type</span> <span class="nx">HandlerFunc</span> <span class="kd">func</span><span class="p">(</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="o">*</span><span class="nx">Request</span><span class="p">)</span>

<span class="c1">// ServeHTTP calls f(w, req).</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="nx">HandlerFunc</span><span class="p">)</span> <span class="nx">ServeHTTP</span><span class="p">(</span><span class="nx">w</span> <span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">req</span> <span class="o">*</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">f</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="nx">req</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong>HandlerFunc</strong> is a type with a method, <strong>ServeHTTP</strong>, so values of
that type can serve HTTP requests. Look at the implementation of the
method: the receiver is a function, <strong>f</strong>, and the method calls <strong>f</strong>.
That may seem odd but it's not that different from, say, the receiver
being a channel and the method sending on the channel.</p>
<p>To make <strong>ArgServer</strong> into an HTTP server, we first modify it to have
the right signature.</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// Argument server.</span>
<span class="kd">func</span> <span class="nx">ArgServer</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">req</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintln</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Args</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong>ArgServer</strong> now has same signature as <strong>HandlerFunc</strong>, so it can be
converted to that type to access its methods, just as we converted
<strong>Sequence</strong> to <strong>IntSlice</strong> to access <strong>IntSlice.Sort</strong>. The code to
set it up is concise:</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">http</span><span class="p">.</span><span class="nx">Handle</span><span class="p">(</span><span class="s">&quot;/args&quot;</span><span class="p">,</span> <span class="nx">http</span><span class="p">.</span><span class="nx">HandlerFunc</span><span class="p">(</span><span class="nx">ArgServer</span><span class="p">))</span>
</pre></div>
</div>
<p>When someone visits the page <strong>/args</strong>, the handler installed at that
page has value <strong>ArgServer</strong> and type <strong>HandlerFunc</strong>. The HTTP server
will invoke the method <strong>ServeHTTP</strong> of that type, with <strong>ArgServer</strong> as
the receiver, which will in turn call <strong>ArgServer</strong> (via the invocation
<strong>f(w, req)</strong> inside <strong>HandlerFunc.ServeHTTP</strong>). The arguments will then
be displayed.</p>
<p>In this section we have made an HTTP server from a struct, an integer, a
channel, and a function, all because interfaces are just sets of
methods, which can be defined for (almost) any type.</p>
</div>
</div>
<div class="section" id="blank">
<span id="id38"></span><h2>空白の識別子<a class="headerlink" href="#blank" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>We've mentioned the blank identifier a couple of times now, in the
context of <strong>`for</strong> <strong>range</strong> loops &lt;#for&gt;`__ and <a class="reference external" href="#maps">maps</a>. The
blank identifier can be assigned or declared with any value of any type,
with the value discarded harmlessly. It's a bit like writing to the Unix
<strong>/dev/null</strong> file: it represents a write-only value to be used as a
place-holder where a variable is needed but the actual value is
irrelevant. It has uses beyond those we've seen already.</p>
<div class="section" id="the-blank-identifier-in-multiple-assignment">
<span id="blank-assign"></span><h3>The blank identifier in multiple assignment<a class="headerlink" href="#the-blank-identifier-in-multiple-assignment" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>The use of a blank identifier in a <strong>for</strong> <strong>range</strong> loop is a special
case of a general situation: multiple assignment.</p>
<p>If an assignment requires multiple values on the left side, but one of
the values will not be used by the program, a blank identifier on the
left-hand-side of the assignment avoids the need to create a dummy
variable and makes it clear that the value is to be discarded. For
instance, when calling a function that returns a value and an error, but
only the error is important, use the blank identifier to discard the
irrelevant value.</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Stat</span><span class="p">(</span><span class="nx">path</span><span class="p">);</span> <span class="nx">os</span><span class="p">.</span><span class="nx">IsNotExist</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%s does not exist\n&quot;</span><span class="p">,</span> <span class="nx">path</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Occasionally you'll see code that discards the error value in order to
ignore the error; this is terrible practice. Always check error returns;
they're provided for a reason.</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// Bad! This code will crash if path does not exist.</span>
<span class="nx">fi</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Stat</span><span class="p">(</span><span class="nx">path</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">fi</span><span class="p">.</span><span class="nx">IsDir</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%s is a directory\n&quot;</span><span class="p">,</span> <span class="nx">path</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="unused-imports-and-variables">
<span id="blank-unused"></span><h3>Unused imports and variables<a class="headerlink" href="#unused-imports-and-variables" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>It is an error to import a package or to declare a variable without
using it. Unused imports bloat the program and slow compilation, while a
variable that is initialized but not used is at least a wasted
computation and perhaps indicative of a larger bug. When a program is
under active development, however, unused imports and variables often
arise and it can be annoying to delete them just to have the compilation
proceed, only to have them be needed again later. The blank identifier
provides a workaround.</p>
<p>This half-written program has two unused imports (<strong>fmt</strong> and <strong>io</strong>)
and an unused variable (<strong>fd</strong>), so it will not compile, but it would be
nice to see if the code so far is correct.</p>
<p>{{code &quot;/doc/progs/eff_unused1.go&quot; `/package/` `$`}}</p>
<p>To silence complaints about the unused imports, use a blank identifier
to refer to a symbol from the imported package. Similarly, assigning the
unused variable <strong>fd</strong> to the blank identifier will silence the unused
variable error. This version of the program does compile.</p>
<p>{{code &quot;/doc/progs/eff_unused2.go&quot; `/package/` `$`}}</p>
<p>By convention, the global declarations to silence import errors should
come right after the imports and be commented, both to make them easy to
find and as a reminder to clean things up later.</p>
</div>
<div class="section" id="import-for-side-effect">
<span id="blank-import"></span><h3>Import for side effect<a class="headerlink" href="#import-for-side-effect" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>An unused import like <strong>fmt</strong> or <strong>io</strong> in the previous example should
eventually be used or removed: blank assignments identify code as a work
in progress. But sometimes it is useful to import a package only for its
side effects, without any explicit use. For example, during its <strong>init</strong>
function, the <strong>net/http/pprof</strong> package registers HTTP handlers that
provide debugging information. It has an exported API, but most clients
need only the handler registration and access the data through a web
page. To import the package only for its side effects, rename the
package to the blank identifier:</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nx">_</span> <span class="s">&quot;net/http/pprof&quot;</span>
</pre></div>
</div>
<p>This form of import makes clear that the package is being imported for
its side effects, because there is no other possible use of the package:
in this file, it doesn't have a name. (If it did, and we didn't use that
name, the compiler would reject the program.)</p>
</div>
<div class="section" id="interface-checks">
<span id="blank-implements"></span><h3>Interface checks<a class="headerlink" href="#interface-checks" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>As we saw in the discussion of <a class="reference external" href="#interfaces_and_types">interfaces</a>
above, a type need not declare explicitly that it implements an
interface. Instead, a type implements the interface just by implementing
the interface's methods. In practice, most interface conversions are
static and therefore checked at compile time. For example, passing an
<strong>*os.File</strong> to a function expecting an <strong>io.Reader</strong> will not compile
unless <strong>*os.File</strong> implements the <strong>io.Reader</strong> interface.</p>
<p>Some interface checks do happen at run-time, though. One instance is in
the <strong>encoding/json</strong> package, which defines a <strong>Marshaler</strong> interface.
When the JSON encoder receives a value that implements that interface,
the encoder invokes the value's marshaling method to convert it to JSON
instead of doing the standard conversion. The encoder checks this
property at run time with a <a class="reference external" href="#interface_conversions">type assertion</a>
like:</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">m</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">val</span><span class="p">.(</span><span class="nx">json</span><span class="p">.</span><span class="nx">Marshaler</span><span class="p">)</span>
</pre></div>
</div>
<p>If it's necessary only to ask whether a type implements an interface,
without actually using the interface itself, perhaps as part of an error
check, use the blank identifier to ignore the type-asserted value:</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">val</span><span class="p">.(</span><span class="nx">json</span><span class="p">.</span><span class="nx">Marshaler</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;value %v of type %T implements json.Marshaler\n&quot;</span><span class="p">,</span> <span class="nx">val</span><span class="p">,</span> <span class="nx">val</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>One place this situation arises is when it is necessary to guarantee
within the package implementing the type that it actually satisfies the
interface. If a type—for example, <strong>json.RawMessage</strong>—needs a custom
JSON representation, it should implement <strong>json.Marshaler</strong>, but there
are no static conversions that would cause the compiler to verify this
automatically. If the type inadvertently fails to satisfy the interface,
the JSON encoder will still work, but will not use the custom
implementation. To guarantee that the implementation is correct, a
global declaration using the blank identifier can be used in the
package:</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">_</span> <span class="nx">json</span><span class="p">.</span><span class="nx">Marshaler</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">RawMessage</span><span class="p">)(</span><span class="kc">nil</span><span class="p">)</span>
</pre></div>
</div>
<p>In this declaration, the assignment involving a conversion of a
<strong>*RawMessage</strong> to a <strong>Marshaler</strong> requires that <strong>*RawMessage</strong>
implements <strong>Marshaler</strong>, and that property will be checked at compile
time. Should the <strong>json.Marshaler</strong> interface change, this package will
no longer compile and we will be on notice that it needs to be updated.</p>
<p>The appearance of the blank identifier in this construct indicates that
the declaration exists only for the type checking, not to create a
variable. Don't do this for every type that satisfies an interface,
though. By convention, such declarations are only used when there are no
static conversions already present in the code, which is a rare event.</p>
</div>
</div>
<div class="section" id="id39">
<h2>埋め込み<a class="headerlink" href="#id39" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Go does not provide the typical, type-driven notion of subclassing, but
it does have the ability to “borrow” pieces of an implementation by
<em>embedding</em> types within a struct or interface.</p>
<p>Interface embedding is very simple. We've mentioned the <strong>io.Reader</strong>
and <strong>io.Writer</strong> interfaces before; here are their definitions.</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">Reader</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nx">Read</span><span class="p">(</span><span class="nx">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Writer</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nx">Write</span><span class="p">(</span><span class="nx">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The <strong>io</strong> package also exports several other interfaces that specify
objects that can implement several such methods. For instance, there is
<strong>io.ReadWriter</strong>, an interface containing both <strong>Read</strong> and <strong>Write</strong>.
We could specify <strong>io.ReadWriter</strong> by listing the two methods
explicitly, but it's easier and more evocative to embed the two
interfaces to form the new one, like this:</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// ReadWriter is the interface that combines the Reader and Writer interfaces.</span>
<span class="kd">type</span> <span class="nx">ReadWriter</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nx">Reader</span>
    <span class="nx">Writer</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This says just what it looks like: A <strong>ReadWriter</strong> can do what a
<strong>Reader</strong> does <em>and</em> what a <strong>Writer</strong> does; it is a union of the
embedded interfaces (which must be disjoint sets of methods). Only
interfaces can be embedded within interfaces.</p>
<p>The same basic idea applies to structs, but with more far-reaching
implications. The <strong>bufio</strong> package has two struct types,
<strong>bufio.Reader</strong> and <strong>bufio.Writer</strong>, each of which of course
implements the analogous interfaces from package <strong>io</strong>. And <strong>bufio</strong>
also implements a buffered reader/writer, which it does by combining a
reader and a writer into one struct using embedding: it lists the types
within the struct but does not give them field names.</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// ReadWriter stores pointers to a Reader and a Writer.</span>
<span class="c1">// It implements io.ReadWriter.</span>
<span class="kd">type</span> <span class="nx">ReadWriter</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="o">*</span><span class="nx">Reader</span>  <span class="c1">// *bufio.Reader</span>
    <span class="o">*</span><span class="nx">Writer</span>  <span class="c1">// *bufio.Writer</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The embedded elements are pointers to structs and of course must be
initialized to point to valid structs before they can be used. The
<strong>ReadWriter</strong> struct could be written as</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">ReadWriter</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">reader</span> <span class="o">*</span><span class="nx">Reader</span>
    <span class="nx">writer</span> <span class="o">*</span><span class="nx">Writer</span>
<span class="p">}</span>
</pre></div>
</div>
<p>but then to promote the methods of the fields and to satisfy the <strong>io</strong>
interfaces, we would also need to provide forwarding methods, like this:</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="p">(</span><span class="nx">rw</span> <span class="o">*</span><span class="nx">ReadWriter</span><span class="p">)</span> <span class="nx">Read</span><span class="p">(</span><span class="nx">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">rw</span><span class="p">.</span><span class="nx">reader</span><span class="p">.</span><span class="nx">Read</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>By embedding the structs directly, we avoid this bookkeeping. The
methods of embedded types come along for free, which means that
<strong>bufio.ReadWriter</strong> not only has the methods of <strong>bufio.Reader</strong> and
<strong>bufio.Writer</strong>, it also satisfies all three interfaces: <strong>io.Reader</strong>,
<strong>io.Writer</strong>, and <strong>io.ReadWriter</strong>.</p>
<p>There's an important way in which embedding differs from subclassing.
When we embed a type, the methods of that type become methods of the
outer type, but when they are invoked the receiver of the method is the
inner type, not the outer one. In our example, when the <strong>Read</strong> method
of a <strong>bufio.ReadWriter</strong> is invoked, it has exactly the same effect as
the forwarding method written out above; the receiver is the <strong>reader</strong>
field of the <strong>ReadWriter</strong>, not the <strong>ReadWriter</strong> itself.</p>
<p>Embedding can also be a simple convenience. This example shows an
embedded field alongside a regular, named field.</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">Job</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Command</span> <span class="kt">string</span>
    <span class="o">*</span><span class="nx">log</span><span class="p">.</span><span class="nx">Logger</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The <strong>Job</strong> type now has the <strong>Print</strong>, <strong>Printf</strong>, <strong>Println</strong> and
other methods of <strong>*log.Logger</strong>. We could have given the <strong>Logger</strong> a
field name, of course, but it's not necessary to do so. And now, once
initialized, we can log to the <strong>Job</strong>:</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">job</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;starting now...&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>The <strong>Logger</strong> is a regular field of the <strong>Job</strong> struct, so we can
initialize it in the usual way inside the constructor for <strong>Job</strong>, like
this,</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">NewJob</span><span class="p">(</span><span class="nx">command</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">logger</span> <span class="o">*</span><span class="nx">log</span><span class="p">.</span><span class="nx">Logger</span><span class="p">)</span> <span class="o">*</span><span class="nx">Job</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="nx">Job</span><span class="p">{</span><span class="nx">command</span><span class="p">,</span> <span class="nx">logger</span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>or with a composite literal,</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">job</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Job</span><span class="p">{</span><span class="nx">command</span><span class="p">,</span> <span class="nx">log</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stderr</span><span class="p">,</span> <span class="s">&quot;Job: &quot;</span><span class="p">,</span> <span class="nx">log</span><span class="p">.</span><span class="nx">Ldate</span><span class="p">)}</span>
</pre></div>
</div>
<p>If we need to refer to an embedded field directly, the type name of the
field, ignoring the package qualifier, serves as a field name, as it did
in the <strong>Read</strong> method of our <strong>ReadWriter</strong> struct. Here, if we needed
to access the <strong>*log.Logger</strong> of a <strong>Job</strong> variable <strong>job</strong>, we would
write <strong>job.Logger</strong>, which would be useful if we wanted to refine the
methods of <strong>Logger</strong>.</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="p">(</span><span class="nx">job</span> <span class="o">*</span><span class="nx">Job</span><span class="p">)</span> <span class="nx">Printf</span><span class="p">(</span><span class="nx">format</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">args</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
    <span class="nx">job</span><span class="p">.</span><span class="nx">Logger</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%q: %s&quot;</span><span class="p">,</span> <span class="nx">job</span><span class="p">.</span><span class="nx">Command</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="nx">format</span><span class="p">,</span> <span class="nx">args</span><span class="o">...</span><span class="p">))</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Embedding types introduces the problem of name conflicts but the rules
to resolve them are simple. First, a field or method <strong>X</strong> hides any
other item <strong>X</strong> in a more deeply nested part of the type. If
<strong>log.Logger</strong> contained a field or method called <strong>Command</strong>, the
<strong>Command</strong> field of <strong>Job</strong> would dominate it.</p>
<p>Second, if the same name appears at the same nesting level, it is
usually an error; it would be erroneous to embed <strong>log.Logger</strong> if the
<strong>Job</strong> struct contained another field or method called <strong>Logger</strong>.
However, if the duplicate name is never mentioned in the program outside
the type definition, it is OK. This qualification provides some
protection against changes made to types embedded from outside; there is
no problem if a field is added that conflicts with another field in
another subtype if neither field is ever used.</p>
</div>
<div class="section" id="id40">
<h2>並行処理<a class="headerlink" href="#id40" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="sharing">
<span id="id41"></span><h3>通信による共有<a class="headerlink" href="#sharing" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Concurrent programming is a large topic and there is space only for some
Go-specific highlights here.</p>
<p>Concurrent programming in many environments is made difficult by the
subtleties required to implement correct access to shared variables. Go
encourages a different approach in which shared values are passed around
on channels and, in fact, never actively shared by separate threads of
execution. Only one goroutine has access to the value at any given time.
Data races cannot occur, by design. To encourage this way of thinking we
have reduced it to a slogan:</p>
<blockquote>
<div><p>Do not communicate by sharing memory; instead, share memory by
communicating.</p>
</div></blockquote>
<p>This approach can be taken too far. Reference counts may be best done by
putting a mutex around an integer variable, for instance. But as a
high-level approach, using channels to control access makes it easier to
write clear, correct programs.</p>
<p>One way to think about this model is to consider a typical
single-threaded program running on one CPU. It has no need for
synchronization primitives. Now run another such instance; it too needs
no synchronization. Now let those two communicate; if the communication
is the synchronizer, there's still no need for other synchronization.
Unix pipelines, for example, fit this model perfectly. Although Go's
approach to concurrency originates in Hoare's Communicating Sequential
Processes (CSP), it can also be seen as a type-safe generalization of
Unix pipes.</p>
</div>
<div class="section" id="id42">
<h3>ゴルーチン<a class="headerlink" href="#id42" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>They're called <em>goroutines</em> because the existing terms—threads,
coroutines, processes, and so on—convey inaccurate connotations. A
goroutine has a simple model: it is a function executing concurrently
with other goroutines in the same address space. It is lightweight,
costing little more than the allocation of stack space. And the stacks
start small, so they are cheap, and grow by allocating (and freeing)
heap storage as required.</p>
<p>Goroutines are multiplexed onto multiple OS threads so if one should
block, such as while waiting for I/O, others continue to run. Their
design hides many of the complexities of thread creation and management.</p>
<p>Prefix a function or method call with the <strong>go</strong> keyword to run the call
in a new goroutine. When the call completes, the goroutine exits,
silently. (The effect is similar to the Unix shell's <strong>&amp;</strong> notation for
running a command in the background.)</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="k">go</span> <span class="nx">list</span><span class="p">.</span><span class="nx">Sort</span><span class="p">()</span>  <span class="c1">// run list.Sort concurrently; don&#39;t wait for it.</span>
</pre></div>
</div>
<p>A function literal can be handy in a goroutine invocation.</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">Announce</span><span class="p">(</span><span class="nx">message</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">delay</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">time</span><span class="p">.</span><span class="nx">Sleep</span><span class="p">(</span><span class="nx">delay</span><span class="p">)</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">message</span><span class="p">)</span>
    <span class="p">}()</span>  <span class="c1">// Note the parentheses - must call the function.</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In Go, function literals are closures: the implementation makes sure the
variables referred to by the function survive as long as they are
active.</p>
<p>These examples aren't too practical because the functions have no way of
signaling completion. For that, we need channels.</p>
</div>
<div class="section" id="id43">
<h3>チャンネル<a class="headerlink" href="#id43" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Like maps, channels are allocated with <strong>make</strong>, and the resulting value
acts as a reference to an underlying data structure. If an optional
integer parameter is provided, it sets the buffer size for the channel.
The default is zero, for an unbuffered or synchronous channel.</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">ci</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>            <span class="c1">// unbuffered channel of integers</span>
<span class="nx">cj</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>         <span class="c1">// unbuffered channel of integers</span>
<span class="nx">cs</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="o">*</span><span class="nx">os</span><span class="p">.</span><span class="nx">File</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>  <span class="c1">// buffered channel of pointers to Files</span>
</pre></div>
</div>
<p>Unbuffered channels combine communication—the exchange of a value—with
synchronization—guaranteeing that two calculations (goroutines) are in a
known state.</p>
<p>There are lots of nice idioms using channels. Here's one to get us
started. In the previous section we launched a sort in the background. A
channel can allow the launching goroutine to wait for the sort to
complete.</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">c</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>  <span class="c1">// Allocate a channel.</span>
<span class="c1">// Start the sort in a goroutine; when it completes, signal on the channel.</span>
<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">list</span><span class="p">.</span><span class="nx">Sort</span><span class="p">()</span>
    <span class="nx">c</span> <span class="o">&lt;-</span> <span class="mi">1</span>  <span class="c1">// Send a signal; value does not matter.</span>
<span class="p">}()</span>
<span class="nx">doSomethingForAWhile</span><span class="p">()</span>
<span class="o">&lt;-</span><span class="nx">c</span>   <span class="c1">// Wait for sort to finish; discard sent value.</span>
</pre></div>
</div>
<p>Receivers always block until there is data to receive. If the channel is
unbuffered, the sender blocks until the receiver has received the value.
If the channel has a buffer, the sender blocks only until the value has
been copied to the buffer; if the buffer is full, this means waiting
until some receiver has retrieved a value.</p>
<p>A buffered channel can be used like a semaphore, for instance to limit
throughput. In this example, incoming requests are passed to <strong>handle</strong>,
which sends a value into the channel, processes the request, and then
receives a value from the channel to ready the “semaphore” for the next
consumer. The capacity of the channel buffer limits the number of
simultaneous calls to <strong>process</strong>.</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">sem</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">MaxOutstanding</span><span class="p">)</span>

<span class="kd">func</span> <span class="nx">handle</span><span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">sem</span> <span class="o">&lt;-</span> <span class="mi">1</span>    <span class="c1">// Wait for active queue to drain.</span>
    <span class="nx">process</span><span class="p">(</span><span class="nx">r</span><span class="p">)</span>  <span class="c1">// May take a long time.</span>
    <span class="o">&lt;-</span><span class="nx">sem</span>       <span class="c1">// Done; enable next request to run.</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">Serve</span><span class="p">(</span><span class="nx">queue</span> <span class="kd">chan</span> <span class="o">*</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">{</span>
        <span class="nx">req</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">queue</span>
        <span class="k">go</span> <span class="nx">handle</span><span class="p">(</span><span class="nx">req</span><span class="p">)</span>  <span class="c1">// Don&#39;t wait for handle to finish.</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Once <strong>MaxOutstanding</strong> handlers are executing <strong>process</strong>, any more
will block trying to send into the filled channel buffer, until one of
the existing handlers finishes and receives from the buffer.</p>
<p>This design has a problem, though: <strong>Serve</strong> creates a new goroutine for
every incoming request, even though only <strong>MaxOutstanding</strong> of them can
run at any moment. As a result, the program can consume unlimited
resources if the requests come in too fast. We can address that
deficiency by changing <strong>Serve</strong> to gate the creation of the goroutines.
Here's an obvious solution, but beware it has a bug we'll fix
subsequently:</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">Serve</span><span class="p">(</span><span class="nx">queue</span> <span class="kd">chan</span> <span class="o">*</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">req</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">queue</span> <span class="p">{</span>
        <span class="nx">sem</span> <span class="o">&lt;-</span> <span class="mi">1</span>
        <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
            <span class="nx">process</span><span class="p">(</span><span class="nx">req</span><span class="p">)</span> <span class="c1">// Buggy; see explanation below.</span>
            <span class="o">&lt;-</span><span class="nx">sem</span>
        <span class="p">}()</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The bug is that in a Go <strong>for</strong> loop, the loop variable is reused for
each iteration, so the <strong>req</strong> variable is shared across all goroutines.
That's not what we want. We need to make sure that <strong>req</strong> is unique for
each goroutine. Here's one way to do that, passing the value of <strong>req</strong>
as an argument to the closure in the goroutine:</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">Serve</span><span class="p">(</span><span class="nx">queue</span> <span class="kd">chan</span> <span class="o">*</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">req</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">queue</span> <span class="p">{</span>
        <span class="nx">sem</span> <span class="o">&lt;-</span> <span class="mi">1</span>
        <span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">req</span> <span class="o">*</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">process</span><span class="p">(</span><span class="nx">req</span><span class="p">)</span>
            <span class="o">&lt;-</span><span class="nx">sem</span>
        <span class="p">}(</span><span class="nx">req</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Compare this version with the previous to see the difference in how the
closure is declared and run. Another solution is just to create a new
variable with the same name, as in this example:</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">Serve</span><span class="p">(</span><span class="nx">queue</span> <span class="kd">chan</span> <span class="o">*</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">req</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">queue</span> <span class="p">{</span>
        <span class="nx">req</span> <span class="o">:=</span> <span class="nx">req</span> <span class="c1">// Create new instance of req for the goroutine.</span>
        <span class="nx">sem</span> <span class="o">&lt;-</span> <span class="mi">1</span>
        <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
            <span class="nx">process</span><span class="p">(</span><span class="nx">req</span><span class="p">)</span>
            <span class="o">&lt;-</span><span class="nx">sem</span>
        <span class="p">}()</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>It may seem odd to write</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">req</span> <span class="o">:=</span> <span class="nx">req</span>
</pre></div>
</div>
<p>but it's legal and idiomatic in Go to do this. You get a fresh version
of the variable with the same name, deliberately shadowing the loop
variable locally but unique to each goroutine.</p>
<p>Going back to the general problem of writing the server, another
approach that manages resources well is to start a fixed number of
<strong>handle</strong> goroutines all reading from the request channel. The number
of goroutines limits the number of simultaneous calls to <strong>process</strong>.
This <strong>Serve</strong> function also accepts a channel on which it will be told
to exit; after launching the goroutines it blocks receiving from that
channel.</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">handle</span><span class="p">(</span><span class="nx">queue</span> <span class="kd">chan</span> <span class="o">*</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">r</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">queue</span> <span class="p">{</span>
        <span class="nx">process</span><span class="p">(</span><span class="nx">r</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">Serve</span><span class="p">(</span><span class="nx">clientRequests</span> <span class="kd">chan</span> <span class="o">*</span><span class="nx">Request</span><span class="p">,</span> <span class="nx">quit</span> <span class="kd">chan</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Start handlers</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">MaxOutstanding</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="k">go</span> <span class="nx">handle</span><span class="p">(</span><span class="nx">clientRequests</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="o">&lt;-</span><span class="nx">quit</span>  <span class="c1">// Wait to be told to exit.</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="channels-of-channels">
<span id="chan-of-chan"></span><h3>Channels of channels<a class="headerlink" href="#channels-of-channels" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>One of the most important properties of Go is that a channel is a
first-class value that can be allocated and passed around like any
other. A common use of this property is to implement safe, parallel
demultiplexing.</p>
<p>In the example in the previous section, <strong>handle</strong> was an idealized
handler for a request but we didn't define the type it was handling. If
that type includes a channel on which to reply, each client can provide
its own path for the answer. Here's a schematic definition of type
<strong>Request</strong>.</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">Request</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">args</span>        <span class="p">[]</span><span class="kt">int</span>
    <span class="nx">f</span>           <span class="kd">func</span><span class="p">([]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span>
    <span class="nx">resultChan</span>  <span class="kd">chan</span> <span class="kt">int</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The client provides a function and its arguments, as well as a channel
inside the request object on which to receive the answer.</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">sum</span><span class="p">(</span><span class="nx">a</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="nx">s</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">a</span> <span class="p">{</span>
        <span class="nx">s</span> <span class="o">+=</span> <span class="nx">v</span>
    <span class="p">}</span>
    <span class="k">return</span>
<span class="p">}</span>

<span class="nx">request</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Request</span><span class="p">{[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">},</span> <span class="nx">sum</span><span class="p">,</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)}</span>
<span class="c1">// Send request</span>
<span class="nx">clientRequests</span> <span class="o">&lt;-</span> <span class="nx">request</span>
<span class="c1">// Wait for response.</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;answer: %d\n&quot;</span><span class="p">,</span> <span class="o">&lt;-</span><span class="nx">request</span><span class="p">.</span><span class="nx">resultChan</span><span class="p">)</span>
</pre></div>
</div>
<p>On the server side, the handler function is the only thing that changes.</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">handle</span><span class="p">(</span><span class="nx">queue</span> <span class="kd">chan</span> <span class="o">*</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">req</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">queue</span> <span class="p">{</span>
        <span class="nx">req</span><span class="p">.</span><span class="nx">resultChan</span> <span class="o">&lt;-</span> <span class="nx">req</span><span class="p">.</span><span class="nx">f</span><span class="p">(</span><span class="nx">req</span><span class="p">.</span><span class="nx">args</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>There's clearly a lot more to do to make it realistic, but this code is
a framework for a rate-limited, parallel, non-blocking RPC system, and
there's not a mutex in sight.</p>
</div>
<div class="section" id="parallelization">
<span id="parallel"></span><h3>Parallelization<a class="headerlink" href="#parallelization" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Another application of these ideas is to parallelize a calculation
across multiple CPU cores. If the calculation can be broken into
separate pieces that can execute independently, it can be parallelized,
with a channel to signal when each piece completes.</p>
<p>Let's say we have an expensive operation to perform on a vector of
items, and that the value of the operation on each item is independent,
as in this idealized example.</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">Vector</span> <span class="p">[]</span><span class="kt">float64</span>

<span class="c1">// Apply the operation to v[i], v[i+1] ... up to v[n-1].</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="nx">Vector</span><span class="p">)</span> <span class="nx">DoSome</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">u</span> <span class="nx">Vector</span><span class="p">,</span> <span class="nx">c</span> <span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="nx">v</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">+=</span> <span class="nx">u</span><span class="p">.</span><span class="nx">Op</span><span class="p">(</span><span class="nx">v</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
    <span class="p">}</span>
    <span class="nx">c</span> <span class="o">&lt;-</span> <span class="mi">1</span>    <span class="c1">// signal that this piece is done</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We launch the pieces independently in a loop, one per CPU. They can
complete in any order but it doesn't matter; we just count the
completion signals by draining the channel after launching all the
goroutines.</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">const</span> <span class="nx">numCPU</span> <span class="p">=</span> <span class="mi">4</span> <span class="c1">// number of CPU cores</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="nx">Vector</span><span class="p">)</span> <span class="nx">DoAll</span><span class="p">(</span><span class="nx">u</span> <span class="nx">Vector</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">c</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">numCPU</span><span class="p">)</span>  <span class="c1">// Buffering optional but sensible.</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">numCPU</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="k">go</span> <span class="nx">v</span><span class="p">.</span><span class="nx">DoSome</span><span class="p">(</span><span class="nx">i</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span><span class="o">/</span><span class="nx">numCPU</span><span class="p">,</span> <span class="p">(</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span><span class="o">/</span><span class="nx">numCPU</span><span class="p">,</span> <span class="nx">u</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="c1">// Drain the channel.</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">numCPU</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="o">&lt;-</span><span class="nx">c</span>    <span class="c1">// wait for one task to complete</span>
    <span class="p">}</span>
    <span class="c1">// All done.</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Rather than create a constant value for numCPU, we can ask the runtime
what value is appropriate. The function <strong>runtime.NumCPU</strong> returns the
number of hardware CPU cores in the machine, so we could write</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">numCPU</span> <span class="p">=</span> <span class="nx">runtime</span><span class="p">.</span><span class="nx">NumCPU</span><span class="p">()</span>
</pre></div>
</div>
<p>There is also a function <strong>runtime.GOMAXPROCS</strong>, which reports (or sets)
the user-specified number of cores that a Go program can have running
simultaneously. It defaults to the value of <strong>runtime.NumCPU</strong> but can
be overridden by setting the similarly named shell environment variable
or by calling the function with a positive number. Calling it with zero
just queries the value. Therefore if we want to honor the user's
resource request, we should write</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">numCPU</span> <span class="p">=</span> <span class="nx">runtime</span><span class="p">.</span><span class="nx">GOMAXPROCS</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>Be sure not to confuse the ideas of concurrency—structuring a program as
independently executing components—and parallelism—executing
calculations in parallel for efficiency on multiple CPUs. Although the
concurrency features of Go can make some problems easy to structure as
parallel computations, Go is a concurrent language, not a parallel one,
and not all parallelization problems fit Go's model. For a discussion of
the distinction, see the talk cited in <a class="reference external" href="//blog.golang.org/2013/01/concurrency-is-not-parallelism.html">this blog
post</a>.</p>
</div>
<div class="section" id="a-leaky-buffer">
<span id="leaky-buffer"></span><h3>A leaky buffer<a class="headerlink" href="#a-leaky-buffer" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>The tools of concurrent programming can even make non-concurrent ideas
easier to express. Here's an example abstracted from an RPC package. The
client goroutine loops receiving data from some source, perhaps a
network. To avoid allocating and freeing buffers, it keeps a free list,
and uses a buffered channel to represent it. If the channel is empty, a
new buffer gets allocated. Once the message buffer is ready, it's sent
to the server on <strong>serverChan</strong>.</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">freeList</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="o">*</span><span class="nx">Buffer</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="kd">var</span> <span class="nx">serverChan</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="o">*</span><span class="nx">Buffer</span><span class="p">)</span>

<span class="kd">func</span> <span class="nx">client</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">b</span> <span class="o">*</span><span class="nx">Buffer</span>
        <span class="c1">// Grab a buffer if available; allocate if not.</span>
        <span class="k">select</span> <span class="p">{</span>
        <span class="k">case</span> <span class="nx">b</span> <span class="p">=</span> <span class="o">&lt;-</span><span class="nx">freeList</span><span class="p">:</span>
            <span class="c1">// Got one; nothing more to do.</span>
        <span class="k">default</span><span class="p">:</span>
            <span class="c1">// None free, so allocate a new one.</span>
            <span class="nx">b</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">Buffer</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="nx">load</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span>              <span class="c1">// Read next message from the net.</span>
        <span class="nx">serverChan</span> <span class="o">&lt;-</span> <span class="nx">b</span>      <span class="c1">// Send to server.</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The server loop receives each message from the client, processes it, and
returns the buffer to the free list.</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">server</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">{</span>
        <span class="nx">b</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">serverChan</span>    <span class="c1">// Wait for work.</span>
        <span class="nx">process</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span>
        <span class="c1">// Reuse buffer if there&#39;s room.</span>
        <span class="k">select</span> <span class="p">{</span>
        <span class="k">case</span> <span class="nx">freeList</span> <span class="o">&lt;-</span> <span class="nx">b</span><span class="p">:</span>
            <span class="c1">// Buffer on free list; nothing more to do.</span>
        <span class="k">default</span><span class="p">:</span>
            <span class="c1">// Free list full, just carry on.</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The client attempts to retrieve a buffer from <strong>freeList</strong>; if none is
available, it allocates a fresh one. The server's send to <strong>freeList</strong>
puts <strong>b</strong> back on the free list unless the list is full, in which case
the buffer is dropped on the floor to be reclaimed by the garbage
collector. (The <strong>default</strong> clauses in the <strong>select</strong> statements execute
when no other case is ready, meaning that the <strong>selects</strong> never block.)
This implementation builds a leaky bucket free list in just a few lines,
relying on the buffered channel and the garbage collector for
bookkeeping.</p>
</div>
</div>
<div class="section" id="id44">
<h2>エラー<a class="headerlink" href="#id44" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Library routines must often return some sort of error indication to the
caller. As mentioned earlier, Go's multivalue return makes it easy to
return a detailed error description alongside the normal return value.
It is good style to use this feature to provide detailed error
information. For example, as we'll see, <strong>os.Open</strong> doesn't just return
a <strong>nil</strong> pointer on failure, it also returns an error value that
describes what went wrong.</p>
<p>By convention, errors have type <strong>error</strong>, a simple built-in interface.</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="kt">error</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nx">Error</span><span class="p">()</span> <span class="kt">string</span>
<span class="p">}</span>
</pre></div>
</div>
<p>A library writer is free to implement this interface with a richer model
under the covers, making it possible not only to see the error but also
to provide some context. As mentioned, alongside the usual <strong>*os.File</strong>
return value, <strong>os.Open</strong> also returns an error value. If the file is
opened successfully, the error will be <strong>nil</strong>, but when there is a
problem, it will hold an <strong>os.PathError</strong>:</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// PathError records an error and the operation and</span>
<span class="c1">// file path that caused it.</span>
<span class="kd">type</span> <span class="nx">PathError</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Op</span> <span class="kt">string</span>    <span class="c1">// &quot;open&quot;, &quot;unlink&quot;, etc.</span>
    <span class="nx">Path</span> <span class="kt">string</span>  <span class="c1">// The associated file.</span>
    <span class="nx">Err</span> <span class="kt">error</span>    <span class="c1">// Returned by the system call.</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">PathError</span><span class="p">)</span> <span class="nx">Error</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">e</span><span class="p">.</span><span class="nx">Op</span> <span class="o">+</span> <span class="s">&quot; &quot;</span> <span class="o">+</span> <span class="nx">e</span><span class="p">.</span><span class="nx">Path</span> <span class="o">+</span> <span class="s">&quot;: &quot;</span> <span class="o">+</span> <span class="nx">e</span><span class="p">.</span><span class="nx">Err</span><span class="p">.</span><span class="nx">Error</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong>PathError</strong>'s <strong>Error</strong> generates a string like this:</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">open</span> <span class="o">/</span><span class="nx">etc</span><span class="o">/</span><span class="nx">passwx</span><span class="p">:</span> <span class="nx">no</span> <span class="nx">such</span> <span class="nx">file</span> <span class="nx">or</span> <span class="nx">directory</span>
</pre></div>
</div>
<p>Such an error, which includes the problematic file name, the operation,
and the operating system error it triggered, is useful even if printed
far from the call that caused it; it is much more informative than the
plain &quot;no such file or directory&quot;.</p>
<p>When feasible, error strings should identify their origin, such as by
having a prefix naming the operation or package that generated the
error. For example, in package <strong>image</strong>, the string representation for
a decoding error due to an unknown format is &quot;image: unknown format&quot;.</p>
<p>Callers that care about the precise error details can use a type switch
or a type assertion to look for specific errors and extract details. For
<strong>PathErrors</strong> this might include examining the internal <strong>Err</strong> field
for recoverable failures.</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="nx">try</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">try</span> <span class="p">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="nx">try</span><span class="o">++</span> <span class="p">{</span>
    <span class="nx">file</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Create</span><span class="p">(</span><span class="nx">filename</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">e</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">err</span><span class="p">.(</span><span class="o">*</span><span class="nx">os</span><span class="p">.</span><span class="nx">PathError</span><span class="p">);</span> <span class="nx">ok</span> <span class="o">&amp;&amp;</span> <span class="nx">e</span><span class="p">.</span><span class="nx">Err</span> <span class="o">==</span> <span class="nx">syscall</span><span class="p">.</span><span class="nx">ENOSPC</span> <span class="p">{</span>
        <span class="nx">deleteTempFiles</span><span class="p">()</span>  <span class="c1">// Recover some space.</span>
        <span class="k">continue</span>
    <span class="p">}</span>
    <span class="k">return</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The second <strong>if</strong> statement here is another <a class="reference external" href="#interface_conversions">type
assertion</a>. If it fails, <strong>ok</strong> will be
false, and <strong>e</strong> will be <strong>nil</strong>. If it succeeds, <strong>ok</strong> will be true,
which means the error was of type <strong>*os.PathError</strong>, and then so is
<strong>e</strong>, which we can examine for more information about the error.</p>
<div class="section" id="panic">
<h3>Panic<a class="headerlink" href="#panic" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>The usual way to report an error to a caller is to return an <strong>error</strong>
as an extra return value. The canonical <strong>Read</strong> method is a well-known
instance; it returns a byte count and an <strong>error</strong>. But what if the
error is unrecoverable? Sometimes the program simply cannot continue.</p>
<p>For this purpose, there is a built-in function <strong>panic</strong> that in effect
creates a run-time error that will stop the program (but see the next
section). The function takes a single argument of arbitrary type—often a
string—to be printed as the program dies. It's also a way to indicate
that something impossible has happened, such as exiting an infinite
loop.</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// A toy implementation of cube root using Newton&#39;s method.</span>
<span class="kd">func</span> <span class="nx">CubeRoot</span><span class="p">(</span><span class="nx">x</span> <span class="kt">float64</span><span class="p">)</span> <span class="kt">float64</span> <span class="p">{</span>
    <span class="nx">z</span> <span class="o">:=</span> <span class="nx">x</span><span class="o">/</span><span class="mi">3</span>   <span class="c1">// Arbitrary initial value</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mf">1e6</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="nx">prevz</span> <span class="o">:=</span> <span class="nx">z</span>
        <span class="nx">z</span> <span class="o">-=</span> <span class="p">(</span><span class="nx">z</span><span class="o">*</span><span class="nx">z</span><span class="o">*</span><span class="nx">z</span><span class="o">-</span><span class="nx">x</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="nx">z</span><span class="o">*</span><span class="nx">z</span><span class="p">)</span>
        <span class="k">if</span> <span class="nx">veryClose</span><span class="p">(</span><span class="nx">z</span><span class="p">,</span> <span class="nx">prevz</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">z</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// A million iterations has not converged; something is wrong.</span>
    <span class="nb">panic</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&quot;CubeRoot(%g) did not converge&quot;</span><span class="p">,</span> <span class="nx">x</span><span class="p">))</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This is only an example but real library functions should avoid
<strong>panic</strong>. If the problem can be masked or worked around, it's always
better to let things continue to run rather than taking down the whole
program. One possible counterexample is during initialization: if the
library truly cannot set itself up, it might be reasonable to panic, so
to speak.</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">user</span> <span class="p">=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Getenv</span><span class="p">(</span><span class="s">&quot;USER&quot;</span><span class="p">)</span>

<span class="kd">func</span> <span class="nx">init</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">user</span> <span class="o">==</span> <span class="s">&quot;&quot;</span> <span class="p">{</span>
        <span class="nb">panic</span><span class="p">(</span><span class="s">&quot;no value for $USER&quot;</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="recover">
<h3>Recover<a class="headerlink" href="#recover" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>When <strong>panic</strong> is called, including implicitly for run-time errors such
as indexing a slice out of bounds or failing a type assertion, it
immediately stops execution of the current function and begins unwinding
the stack of the goroutine, running any deferred functions along the
way. If that unwinding reaches the top of the goroutine's stack, the
program dies. However, it is possible to use the built-in function
<strong>recover</strong> to regain control of the goroutine and resume normal
execution.</p>
<p>A call to <strong>recover</strong> stops the unwinding and returns the argument
passed to <strong>panic</strong>. Because the only code that runs while unwinding is
inside deferred functions, <strong>recover</strong> is only useful inside deferred
functions.</p>
<p>One application of <strong>recover</strong> is to shut down a failing goroutine
inside a server without killing the other executing goroutines.</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">server</span><span class="p">(</span><span class="nx">workChan</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="o">*</span><span class="nx">Work</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">work</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">workChan</span> <span class="p">{</span>
        <span class="k">go</span> <span class="nx">safelyDo</span><span class="p">(</span><span class="nx">work</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">safelyDo</span><span class="p">(</span><span class="nx">work</span> <span class="o">*</span><span class="nx">Work</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nb">recover</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="nx">log</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;work failed:&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}()</span>
    <span class="nx">do</span><span class="p">(</span><span class="nx">work</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In this example, if <strong>do(work)</strong> panics, the result will be logged and
the goroutine will exit cleanly without disturbing the others. There's
no need to do anything else in the deferred closure; calling <strong>recover</strong>
handles the condition completely.</p>
<p>Because <strong>recover</strong> always returns <strong>nil</strong> unless called directly from a
deferred function, deferred code can call library routines that
themselves use <strong>panic</strong> and <strong>recover</strong> without failing. As an example,
the deferred function in <strong>safelyDo</strong> might call a logging function
before calling <strong>recover</strong>, and that logging code would run unaffected
by the panicking state.</p>
<p>With our recovery pattern in place, the <strong>do</strong> function (and anything it
calls) can get out of any bad situation cleanly by calling <strong>panic</strong>. We
can use that idea to simplify error handling in complex software. Let's
look at an idealized version of a <strong>regexp</strong> package, which reports
parsing errors by calling <strong>panic</strong> with a local error type. Here's the
definition of <strong>Error</strong>, an <strong>error</strong> method, and the <strong>Compile</strong>
function.</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// Error is the type of a parse error; it satisfies the error interface.</span>
<span class="kd">type</span> <span class="nx">Error</span> <span class="kt">string</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">e</span> <span class="nx">Error</span><span class="p">)</span> <span class="nx">Error</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">string</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// error is a method of *Regexp that reports parsing errors by</span>
<span class="c1">// panicking with an Error.</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">regexp</span> <span class="o">*</span><span class="nx">Regexp</span><span class="p">)</span> <span class="nb">error</span><span class="p">(</span><span class="nx">err</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">panic</span><span class="p">(</span><span class="nx">Error</span><span class="p">(</span><span class="nx">err</span><span class="p">))</span>
<span class="p">}</span>

<span class="c1">// Compile returns a parsed representation of the regular expression.</span>
<span class="kd">func</span> <span class="nx">Compile</span><span class="p">(</span><span class="nx">str</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">regexp</span> <span class="o">*</span><span class="nx">Regexp</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">regexp</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">Regexp</span><span class="p">)</span>
    <span class="c1">// doParse will panic if there is a parse error.</span>
    <span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">e</span> <span class="o">:=</span> <span class="nb">recover</span><span class="p">();</span> <span class="nx">e</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="nx">regexp</span> <span class="p">=</span> <span class="kc">nil</span>    <span class="c1">// Clear return value.</span>
            <span class="nx">err</span> <span class="p">=</span> <span class="nx">e</span><span class="p">.(</span><span class="nx">Error</span><span class="p">)</span> <span class="c1">// Will re-panic if not a parse error.</span>
        <span class="p">}</span>
    <span class="p">}()</span>
    <span class="k">return</span> <span class="nx">regexp</span><span class="p">.</span><span class="nx">doParse</span><span class="p">(</span><span class="nx">str</span><span class="p">),</span> <span class="kc">nil</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If <strong>doParse</strong> panics, the recovery block will set the return value to
<strong>nil</strong>—deferred functions can modify named return values. It will then
check, in the assignment to <strong>err</strong>, that the problem was a parse error
by asserting that it has the local type <strong>Error</strong>. If it does not, the
type assertion will fail, causing a run-time error that continues the
stack unwinding as though nothing had interrupted it. This check means
that if something unexpected happens, such as an index out of bounds,
the code will fail even though we are using <strong>panic</strong> and <strong>recover</strong> to
handle parse errors.</p>
<p>With error handling in place, the <strong>error</strong> method (because it's a
method bound to a type, it's fine, even natural, for it to have the same
name as the builtin <strong>error</strong> type) makes it easy to report parse errors
without worrying about unwinding the parse stack by hand:</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="nx">pos</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="nx">re</span><span class="p">.</span><span class="nb">error</span><span class="p">(</span><span class="s">&quot;&#39;*&#39; illegal at start of expression&quot;</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Useful though this pattern is, it should be used only within a package.
<strong>Parse</strong> turns its internal <strong>panic</strong> calls into <strong>error</strong> values; it
does not expose <strong>panics</strong> to its client. That is a good rule to follow.</p>
<p>By the way, this re-panic idiom changes the panic value if an actual
error occurs. However, both the original and new failures will be
presented in the crash report, so the root cause of the problem will
still be visible. Thus this simple re-panic approach is usually
sufficient—it's a crash after all—but if you want to display only the
original value, you can write a little more code to filter unexpected
problems and re-panic with the original error. That's left as an
exercise for the reader.</p>
</div>
</div>
<div class="section" id="web">
<span id="web-server"></span><h2>Webサーバー<a class="headerlink" href="#web" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>完全なGoのプログラムであるWebサーバを仕上げて終わりにしましょう。これは実際には一種の中継サーバです。Googleは <strong>chart.apis.google.com</strong> としてデータをチャートおよびグラフに自動的にフォーマットするサービスを提供しています。ただし、データをクエリとしてURLに送信する必要があるため、インタラクティブに使用することは困難です。ここでのプログラムはデータの1形式へのよりよいインターフェースを提供します。短いテキストを与えると、チャートサーバを呼び出し、テキストをエンコードする二次元のQRコードを生成します。その画像を携帯電話のカメラで取得して、たとえばURLとして解釈し、携帯電話の小さなキーボードにURLを入力する手間を省くことができます。</p>
<p>ここに完全なプログラムがあります。以下に従って説明します。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// Copyright 2009 The Go Authors. All rights reserved.</span>
<span class="c1">// Use of this source code is governed by a BSD-style</span>
<span class="c1">// license that can be found in the LICENSE file.</span>

<span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&quot;flag&quot;</span>
	<span class="s">&quot;html/template&quot;</span>
	<span class="s">&quot;log&quot;</span>
	<span class="s">&quot;net/http&quot;</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="nx">addr</span> <span class="p">=</span> <span class="nx">flag</span><span class="p">.</span><span class="nx">String</span><span class="p">(</span><span class="s">&quot;addr&quot;</span><span class="p">,</span> <span class="s">&quot;:1718&quot;</span><span class="p">,</span> <span class="s">&quot;http service address&quot;</span><span class="p">)</span> <span class="c1">// Q=17, R=18</span>

<span class="kd">var</span> <span class="nx">templ</span> <span class="p">=</span> <span class="nx">template</span><span class="p">.</span><span class="nx">Must</span><span class="p">(</span><span class="nx">template</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="s">&quot;qr&quot;</span><span class="p">).</span><span class="nx">Parse</span><span class="p">(</span><span class="nx">templateStr</span><span class="p">))</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">flag</span><span class="p">.</span><span class="nx">Parse</span><span class="p">()</span>
	<span class="nx">http</span><span class="p">.</span><span class="nx">Handle</span><span class="p">(</span><span class="s">&quot;/&quot;</span><span class="p">,</span> <span class="nx">http</span><span class="p">.</span><span class="nx">HandlerFunc</span><span class="p">(</span><span class="nx">QR</span><span class="p">))</span>
	<span class="nx">err</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ListenAndServe</span><span class="p">(</span><span class="o">*</span><span class="nx">addr</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">log</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="s">&quot;ListenAndServe:&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">QR</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">req</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">templ</span><span class="p">.</span><span class="nx">Execute</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="nx">req</span><span class="p">.</span><span class="nx">FormValue</span><span class="p">(</span><span class="s">&quot;s&quot;</span><span class="p">))</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">templateStr</span> <span class="p">=</span> <span class="s">`</span>
<span class="s">&lt;html&gt;</span>
<span class="s">&lt;head&gt;</span>
<span class="s">&lt;title&gt;QR Link Generator&lt;/title&gt;</span>
<span class="s">&lt;/head&gt;</span>
<span class="s">&lt;body&gt;</span>
<span class="s">{{if .}}</span>
<span class="s">&lt;img src=&quot;http://chart.apis.google.com/chart?chs=300x300&amp;cht=qr&amp;choe=UTF-8&amp;chl={{.}}&quot; /&gt;</span>
<span class="s">&lt;br&gt;</span>
<span class="s">{{.}}</span>
<span class="s">&lt;br&gt;</span>
<span class="s">&lt;br&gt;</span>
<span class="s">{{end}}</span>
<span class="s">&lt;form action=&quot;/&quot; name=f method=&quot;GET&quot;&gt;</span>
<span class="s">	&lt;input maxLength=1024 size=70 name=s value=&quot;&quot; title=&quot;Text to QR Encode&quot;&gt;</span>
<span class="s">	&lt;input type=submit value=&quot;Show QR&quot; name=qr&gt;</span>
<span class="s">&lt;/form&gt;</span>
<span class="s">&lt;/body&gt;</span>
<span class="s">&lt;/html&gt;</span>
<span class="s">`</span>
</pre></div>
</div>
<p>mainまでの部分は簡単に理解できるはずです。 1つのフラグは、サーバーのデフォルトHTTPポートを設定します。 テンプレート変数templは、面白いことが起こる場所です。 ページを表示するためにサーバーによって実行されるHTMLテンプレートを作成します。 それについてはすぐに説明します。</p>
<p>メイン関数はフラグを解析し、上で説明したメカニズムを使用して、関数 <strong>QR</strong> をサーバーのルートパスにバインドします。 次に、サーバーを起動するために <strong>http.ListenAndServe</strong> が呼び出されます。 サーバーの実行中はブロックされます。</p>
<p><strong>QR</strong> はフォームデータを含むリクエストを受信し、 <strong>s</strong> という名前のフォーム値のデータに対してテンプレートを実行します。</p>
<p>テンプレートパッケージ <strong>html/template</strong> は強力です。 このプログラムは、その機能に触れています。 本質的に、 <strong>templ.Execute</strong> に渡されるデータ項目（この場合はフォーム値）から派生した要素を置き換えることにより、HTMLテキストを即座に書き換えます。 テンプレートテキスト（templateStr）内で、二重括弧で区切られた部分はテンプレートアクションを示します。 <strong>{{if .}}</strong> から <strong>{{end}}</strong> の部分は、<strong>.</strong> と呼ばれる現在のデータ項目が空でない場合のみ実行されます。つまり、文字列が空の場合、テンプレートのこの部分は抑制されます。</p>
<p>2つのスニペット <strong>{{.}}</strong> は、テンプレートに提示されたデータ（クエリ文字列）をWebページに表示することを示しています。 HTMLテンプレートパッケージは、適切なエスケープを自動的に提供するため、テキストを安全に表示できます。</p>
<p>テンプレート文字列の残りの部分は、ページが読み込まれたときに表示するHTMLです。 説明が速すぎる場合は、テンプレートパッケージの <a href="#id45"><span class="problematic" id="id46">`</span></a>ドキュメント &lt;/pkg/html/template/&gt;`_で詳細を確認してください。</p>
<p>数行のコードといくつかのデータ駆動型HTMLテキストの便利なWebサーバーをあなたは持っています。 Goは、数行で多くのことを実行できるほど強力です。</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">目次</a></h3>
  <ul>
<li><a class="reference internal" href="#">Effective Go</a><ul>
<li><a class="reference internal" href="#id1">イントロダクション</a><ul>
<li><a class="reference internal" href="#id3">例</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id5">フォーマット</a></li>
<li><a class="reference internal" href="#id6">コメント</a></li>
<li><a class="reference internal" href="#id7">命名</a><ul>
<li><a class="reference internal" href="#id8">パッケージ名</a></li>
<li><a class="reference internal" href="#getters">ゲッター</a></li>
<li><a class="reference internal" href="#id10">インターフェース名</a></li>
<li><a class="reference internal" href="#mixedcaps">MixedCaps</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id11">セミコロン</a></li>
<li><a class="reference internal" href="#control-structures">制御構造(Control structures)</a><ul>
<li><a class="reference internal" href="#if">If</a></li>
<li><a class="reference internal" href="#redeclaration-and-reassignment">Redeclaration and reassignment</a></li>
<li><a class="reference internal" href="#for">For</a></li>
<li><a class="reference internal" href="#switch">Switch</a></li>
<li><a class="reference internal" href="#type-switch">Type switch</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id13">関数</a><ul>
<li><a class="reference internal" href="#multiple-returns">多値返却</a></li>
<li><a class="reference internal" href="#named-result-parameters">名前付き結果変数(Named result parameters)</a></li>
<li><a class="reference internal" href="#defer">Defer</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id15">データ</a><ul>
<li><a class="reference internal" href="#new"><strong>new</strong> によるアロケーション</a></li>
<li><a class="reference internal" href="#id16">コンストラクタと複合リテラル</a></li>
<li><a class="reference internal" href="#make"><strong>make</strong> によるアロケーション</a></li>
<li><a class="reference internal" href="#id17">配列</a></li>
<li><a class="reference internal" href="#id18">スライス</a></li>
<li><a class="reference internal" href="#id19">二次元スライス</a></li>
<li><a class="reference internal" href="#id20">マップ</a></li>
<li><a class="reference internal" href="#id22">プリント</a></li>
<li><a class="reference internal" href="#append">Append</a></li>
</ul>
</li>
<li><a class="reference internal" href="#initialization">初期化(Initialization)</a><ul>
<li><a class="reference internal" href="#id26">定数</a></li>
<li><a class="reference internal" href="#id31">変数</a></li>
<li><a class="reference internal" href="#init">init関数</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id33">メソッド</a><ul>
<li><a class="reference internal" href="#pointers-vs-values">ポインター vs 値</a></li>
</ul>
</li>
<li><a class="reference internal" href="#interfaces-and-types">インターフェースとその他の型</a><ul>
<li><a class="reference internal" href="#id36">インターフェース</a></li>
<li><a class="reference internal" href="#conversions">Conversions</a></li>
<li><a class="reference internal" href="#interface-conversions-and-type-assertions">Interface conversions and type assertions</a></li>
<li><a class="reference internal" href="#generality">Generality</a></li>
<li><a class="reference internal" href="#interface-methods">インターフェースとメソッド</a></li>
</ul>
</li>
<li><a class="reference internal" href="#blank">空白の識別子</a><ul>
<li><a class="reference internal" href="#the-blank-identifier-in-multiple-assignment">The blank identifier in multiple assignment</a></li>
<li><a class="reference internal" href="#unused-imports-and-variables">Unused imports and variables</a></li>
<li><a class="reference internal" href="#import-for-side-effect">Import for side effect</a></li>
<li><a class="reference internal" href="#interface-checks">Interface checks</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id39">埋め込み</a></li>
<li><a class="reference internal" href="#id40">並行処理</a><ul>
<li><a class="reference internal" href="#sharing">通信による共有</a></li>
<li><a class="reference internal" href="#id42">ゴルーチン</a></li>
<li><a class="reference internal" href="#id43">チャンネル</a></li>
<li><a class="reference internal" href="#channels-of-channels">Channels of channels</a></li>
<li><a class="reference internal" href="#parallelization">Parallelization</a></li>
<li><a class="reference internal" href="#a-leaky-buffer">A leaky buffer</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id44">エラー</a><ul>
<li><a class="reference internal" href="#panic">Panic</a></li>
<li><a class="reference internal" href="#recover">Recover</a></li>
</ul>
</li>
<li><a class="reference internal" href="#web">Webサーバー</a></li>
</ul>
</li>
</ul>

  <h4>前のトピックへ</h4>
  <p class="topless"><a href="../index.html"
                        title="前の章へ">Effective Go</a></p>
  <div role="note" aria-label="source link">
    <h3>このページ</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/documents/effective_go_ja.rst.txt"
            rel="nofollow">ソースコードを表示</a></li>
    </ul>
   </div><div>
    <h4>Page Info</h4>
    <p>
        <ul>
            <li>英数記号: 56705</li>
            <li>非アスキー: 9336</li>
            <li>合計文字数: 66041</li>
            <li>半角換算: 75377</li>
            <li>全角換算: 37688.5</li>
        </ul>
    </p>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">クイック検索</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="検索" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             >索引</a></li>
        <li class="right" >
          <a href="../index.html" title="Effective Go"
             >前へ</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">Effective Go  ドキュメント</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2020, d-tsuji.
      このドキュメントは <a href="http://sphinx-doc.org/">Sphinx</a> 2.3.1 で生成しました。
    </div>
  </body>
</html>