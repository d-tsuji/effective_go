
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="ja">
  <head>
    <meta charset="utf-8" />
    <title>Effective Go &#8212; Effective Go  ドキュメント</title>
    <link rel="stylesheet" href="../_static/traditional.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <script src="../_static/translations.js"></script>
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="検索" href="../search.html" />
    <link rel="prev" title="Effective Go" href="../index.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../index.html" title="Effective Go"
             accesskey="P">前へ</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">Effective Go  ドキュメント</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="effective-go">
<h1>Effective Go<a class="headerlink" href="#effective-go" title="このヘッドラインへのパーマリンク">¶</a></h1>
<div class="section" id="id1">
<h2>イントロダクション<a class="headerlink" href="#id1" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Goは新しい言語です。既存の言語からアイデアを借りていますが、その言語の特徴で書かれたプログラムとは異なる、Goのプログラムを効果的にする興味深い特徴を持っています。C++やJavaで書かれたプログラムをそのままGoに移植しても、満足な結果は得られないでしょう。JavaのプログラムはGoではなく、Javaで書かれます。一方、Goの特徴を用いると、元のプログラムとは全く異なりますが、良いものが生まれるかもしれません。Goを適切に書くのは、その特徴とイディオムを理解することが重要です。そして、他のGoプログラマーが理解しやすいように、命名規則やフォーマット、プログラムの構成といったGoの慣習を知ることも重要です。</p>
<p>このドキュメントは明確で慣用的なGoのコードを書くためのヒントを示します。<a class="reference external" href="https://golang.org/ref/spec">言語仕様</a> や <a class="reference external" href="https://tour.golang.org/">Tour of Go</a> や <a class="reference external" href="https://golang.org/doc/code.html">How to Write Go Code</a> を補強するもので、最初に読むべきものです。</p>
<div class="section" id="id3">
<h3>例<a class="headerlink" href="#id3" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Go本体のパッケージのソースはコアライブラリとしてだけではなく、Goをどのように扱うかというサンプルでもあります。さらに、多くのパッケージでは <a class="reference external" href="//golang.org">golang.org</a> から直接実行できる、動作する自己完結型の実行可能サンプルが含まれています。 <a class="reference external" href="//golang.org/pkg/strings/#example_Map">この</a> ようなものです。必要に応じて &quot;Example&quot; のボタンを押すと開きます。問題へのアプローチ方法や実装方法について質問がある場合は、ライブラリのドキュメントやコード、サンプルから回答やアイデア、背景を知ることができるでしょう。</p>
</div>
</div>
<div class="section" id="id5">
<h2>フォーマット<a class="headerlink" href="#id5" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>フォーマッティングは最も議論の多い問題ですが、それほど重要な問題ではありません。開発者はさまざまなフォーマッティングスタイルに適応できますが、同じスタイルを守っている場合は、この話題に費やす時間を短縮できます。問題は、長い規範的なスタイルガイドを用いずにこのユートピアにアプローチする方法です。</p>
<p>Goでは、通常とは異なるアプローチを採用し、ほとんどのフォーマットの問題をマシンに任せます。<strong>gofmt</strong> プログラム(ソースファイルレベルではなくパッケージレベルで動作する <strong>go fmt</strong> としても利用可能)は、Goプログラムを読み取り、標準スタイルのインデントと垂直方向の配置でソースを出力し、コメントを保持し、必要に応じて再フォーマットします。 新しいレイアウトの状況を処理する方法を知りたい場合は、 <strong>gofmt</strong> を実行します。 答えが正しくないと思われる場合は、プログラムを再配置(またはgofmtに関するバグを報告)してください。そのまま使わないでください。</p>
<p>例として、構造体のフィールドにコメントを並べるのに時間を費やす必要はありません。 Gofmtがそれを行います。以下に示します。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">T</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">name</span> <span class="kt">string</span> <span class="c1">// name of the object</span>
    <span class="nx">value</span> <span class="kt">int</span> <span class="c1">// its value</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong>gofmt</strong> カラムをフォーマットします:</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">T</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">name</span>    <span class="kt">string</span> <span class="c1">// name of the object</span>
    <span class="nx">value</span>   <span class="kt">int</span>    <span class="c1">// its value</span>
<span class="p">}</span>
</pre></div>
</div>
<p>標準パッケージのすべてのGoのコードは <strong>gofmt</strong> でフォーマットされています。</p>
<p>その他の書式設定の詳細が残っています。 簡潔に説明します。</p>
<dl class="simple">
<dt>インデント</dt><dd><p>インデントにタブを使用し <strong>gofmt</strong> はデフォルトでタブを出力します。必要な場合にのみスペースを使用してください。</p>
</dd>
<dt>行の長さ</dt><dd><p>Goには行の長さの制限はありません。パンチされたカードがあふれる心配はありません。行が長すぎると感じる場合は、それを折り返し、追加のタブでインデントします。</p>
</dd>
<dt>括弧</dt><dd><p>Goでは、CやJavaよりも括弧が少なくてすみます。制御構造( <strong>if</strong>, <strong>for</strong>, <strong>switch</strong> )の構文に括弧がありません。また、演算子の優先順位の階層は短く明確です。</p>
</dd>
</dl>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">x</span><span class="o">&lt;&lt;</span><span class="mi">8</span> <span class="o">+</span> <span class="nx">y</span><span class="o">&lt;&lt;</span><span class="mi">16</span>
</pre></div>
</div>
<p>他の言語とは異なり、スペースが意味することを意味します。</p>
</div>
<div class="section" id="id6">
<h2>コメント<a class="headerlink" href="#id6" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Goは、Cスタイルの <code class="docutils literal notranslate"><span class="pre">/*</span> <span class="pre">*/</span></code> のブロックコメントとC++スタイルの <code class="docutils literal notranslate"><span class="pre">//</span></code> 行コメントを提供します。行コメントは標準です。ブロックコメントは、ほとんどがパッケージコメントとして用いられますが、式の中や大量のコードを無効にするのに役立ちます。</p>
<p><strong>godoc</strong> と呼ばれるプログラム(およびWebサーバー)は、Goソースファイルを解析して、パッケージの内容に関するドキュメントを抽出します。 トップレベルの宣言の前に表示され、改行を挿入しないコメントは、宣言とともにその項目の説明文となります。 これらのコメントの性質とスタイルは <strong>godoc</strong> が作成するドキュメントの質を決定します。</p>
<p>すべてのパッケージには、パッケージコメント、パッケージ句の前のブロックコメントが必要です。 複数ファイルで構成されるパッケージの場合、パッケージコメントは1つのファイルにあれば十分です。パッケージコメントは、パッケージを紹介し、パッケージ全体に関連する情報を提供する必要があります。 godocページの最初に表示され、詳細なドキュメントに続くように設定する必要があります。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm">Package regexp implements a simple library for regular expressions.</span>

<span class="cm">The syntax of the regular expressions accepted is:</span>

<span class="cm">    regexp:</span>
<span class="cm">        concatenation { &#39;|&#39; concatenation }</span>
<span class="cm">    concatenation:</span>
<span class="cm">        { closure }</span>
<span class="cm">    closure:</span>
<span class="cm">        term [ &#39;*&#39; | &#39;+&#39; | &#39;?&#39; ]</span>
<span class="cm">    term:</span>
<span class="cm">        &#39;^&#39;</span>
<span class="cm">        &#39;$&#39;</span>
<span class="cm">        &#39;.&#39;</span>
<span class="cm">        character</span>
<span class="cm">        &#39;[&#39; [ &#39;^&#39; ] character-ranges &#39;]&#39;</span>
<span class="cm">        &#39;(&#39; regexp &#39;)&#39;</span>
<span class="cm">*/</span>
<span class="kn">package</span> <span class="nx">regexp</span>
</pre></div>
</div>
<p>パッケージが単純な場合、パッケージのコメントは簡潔にすることができます。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// Package path implements utility routines for</span>
<span class="c1">// manipulating slash-separated filename paths.</span>
</pre></div>
</div>
<p>コメントには、アスタリスクのバナーなどの追加の書式設定は必要ありません。生成された出力は固定幅のフォントで表示されないかもしれないので、配置の間隔に依存しないでください。 <strong>godoc</strong> は <strong>gofmt</strong> のように面倒を見てくれます。コメントはインタプリタに解釈されないプレーンテキストであるため、HTMLやその他の注釈(_this_など)はそのまま表示されるため、使用しないでください。 <strong>godoc</strong> が行う調整の1つは、プログラムスニペットに適した固定幅フォントでインデントされたテキストを表示することです。 <a class="reference external" href="https://golang.org/pkg/fmt/">fmt package</a> のパッケージコメントは、これを有効に使用しています。</p>
<p>コンテキストによっては <strong>godoc</strong> はコメントを再フォーマットすることすらできない場合があるため、正しいスペル、句読点、文構造を使用する、長い行を折り畳むなど、コメントがまっすぐに見えるようにしてください。</p>
<p>パッケージ内では、最上位の宣言の直前のコメントは、その宣言のドキュメントコメントとして機能します。プログラム内のエクスポートされた(大文字の)名前にはすべて、ドキュメンテーションコメントが必要です。</p>
<p>ドキュメントコメントは完全な文として最適に機能し、さまざまな自動プレゼンテーションを可能にします。最初の文は、宣言される名前で始まる1行の要約でなければなりません。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// Compile parses a regular expression and returns, if successful,</span>
<span class="c1">// a Regexp that can be used to match against text.</span>
<span class="kd">func</span> <span class="nx">Compile</span><span class="p">(</span><span class="nx">str</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">Regexp</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</pre></div>
</div>
<p>すべてのdocコメントが説明する項目の名前で始まる場合、goツールのdocサブコマンドを使用して、grepを介して出力を実行できます。 「Compile」という名前を思い出せなかったが、正規表現の解析関数を探していたので、コマンドを実行したとします。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span>$ go doc -all regexp | grep -i parse
</pre></div>
</div>
<p>パッケージ内のすべてのドキュメントコメントが「This function ...」で始まった場合、grepは名前を検索することには役に立ちません。しかし、パッケージは各docコメントを名前で開始するため、このようなものが表示され、探している単語が思い出されます。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span>$ go doc -all regexp | grep -i parse
    Compile parses a regular expression and returns, if successful, a Regexp
    MustCompile is like Compile but panics if the expression cannot be parsed.
    parsed. It simplifies safe initialization of global variables holding
$
</pre></div>
</div>
<p>Goの宣言構文では、宣言をグループ化できます。単一のdocコメントで、関連する定数または変数のグループを紹介できます。宣言全体が提示されているため、このようなコメントはしばしばおかしなものになります。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// Error codes returned by failures to parse an expression.</span>
<span class="kd">var</span> <span class="p">(</span>
    <span class="nx">ErrInternal</span>      <span class="p">=</span> <span class="nx">errors</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="s">&quot;regexp: internal error&quot;</span><span class="p">)</span>
    <span class="nx">ErrUnmatchedLpar</span> <span class="p">=</span> <span class="nx">errors</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="s">&quot;regexp: unmatched &#39;(&#39;&quot;</span><span class="p">)</span>
    <span class="nx">ErrUnmatchedRpar</span> <span class="p">=</span> <span class="nx">errors</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="s">&quot;regexp: unmatched &#39;)&#39;&quot;</span><span class="p">)</span>
    <span class="o">...</span>
<span class="p">)</span>
</pre></div>
</div>
<p>グループ化は、変数のセットがミューテックスによって保護されているという事実など、項目の関係を示すこともできます。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="p">(</span>
    <span class="nx">countLock</span>   <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>
    <span class="nx">inputCount</span>  <span class="kt">uint32</span>
    <span class="nx">outputCount</span> <span class="kt">uint32</span>
    <span class="nx">errorCount</span>  <span class="kt">uint32</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id7">
<h2>命名<a class="headerlink" href="#id7" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>命名は他の言語と同様にGoでも重要です。セマンティックな効果もあります。外部パッケージから参照可視性は、その最小の文字が大文字かどうかで決まります。したがって、Goプログラムの命名規則について少し話をする価値があります。</p>
<div class="section" id="id8">
<h3>パッケージ名<a class="headerlink" href="#id8" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>パッケージがインポートされるとき、パッケージ名がコンテンツのアクセッサーになります。</p>
<p>以下のように</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="s">&quot;bytes&quot;</span>
</pre></div>
</div>
<p>とパッケージをインポートすると、 <strong>bytes.Buffer</strong> としてパッケージを使うことができます。パッケージを使う人が同じ名前でパッケージのコンテンツを参照すると便利です。これはパッケージ名が適切であることを意味します。短く完結で分かりやすくあるべきです。慣例としてパッケージ名は小文字の単一の単語名にします。アンダースコアやmixedCapsである必要はありません。多くの人がパッケージ名を打ち込むことを考えて、簡潔すぎるほど簡潔にしてしまう場合があります。その場合でも衝突を心配する必要はありません。パッケージ名はインポートするときのデフォルトでしかないからです。ソースコード全体で唯一である必要はありません。衝突するようなまれな場合、インポートするパッケージ名に異なる名前をつけることができます。どのような場合でも、インポート機能においてファイル名がどのパッケージで使用されるかを決めるので、混乱することはまれです。別の慣例として、パッケージ名はソースディレクトリの名前であるこということです。 <strong>src/encoding/base64</strong> にあるパッケージは <strong>&quot;encoding/base64&quot;</strong> としてインポートされます。名前は <strong>base64</strong> であって、 <strong>encoding_base64</strong> でも <strong>encodingBase64</strong> でもありません。</p>
<p>パッケージのインポートするときはパッケージ名を使用してそのコンテンツを参照します。 <strong>import .</strong> という表記をしないでください。パッケージの外部でテストを動かくときに簡素化できますが、そうでない場合は避けてください。)たとえば <strong>bufio</strong> パッケージのバッフ付きのReaderはBufReaderではなくReaderと呼ばれます。これは、ユーザーが <strong>bufio.Reader</strong> という明確で簡潔な名前として表示するためです。さらに、インポートされた要素は常にパッケージ名でアドレス指定されるため、bufio.Readerはio.Readerと競合しません。同様に、ring.Ringの新しいインスタンスを作成するコンストラクターは通常、NewRingとなりますが、Ringはパッケージによってエクスポートされる唯一のタイプであり、パッケージはringであることから <strong>New</strong> となります。パッケージのクライアントはring.Newと使用します。適切な名前を選択するには、パッケージ構造を使用してください。</p>
<p>もう1つの短い例は <strong>once.Do</strong> です。once.Do(setup)は読みやすく、 <strong>once.DoOrWaitUntilDone(setup)</strong> としても読みやすくはなりません。長い命名は可読性に役に立ちません。長い命名をするとよりも、ドキュメンテーションコメントは、充実されるほうが価値がある場合がよくあります。</p>
</div>
<div class="section" id="id9">
<h3>ゲッター<a class="headerlink" href="#id9" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Goはgetterおよびsetterの自動サポートする機能はありません。getterとsetterを記述することは何の問題もありません。そうすることはしばしば適切ですが、 <strong>Get</strong> をゲッターの名前に入れることは慣用的でもないし、必要でもありません。 owner(小文字、エクスポートされていない)というフィールドがある場合、getterメソッドはGetOwnerではなくOwner(大文字、エクスポートされている)と呼ばれる必要があります。 エクスポートに大文字の名前を使用すると、フィールドをメソッドから区別することができます。必要に応じて、setter関数はSetOwnerと呼ばれます。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">owner</span> <span class="o">:=</span> <span class="nx">obj</span><span class="p">.</span><span class="nx">Owner</span><span class="p">()</span>
<span class="k">if</span> <span class="nx">owner</span> <span class="o">!=</span> <span class="nx">user</span> <span class="p">{</span>
    <span class="nx">obj</span><span class="p">.</span><span class="nx">SetOwner</span><span class="p">(</span><span class="nx">user</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id10">
<h3>インターフェース名<a class="headerlink" href="#id10" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>慣例により、1つのメソッドのみを持つインターフェイスには、メソッド名やフィールド名に <code class="docutils literal notranslate"><span class="pre">-er</span></code> という接尾辞(Reader、Writer、Formatter、CloseNotifierなど)を付けた名前が付けられます。</p>
<p>そのような名前は多数あり、それらとそれらが意味する関数名を尊重することは生産的です。 Read、Write、Close、Flush、Stringなどには、標準的なシグネチャと意味があります。混乱を避けるために、同じシグネチャと意味を持たない限り、メソッドにこれらの名前の1つを与えないでください。 逆に、型が既知の型のメソッドと同じ意味を持つメソッドを実装する場合、同じ名前とシグネチャを付けます。文字列に変換するメソッドは ToString ではなく String() を呼び出します。</p>
</div>
<div class="section" id="mixedcaps">
<h3>MixedCaps<a class="headerlink" href="#mixedcaps" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>最後に、Goの慣例では、複数の単語を含むとき、アンダースコアではなく <strong>MixedCaps</strong> または <strong>mixedCaps</strong> を使用します。</p>
</div>
</div>
<div class="section" id="id11">
<h2>セミコロン<a class="headerlink" href="#id11" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Cのように、Goの形式的な文法ではセミコロンを使用してステートメントを終了しますが、Cとは異なり、これらのセミコロンはソースには表れません。代わりに、字句解析器が単純なルールを使用して解析時にセミコロンを自動的に挿入するため、ソースコードにはほとんどセミコロンが含まれていません。</p>
<p>ルールは以下です。改行の直前のトークンが識別子(intやfloat64などの単語を含む)の場合、数値や文字列定数などの基本的なリテラル、または以下のトークンの1つであるとき、字句解析器は常にトークンの後にセミコロンを挿入します。これは、「改行がステートメントを終了できるトークンの後に来る場合、セミコロンを挿入する」と要約できます。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="k">break</span> <span class="k">continue</span> <span class="k">fallthrough</span> <span class="k">return</span> <span class="o">++</span> <span class="o">--</span> <span class="p">)</span> <span class="p">}</span>
</pre></div>
</div>
<p>セミコロンは右中括弧の直前でも省略できるため、次のようなステートメントはセミコロンは不要です。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="k">for</span> <span class="p">{</span> <span class="nx">dst</span> <span class="o">&lt;-</span> <span class="o">&lt;-</span><span class="nx">src</span> <span class="p">}</span> <span class="p">}()</span>
</pre></div>
</div>
<p>慣例的にGoのプログラムには、forループ句中の初期化要素、条件要素、および継続要素を分離する場所にのみセミコロンがあります。また、コードをそのように記述する場合、1行で複数のステートメントを分離するためにも必要です。</p>
<p>セミコロン挿入ルールの結果の1つは、次の行に(if, for, switch, selectの)制御構造を開始する左中括弧を配置できないことです。挿入すると、括弧の前にセミコロンが挿入され、望ましくない効果が生じる可能性があります。 次のように記述してください。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">f</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">g</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>
</div>
<p>以下のように書いてはいけません。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">f</span><span class="p">()</span>  <span class="c1">// wrong!</span>
<span class="p">{</span>           <span class="c1">// wrong!</span>
    <span class="nx">g</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="control-structures">
<h2>制御構造(Control structures)<a class="headerlink" href="#control-structures" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Goの制御構造はCの制御構造に似ていますが、重要な点で異なります。 <strong>do</strong> ループや <strong>while</strong> ループはありません。 <strong>for</strong> 句としてわずかに一般化されています。 <strong>switch</strong> はより柔軟です。 <strong>if</strong> および <strong>switch</strong> は、forのようなオプションの初期化ステートメントを受け入れます。breakおよびcontinueステートメントは、中断または続行するものを識別するオプションのラベルを取ります。 また、型 <code class="docutils literal notranslate"><span class="pre">switch</span></code> や多様な通信のマルチプレクサである <strong>select</strong> などの新しい制御構造があります。 構文もわずかに異なります。括弧はなく、本文は常に中括弧で区切る必要があります。</p>
<div class="section" id="if">
<h3>If<a class="headerlink" href="#if" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Goでは <strong>if</strong> はシンプルです。以下を見てください。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="nx">x</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">y</span>
<span class="p">}</span>
</pre></div>
</div>
<p>必須の中括弧は、複数の行に単純なifステートメントを書くことを奨励します。とにかくそうするのは良いスタイルです。特に、本文にreturnやbreakなどの制御ステートメントが含まれている場合はそうです。</p>
<p><strong>if</strong> および <strong>switch</strong> は初期化ステートメントを受け入れるため、ローカル変数のセットアップに使用されるステートメントで参照するが一般的です。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">file</span><span class="p">.</span><span class="nx">Chmod</span><span class="p">(</span><span class="mo">0664</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nx">Print</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">err</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Goライブラリでは、ifステートメントが次のステートメントに流れない場合(つまり、本文がbreak、continue、goto、またはreturnで終了する場合)、不要なelseが省略されることがわかります。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">f</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Open</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">err</span>
<span class="p">}</span>
<span class="nx">codeUsing</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span>
</pre></div>
</div>
<p>これは、よくある一連のエラー判定をするようなケースです。処理が成功と判断されたときは、エラー処理はスキップし、処理が下方へと流れていくので読みやすいコードとなっています。エラーケースはreturnステートメントで終わることが多いため、elseステートメントは必要ありません。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">f</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Open</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">err</span>
<span class="p">}</span>
<span class="nx">d</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">f</span><span class="p">.</span><span class="nx">Stat</span><span class="p">()</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">f</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>
    <span class="k">return</span> <span class="nx">err</span>
<span class="p">}</span>
<span class="nx">codeUsing</span><span class="p">(</span><span class="nx">f</span><span class="p">,</span> <span class="nx">d</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="redeclaration">
<span id="id12"></span><h3>再宣言と再割り当て<a class="headerlink" href="#redeclaration" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>余談ですが、直前のセクションの最後の例は <code class="docutils literal notranslate"><span class="pre">:=</span></code> という短い宣言方法がどのように動作するか示しています。 <code class="docutils literal notranslate"><span class="pre">os.Open</span></code> は以下のように宣言していました。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">f</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Open</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span>
</pre></div>
</div>
<p>このステートメントは、fとerrという2つの変数を宣言します。数行後、以下のf.Statの呼び出しは</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">d</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">f</span><span class="p">.</span><span class="nx">Stat</span><span class="p">()</span>
</pre></div>
</div>
<p>dとerrを宣言しています。両方のステートメントに <code class="docutils literal notranslate"><span class="pre">err</span></code> があることに注意してください。このように変数を割り当てることは問題ありません。<code class="docutils literal notranslate"><span class="pre">err</span></code> は最初のステートメントで宣言されますが、2番目のステートメントでは再割り当てがされます。つまり <code class="docutils literal notranslate"><span class="pre">f.Stat</span></code> の呼び出しは、上記で宣言された既存の <code class="docutils literal notranslate"><span class="pre">err</span></code> 変数を使用し、新しい値を与えるだけです。</p>
<p><code class="docutils literal notranslate"><span class="pre">:=</span></code> という宣言では、変数vが既に宣言されている場合でも表示されます。ただし、</p>
<ul class="simple">
<li><p>この宣言は、vと同じスコープ内に宣言されています(vが外部スコープで既に宣言されている場合、新しい変数を作成します)。</p></li>
<li><p>初期化の対応する値はvに割り当て可能(な型)である必要があります。</p></li>
<li><p>新たに宣言されている変数に少なくとも1つの他の新しい変数があります。</p></li>
</ul>
<p>この珍しい特徴は実用的です。たとえば長いif-else句で単一のerr値を使用できます。よく見かけるでしょう。</p>
<p>Goでは、関数のパラメーターと戻り値のスコープは中括弧の外側で記述されますが、関数の記述と同じスコープであることに注意してください。</p>
</div>
<div class="section" id="for">
<h3>For<a class="headerlink" href="#for" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>GoのforループはCに似ていますが、同じではありません。Go言語のforループは、C言語のforとwhileループを兼ねていますが、do-whileループに相当するものはありません。forループには3つの形式がありますが、セミコロンを使うのはそのうちひとつだけです。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// Like a C for</span>
<span class="k">for</span> <span class="nx">init</span><span class="p">;</span> <span class="nx">condition</span><span class="p">;</span> <span class="nx">post</span> <span class="p">{</span> <span class="p">}</span>

<span class="c1">// Like a C while</span>
<span class="k">for</span> <span class="nx">condition</span> <span class="p">{</span> <span class="p">}</span>

<span class="c1">// Like a C for(;;)</span>
<span class="k">for</span> <span class="p">{</span> <span class="p">}</span>
</pre></div>
</div>
<p>短い宣言により、ループ内で用いるインデックス変数を簡単に宣言できます。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">sum</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
    <span class="nx">sum</span> <span class="o">+=</span> <span class="nx">i</span>
<span class="p">}</span>
</pre></div>
</div>
<p>配列、スライス、文字列、またはマップをループしている場合、またはチャンネルから読み込んでいる場合 <code class="docutils literal notranslate"><span class="pre">range</span></code> 句でループを管理できます。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">value</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">oldMap</span> <span class="p">{</span>
    <span class="nx">newMap</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="p">=</span> <span class="nx">value</span>
<span class="p">}</span>
</pre></div>
</div>
<p>範囲内の最初の項目(キーまたはインデックス)のみが必要な場合は、2番目の項目を削除します。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="nx">key</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">m</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">key</span><span class="p">.</span><span class="nx">expired</span><span class="p">()</span> <span class="p">{</span>
        <span class="nb">delete</span><span class="p">(</span><span class="nx">m</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>範囲内の2番目の項目(値)のみが必要な場合は、空白識別子であるアンダースコアを使用して、最初の項目を破棄します。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">sum</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">value</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">array</span> <span class="p">{</span>
    <span class="nx">sum</span> <span class="o">+=</span> <span class="nx">value</span>
<span class="p">}</span>
</pre></div>
</div>
<p><a class="reference external" href="#blank">ブランク識別子</a> には、後のセクションで説明するように、多くの用途があります。</p>
<p>文字列を扱うときの <code class="docutils literal notranslate"><span class="pre">range</span></code> はより高機能で、UTF-8をパースすることで各文字のユニコードのコードポイントを取り出します。誤ったエンコーディングは1バイトを消費し、置換ルーン <code class="docutils literal notranslate"><span class="pre">U+FFFD</span></code> を生成します。Goの組み込み型である <strong>rune</strong> は単一のユニコードのコードポイントを示すGoの用語です。詳細については、言語仕様を参照してください。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="nx">pos</span><span class="p">,</span> <span class="nx">char</span> <span class="o">:=</span> <span class="k">range</span> <span class="s">&quot;日本\x80語&quot;</span> <span class="p">{</span> <span class="c1">// \x80 is an illegal UTF-8 encoding</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;character %#U starts at byte position %d\n&quot;</span><span class="p">,</span> <span class="nx">char</span><span class="p">,</span> <span class="nx">pos</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>以下のように表示します。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">character</span> <span class="nx">U</span><span class="o">+</span><span class="mf">65E5</span> <span class="sc">&#39;日&#39;</span> <span class="nx">starts</span> <span class="nx">at</span> <span class="kt">byte</span> <span class="nx">position</span> <span class="mi">0</span>
<span class="nx">character</span> <span class="nx">U</span><span class="o">+</span><span class="mi">672</span><span class="nx">C</span> <span class="sc">&#39;本&#39;</span> <span class="nx">starts</span> <span class="nx">at</span> <span class="kt">byte</span> <span class="nx">position</span> <span class="mi">3</span>
<span class="nx">character</span> <span class="nx">U</span><span class="o">+</span><span class="nx">FFFD</span> <span class="sc">&#39;�&#39;</span> <span class="nx">starts</span> <span class="nx">at</span> <span class="kt">byte</span> <span class="nx">position</span> <span class="mi">6</span>
<span class="nx">character</span> <span class="nx">U</span><span class="o">+</span><span class="mi">8</span><span class="nx">A9E</span> <span class="sc">&#39;語&#39;</span> <span class="nx">starts</span> <span class="nx">at</span> <span class="kt">byte</span> <span class="nx">position</span> <span class="mi">7</span>
</pre></div>
</div>
<p>最後に、Goにはコンマ演算子がなく、 <code class="docutils literal notranslate"><span class="pre">++</span></code> および <code class="docutils literal notranslate"><span class="pre">--</span></code> は式ではなくステートメントです。したがって、forで複数の変数を実行する場合は、並列代入を使用する必要があります（ただし、++および--は除外されます）。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// Reverse a</span>
<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">j</span><span class="p">;</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="p">=</span> <span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nx">j</span><span class="o">-</span><span class="mi">1</span> <span class="p">{</span>
    <span class="nx">a</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">a</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">a</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span> <span class="nx">a</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="switch">
<h3>Switch<a class="headerlink" href="#switch" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Goの <code class="docutils literal notranslate"><span class="pre">switch</span></code> はCの <code class="docutils literal notranslate"><span class="pre">switch</span></code> よりも一般的です。式は定数または整数である必要はなく、一致するものが見つかるまでケースは上から下に評価していきます。 <code class="docutils literal notranslate"><span class="pre">switch</span></code> に式がない場合はtrueとなるケースにマッチします。したがって、if-else-if-elseチェーンを <code class="docutils literal notranslate"><span class="pre">switch</span></code> として記述することができます。そして慣用的な書き方です。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">unhex</span><span class="p">(</span><span class="nx">c</span> <span class="kt">byte</span><span class="p">)</span> <span class="kt">byte</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="p">{</span>
    <span class="k">case</span> <span class="sc">&#39;0&#39;</span> <span class="o">&lt;=</span> <span class="nx">c</span> <span class="o">&amp;&amp;</span> <span class="nx">c</span> <span class="o">&lt;=</span> <span class="sc">&#39;9&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="nx">c</span> <span class="o">-</span> <span class="sc">&#39;0&#39;</span>
    <span class="k">case</span> <span class="sc">&#39;a&#39;</span> <span class="o">&lt;=</span> <span class="nx">c</span> <span class="o">&amp;&amp;</span> <span class="nx">c</span> <span class="o">&lt;=</span> <span class="sc">&#39;f&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="nx">c</span> <span class="o">-</span> <span class="sc">&#39;a&#39;</span> <span class="o">+</span> <span class="mi">10</span>
    <span class="k">case</span> <span class="sc">&#39;A&#39;</span> <span class="o">&lt;=</span> <span class="nx">c</span> <span class="o">&amp;&amp;</span> <span class="nx">c</span> <span class="o">&lt;=</span> <span class="sc">&#39;F&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="nx">c</span> <span class="o">-</span> <span class="sc">&#39;A&#39;</span> <span class="o">+</span> <span class="mi">10</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span>
<span class="p">}</span>
</pre></div>
</div>
<p>自動フォールスルーはありませんが、コンマ区切りのリストで複数のケースを示すことができます。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">shouldEscape</span><span class="p">(</span><span class="nx">c</span> <span class="kt">byte</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="nx">c</span> <span class="p">{</span>
    <span class="k">case</span> <span class="sc">&#39; &#39;</span><span class="p">,</span> <span class="sc">&#39;?&#39;</span><span class="p">,</span> <span class="sc">&#39;&amp;&#39;</span><span class="p">,</span> <span class="sc">&#39;=&#39;</span><span class="p">,</span> <span class="sc">&#39;#&#39;</span><span class="p">,</span> <span class="sc">&#39;+&#39;</span><span class="p">,</span> <span class="sc">&#39;%&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">true</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="kc">false</span>
<span class="p">}</span>
</pre></div>
</div>
<p>breakステートメントを使用してスイッチを早期に終了できます。ただし、Goでは他のCライクな言語ほど一般的ではありません。場合によっては、 <code class="docutils literal notranslate"><span class="pre">switch</span></code> を用いずに周辺のループから抜け出す必要があります。Goでは、ループにラベルを付けて、そのラベルを <code class="docutils literal notranslate"><span class="pre">break</span></code> することで実現できます。 以下の例は、両方の使用法を示しています。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">Loop</span><span class="p">:</span>
    <span class="k">for</span> <span class="nx">n</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">n</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">src</span><span class="p">);</span> <span class="nx">n</span> <span class="o">+=</span> <span class="nx">size</span> <span class="p">{</span>
        <span class="k">switch</span> <span class="p">{</span>
        <span class="k">case</span> <span class="nx">src</span><span class="p">[</span><span class="nx">n</span><span class="p">]</span> <span class="p">&lt;</span> <span class="nx">sizeOne</span><span class="p">:</span>
            <span class="k">if</span> <span class="nx">validateOnly</span> <span class="p">{</span>
                <span class="k">break</span>
            <span class="p">}</span>
            <span class="nx">size</span> <span class="p">=</span> <span class="mi">1</span>
            <span class="nx">update</span><span class="p">(</span><span class="nx">src</span><span class="p">[</span><span class="nx">n</span><span class="p">])</span>

        <span class="k">case</span> <span class="nx">src</span><span class="p">[</span><span class="nx">n</span><span class="p">]</span> <span class="p">&lt;</span> <span class="nx">sizeTwo</span><span class="p">:</span>
            <span class="k">if</span> <span class="nx">n</span><span class="o">+</span><span class="mi">1</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">src</span><span class="p">)</span> <span class="p">{</span>
                <span class="nx">err</span> <span class="p">=</span> <span class="nx">errShortInput</span>
                <span class="k">break</span> <span class="nx">Loop</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="nx">validateOnly</span> <span class="p">{</span>
                <span class="k">break</span>
            <span class="p">}</span>
            <span class="nx">size</span> <span class="p">=</span> <span class="mi">2</span>
            <span class="nx">update</span><span class="p">(</span><span class="nx">src</span><span class="p">[</span><span class="nx">n</span><span class="p">]</span> <span class="o">+</span> <span class="nx">src</span><span class="p">[</span><span class="nx">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="nx">shift</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
</pre></div>
</div>
<p>もちろん <code class="docutils literal notranslate"><span class="pre">continue</span></code> ステートメントはオプションのラベルも受け入れますが、ループにのみ適用されます。</p>
<p>最後に、2つの <code class="docutils literal notranslate"><span class="pre">switch</span></code> ステートメントを使用するバイトスライスの比較ルーチンを次に示します。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// Compare returns an integer comparing the two byte slices,</span>
<span class="c1">// lexicographically.</span>
<span class="c1">// The result will be 0 if a == b, -1 if a &lt; b, and +1 if a &gt; b</span>
<span class="kd">func</span> <span class="nx">Compare</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">b</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="k">switch</span> <span class="p">{</span>
        <span class="k">case</span> <span class="nx">a</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">&gt;</span> <span class="nx">b</span><span class="p">[</span><span class="nx">i</span><span class="p">]:</span>
            <span class="k">return</span> <span class="mi">1</span>
        <span class="k">case</span> <span class="nx">a</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">&lt;</span> <span class="nx">b</span><span class="p">[</span><span class="nx">i</span><span class="p">]:</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">switch</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nb">len</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="p">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">b</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="k">case</span> <span class="nb">len</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">b</span><span class="p">):</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="type-switch">
<span id="id14"></span><h3>型の switch<a class="headerlink" href="#type-switch" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">switch</span></code> を使用して、インターフェイス変数の動的な型を検出することもできます。 このような型 <code class="docutils literal notranslate"><span class="pre">switch</span></code> は、カッコ内にキーワードタイプを持つ型アサーションの構文を使用します。 <code class="docutils literal notranslate"><span class="pre">switch</span></code> が式で変数を宣言する場合、変数は各句で対応する型を持ちます。また、このような場合に名前を再利用することも慣習的であり、事実上、それぞれの場合に同じ名前で異なる型の新しい変数を宣言します。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">t</span> <span class="kd">interface</span><span class="p">{}</span>
<span class="nx">t</span> <span class="p">=</span> <span class="nx">functionOfSomeType</span><span class="p">()</span>
<span class="k">switch</span> <span class="nx">t</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.(</span><span class="kd">type</span><span class="p">)</span> <span class="p">{</span>
<span class="k">default</span><span class="p">:</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;unexpected type %T\n&quot;</span><span class="p">,</span> <span class="nx">t</span><span class="p">)</span>     <span class="c1">// %T prints whatever type t has</span>
<span class="k">case</span> <span class="kt">bool</span><span class="p">:</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;boolean %t\n&quot;</span><span class="p">,</span> <span class="nx">t</span><span class="p">)</span>             <span class="c1">// t has type bool</span>
<span class="k">case</span> <span class="kt">int</span><span class="p">:</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;integer %d\n&quot;</span><span class="p">,</span> <span class="nx">t</span><span class="p">)</span>             <span class="c1">// t has type int</span>
<span class="k">case</span> <span class="o">*</span><span class="kt">bool</span><span class="p">:</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;pointer to boolean %t\n&quot;</span><span class="p">,</span> <span class="o">*</span><span class="nx">t</span><span class="p">)</span> <span class="c1">// t has type *bool</span>
<span class="k">case</span> <span class="o">*</span><span class="kt">int</span><span class="p">:</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;pointer to integer %d\n&quot;</span><span class="p">,</span> <span class="o">*</span><span class="nx">t</span><span class="p">)</span> <span class="c1">// t has type *int</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id15">
<h2>関数<a class="headerlink" href="#id15" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="multiple-returns">
<span id="id16"></span><h3>複数の戻り値<a class="headerlink" href="#multiple-returns" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Goの珍しい機能の1つは、関数とメソッドが複数の値を返すことができることです。 この形式は、Cプログラムのいくつかの不格好なイディオムを改善するために使用できます。EOFに対して-1などの in-band エラーが返され、アドレスによって渡された引数を変更するといったものです。</p>
<p>Cでは、書き込みエラーは、負の数によって通知され、エラーコードは揮発性の場所に隠されてしまいます。Goでは Write はカウント数とエラーを同時に戻すことができます。エラーは「デバイスが一杯になったため、一部のバイト数は書き込めたが、全てを書き込むことはできませんでした」といったものです。os パッケージの <strong>Write</strong> メソッドのシグネチャは以下のものです。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="p">(</span><span class="nx">file</span> <span class="o">*</span><span class="nx">File</span><span class="p">)</span> <span class="nx">Write</span><span class="p">(</span><span class="nx">b</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
</pre></div>
</div>
<p>そして、ドキュメントのように、<code class="docutils literal notranslate"><span class="pre">n！=</span> <span class="pre">len(b)</span></code> の場合、書き込まれたバイト数と非nilエラーを返します。 これは一般的なスタイルです。 その他の例については、エラー処理のセクションを参照してください。</p>
<p>同様のアプローチにより、参照パラメーターをシミュレートするためにポインターを戻り値に渡す必要がなくなります。 バイトスライスの位置から数値を取得し、その数値と次の位置を返す単純な関数を次に示します。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">nextInt</span><span class="p">(</span><span class="nx">b</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">i</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">isDigit</span><span class="p">(</span><span class="nx">b</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
    <span class="p">}</span>
    <span class="nx">x</span> <span class="o">:=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">isDigit</span><span class="p">(</span><span class="nx">b</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="nx">x</span> <span class="p">=</span> <span class="nx">x</span><span class="o">*</span><span class="mi">10</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="nx">b</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span> <span class="o">-</span> <span class="sc">&#39;0&#39;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">i</span>
<span class="p">}</span>
</pre></div>
</div>
<p>これを使用して、次のように入力スライス <code class="docutils literal notranslate"><span class="pre">b</span></code> の数値をスキャンできます。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">b</span><span class="p">);</span> <span class="p">{</span>
    <span class="nx">x</span><span class="p">,</span> <span class="nx">i</span> <span class="p">=</span> <span class="nx">nextInt</span><span class="p">(</span><span class="nx">b</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id17">
<h3>名前付けされた戻り値<a class="headerlink" href="#id17" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Goの関数の戻り値は、入力パラメーターと同様に、名前を付けて通常の変数として使用できます。名前が付けられると、関数の開始時にそれらの型のゼロ値で初期化されます。 関数が引数なしでreturnステートメントを実行する場合、結果パラメーターの現在の値が戻り値として使用されます。</p>
<p>名前は必須ではありませんが、コードをより短く明確にすることができます。それらはドキュメントです。nextIntの返り値に名前を付けると、返されたintがどれであるかが明らかになります。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">nextInt</span><span class="p">(</span><span class="nx">b</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">pos</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="nx">value</span><span class="p">,</span> <span class="nx">nextPos</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</pre></div>
</div>
<p>名前付きの戻り値は初期化され、return ステートメントの戻り値に紐付いているため、単純化および明確化できます。これらをうまく使用するio.ReadFullのバージョンは次のとおりです。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">ReadFull</span><span class="p">(</span><span class="nx">r</span> <span class="nx">Reader</span><span class="p">,</span> <span class="nx">buf</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nb">len</span><span class="p">(</span><span class="nx">buf</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">nr</span> <span class="kt">int</span>
        <span class="nx">nr</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Read</span><span class="p">(</span><span class="nx">buf</span><span class="p">)</span>
        <span class="nx">n</span> <span class="o">+=</span> <span class="nx">nr</span>
        <span class="nx">buf</span> <span class="p">=</span> <span class="nx">buf</span><span class="p">[</span><span class="nx">nr</span><span class="p">:]</span>
    <span class="p">}</span>
    <span class="k">return</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="defer">
<h3>Defer<a class="headerlink" href="#defer" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Goの <strong>defer</strong> ステートメントは、deferを実行する関数が戻る直前に実行される関数呼び出し(遅延関数)をスケジュールします。 これは、関数がどのパスを返すかに関係なく解放する必要があるリソースなどの状況に対処するための、珍しい方法ですが、効果的な方法です。 標準的な例は、ミューテックスのロック解除またはファイルのクローズです。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// Contents returns the file&#39;s contents as a string.</span>
<span class="kd">func</span> <span class="nx">Contents</span><span class="p">(</span><span class="nx">filename</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">f</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Open</span><span class="p">(</span><span class="nx">filename</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="nx">err</span>
    <span class="p">}</span>
    <span class="k">defer</span> <span class="nx">f</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span>  <span class="c1">// f.Close will run when we&#39;re finished.</span>

    <span class="kd">var</span> <span class="nx">result</span> <span class="p">[]</span><span class="kt">byte</span>
    <span class="nx">buf</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
    <span class="k">for</span> <span class="p">{</span>
        <span class="nx">n</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">f</span><span class="p">.</span><span class="nx">Read</span><span class="p">(</span><span class="nx">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">:])</span>
        <span class="nx">result</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span> <span class="nx">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="nx">n</span><span class="p">]</span><span class="o">...</span><span class="p">)</span> <span class="c1">// append is discussed later.</span>
        <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">io</span><span class="p">.</span><span class="nx">EOF</span> <span class="p">{</span>
                <span class="k">break</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="nx">err</span>  <span class="c1">// f will be closed if we return here.</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">string</span><span class="p">(</span><span class="nx">result</span><span class="p">),</span> <span class="kc">nil</span> <span class="c1">// f will be closed if we return here.</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Closeなどの関数の呼び出しを遅延することには、2つの利点があります。 まず、ファイルを閉じることを決して忘れないことを保証します。これは、後で関数を編集して新しい戻りパスを追加する場合によくある間違いです。 2つ目にClose関数がOpen関数の近くにあることを意味します。これは、関数の最後に配置するよりもずっと明確です。</p>
<p>遅延関数(関数がメソッドの場合はレシーバーを含む)の引数は、関数呼び出しの実行時ではなく <code class="docutils literal notranslate"><span class="pre">defer</span></code> の実行時に評価されます。関数の実行時に変数が値を変更する心配を防ぎます。また、これは、単一の遅延呼び出しの場所で複数の関数の実行を遅延できることを意味します。これは簡単な例です。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
    <span class="k">defer</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%d &quot;</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>遅延関数はLIFOの順序で実行されるため、このコードにより、関数が戻るときに <strong>4 3 2 1 0</strong> が出力されます。 より妥当な例は、プログラムを通して関数の実行をトレースする簡単な方法です。 次のような簡単なトレースルーチンをいくつか作成できます。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">trace</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span>   <span class="p">{</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;entering:&quot;</span><span class="p">,</span> <span class="nx">s</span><span class="p">)</span> <span class="p">}</span>
<span class="kd">func</span> <span class="nx">untrace</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;leaving:&quot;</span><span class="p">,</span> <span class="nx">s</span><span class="p">)</span> <span class="p">}</span>

<span class="c1">// Use them like this:</span>
<span class="kd">func</span> <span class="nx">a</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">trace</span><span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">)</span>
    <span class="k">defer</span> <span class="nx">untrace</span><span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">)</span>
    <span class="c1">// do something....</span>
<span class="p">}</span>
</pre></div>
</div>
<p>遅延された関数の引数が <code class="docutils literal notranslate"><span class="pre">defer</span></code> の実行時に評価されるという事実を活用することで、より良い結果を得ることができます。トレースルーチンは、トレース解除ルーチンへの引数を設定できます。以下のような例です。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">trace</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;entering:&quot;</span><span class="p">,</span> <span class="nx">s</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">s</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">un</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;leaving:&quot;</span><span class="p">,</span> <span class="nx">s</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">a</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">defer</span> <span class="nx">un</span><span class="p">(</span><span class="nx">trace</span><span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">))</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;in a&quot;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">b</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">defer</span> <span class="nx">un</span><span class="p">(</span><span class="nx">trace</span><span class="p">(</span><span class="s">&quot;b&quot;</span><span class="p">))</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;in b&quot;</span><span class="p">)</span>
    <span class="nx">a</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">b</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>
</div>
<p>以下のように表示します。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">entering</span><span class="p">:</span> <span class="nx">b</span>
<span class="nx">in</span> <span class="nx">b</span>
<span class="nx">entering</span><span class="p">:</span> <span class="nx">a</span>
<span class="nx">in</span> <span class="nx">a</span>
<span class="nx">leaving</span><span class="p">:</span> <span class="nx">a</span>
<span class="nx">leaving</span><span class="p">:</span> <span class="nx">b</span>
</pre></div>
</div>
<p>他の言語のブロックレベルのリソース管理に慣れているプログラマーにとって <strong>defer</strong> は独特のように思えるかもしれません。しかし、その最も興味深く、強力なアプリケーションは、ブロックベースではなく機能ベースであるという事実からきています。 パニックと回復のセクションでは、別の例を見るでしょう。</p>
</div>
</div>
<div class="section" id="id18">
<h2>データ<a class="headerlink" href="#id18" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="new">
<h3><strong>new</strong> によるアロケーション<a class="headerlink" href="#new" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Goは2つのメモリアロケーションのプリミティブを持っています。組み込み関数である <strong>new</strong> と <strong>make</strong> です。それらは異なることを行い、異なる型に適用するため困惑するかもしれません。しかしルールはシンプルです。まず <strong>new</strong> について説明しましょう。これはメモリをアロケーションする組み込み関数ですが、他のいくつかの言語の同じ関数名のそれとは異なり、メモリを <strong>初期化</strong> せず、ゼロにするだけです。つまり <strong>new(T)</strong> は、型Tの新しい要素にゼロ化されたメモリを割り当て、型*Tの値であるアドレスを返します。 Goの用語では、型Tとして新しく割り当てられたゼロ値へのポインターを返します。</p>
<p><strong>new</strong> によって返されるメモリはゼロ化されます。これはデータ構造を設計する際に、各タイプのゼロ値をさらに初期化せずに使用できるように設計すると役立ちます。 データ構造を用いる開発者が <strong>new</strong> で変数を作成し、適切に動作できることを意味します。 たとえば、 <strong>bytes.Buffer</strong> のドキュメントには、「Bufferのゼロ値はすぐに使用できる空のバッファーです」と記載されています。 同様に <strong>sync.Mutex</strong> には明示的なコンストラクターまたは <strong>Init</strong> メソッドがありません。 代わりに <strong>sync.Mutex</strong> のゼロ値は非ロック状態のミューテックスとして定義されます。</p>
<p>ゼロ値の性質は推移的に機能します。以下の型宣言について考えてください。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">SyncedBuffer</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">lock</span>    <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>
    <span class="nx">buffer</span>  <span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span>
<span class="p">}</span>
</pre></div>
</div>
<p>型 <strong>SyncedBuffer</strong> の値も <strong>new</strong> によるメモリアロケーションや変数の宣言だけですぐに使用できます。次のスニペットでは <strong>p</strong> と <strong>v</strong> の両方が、追加のメソッドなどを用いることなく正しく機能します。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">p</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">SyncedBuffer</span><span class="p">)</span>  <span class="c1">// type *SyncedBuffer</span>
<span class="kd">var</span> <span class="nx">v</span> <span class="nx">SyncedBuffer</span>      <span class="c1">// type  SyncedBuffer</span>
</pre></div>
</div>
</div>
<div class="section" id="id19">
<h3>コンストラクタと複合リテラル<a class="headerlink" href="#id19" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>パッケージ <strong>os</strong> から派生したこの例のように、ゼロ値では不十分な場合があり、初期化コンストラクターが必要になる場合があります。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">NewFile</span><span class="p">(</span><span class="nx">fd</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">name</span> <span class="kt">string</span><span class="p">)</span> <span class="o">*</span><span class="nx">File</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">fd</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">nil</span>
    <span class="p">}</span>
    <span class="nx">f</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">File</span><span class="p">)</span>
    <span class="nx">f</span><span class="p">.</span><span class="nx">fd</span> <span class="p">=</span> <span class="nx">fd</span>
    <span class="nx">f</span><span class="p">.</span><span class="nx">name</span> <span class="p">=</span> <span class="nx">name</span>
    <span class="nx">f</span><span class="p">.</span><span class="nx">dirinfo</span> <span class="p">=</span> <span class="kc">nil</span>
    <span class="nx">f</span><span class="p">.</span><span class="nx">nepipe</span> <span class="p">=</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="nx">f</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上記はたくさんのボイラープレートがあり冗長です。複合リテラルを使用して単純化できます。複合リテラルは、評価されるたびに新しいインスタンスを作成する式です。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">NewFile</span><span class="p">(</span><span class="nx">fd</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">name</span> <span class="kt">string</span><span class="p">)</span> <span class="o">*</span><span class="nx">File</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">fd</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">nil</span>
    <span class="p">}</span>
    <span class="nx">f</span> <span class="o">:=</span> <span class="nx">File</span><span class="p">{</span><span class="nx">fd</span><span class="p">,</span> <span class="nx">name</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="mi">0</span><span class="p">}</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="nx">f</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Cとは異なり、ローカル変数のアドレスを返すことはまったく問題ありません。 変数に関連付けられたアドレスは、関数がreturnされた後も生き残ります。 実際、複合リテラルのアドレスを取得すると、評価されるたびに新しいインスタンスが割り当てられるため、これらの最後の2行を結合できます。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="k">return</span> <span class="o">&amp;</span><span class="nx">File</span><span class="p">{</span><span class="nx">fd</span><span class="p">,</span> <span class="nx">name</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="mi">0</span><span class="p">}</span>
</pre></div>
</div>
<p>複合リテラルのフィールドは順番に配置され、すべて存在する必要があります。 ただし、要素に <strong>field：value</strong> のペアとして明示的にラベルを付けることができます。その場合、フィールドは任意の順序で表示でき、指定されていないフィールドはゼロ値で初期化されます。 したがって、上記の例は以下のように書きかえることができます。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="k">return</span> <span class="o">&amp;</span><span class="nx">File</span><span class="p">{</span><span class="nx">fd</span><span class="p">:</span> <span class="nx">fd</span><span class="p">,</span> <span class="nx">name</span><span class="p">:</span> <span class="nx">name</span><span class="p">}</span>
</pre></div>
</div>
<p>稀なケースとして、複合リテラルにフィールドがまったく含まれていない場合、その型のゼロ値が作成されます。式 <strong>new(File)**と **&amp;File{}</strong> は同等です。</p>
<p>複合リテラルは配列、スライス、マップも作成できます。フィールドラベルは、必要に応じてインデックスまたはマップのキーになります。 以下の例では、初期化は <code class="docutils literal notranslate"><span class="pre">Eonee</span></code>, <code class="docutils literal notranslate"><span class="pre">Eio</span></code> および <code class="docutils literal notranslate"><span class="pre">Einval</span></code> が相異なっていれば、値に関係なく機能します。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">a</span> <span class="o">:=</span> <span class="p">[</span><span class="o">...</span><span class="p">]</span><span class="kt">string</span>   <span class="p">{</span><span class="nx">Enone</span><span class="p">:</span> <span class="s">&quot;no error&quot;</span><span class="p">,</span> <span class="nx">Eio</span><span class="p">:</span> <span class="s">&quot;Eio&quot;</span><span class="p">,</span> <span class="nx">Einval</span><span class="p">:</span> <span class="s">&quot;invalid argument&quot;</span><span class="p">}</span>
<span class="nx">s</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">string</span>      <span class="p">{</span><span class="nx">Enone</span><span class="p">:</span> <span class="s">&quot;no error&quot;</span><span class="p">,</span> <span class="nx">Eio</span><span class="p">:</span> <span class="s">&quot;Eio&quot;</span><span class="p">,</span> <span class="nx">Einval</span><span class="p">:</span> <span class="s">&quot;invalid argument&quot;</span><span class="p">}</span>
<span class="nx">m</span> <span class="o">:=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">string</span><span class="p">{</span><span class="nx">Enone</span><span class="p">:</span> <span class="s">&quot;no error&quot;</span><span class="p">,</span> <span class="nx">Eio</span><span class="p">:</span> <span class="s">&quot;Eio&quot;</span><span class="p">,</span> <span class="nx">Einval</span><span class="p">:</span> <span class="s">&quot;invalid argument&quot;</span><span class="p">}</span>
</pre></div>
</div>
<p>訳注: <a class="reference external" href="https://play.golang.org/p/2DaYxFnjE6X">https://play.golang.org/p/2DaYxFnjE6X</a></p>
</div>
<div class="section" id="make">
<h3><strong>make</strong> によるアロケーション<a class="headerlink" href="#make" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>メモリのアロケーションの話題に戻ります。 組み込み関数 <strong>make(T, args)</strong> は、<strong>new(T)</strong> とは異なる目的で用います。 スライス、マップ、およびチャンネルのみを作成し、型 <strong>T</strong> (*T ではなく)で初期化された(ゼロではない)値を返します。<strong>new(T)</strong> と区別している理由は、これらの3つの型が、使用前に初期化する必要があるデータ構造への参照を内部的に表しているためです。 たとえば、スライスは、データ(配列内)へのポインター、長さ、および容量の3つの項目を持っています。これらの項目が初期化されるまで、スライスはnilです。 スライス、マップ、およびチャネルの場合 <strong>make</strong> は内部データ構造を初期化し、使用する値を準備します。 例えば、</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
</pre></div>
</div>
<p>100個のintの配列を割り当て、長さ10、配列の最初の10要素を指す容量100のスライス構造を作成します。 (スライスを作成するとき、容量は省略できます。詳細については、スライスに関するセクションを参照してください。)一方 <code class="docutils literal notranslate"><span class="pre">new([]int)</span></code> は、新しく割り当てられたゼロ化されたスライスへのポインター、つまり <strong>nil</strong> スライスのポインターを返します。</p>
<p>以下のサンプルは、 <strong>new</strong> と <strong>make</strong> の違いを示しています。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">p</span> <span class="o">*</span><span class="p">[]</span><span class="kt">int</span> <span class="p">=</span> <span class="nb">new</span><span class="p">([]</span><span class="kt">int</span><span class="p">)</span>       <span class="c1">// allocates slice structure; *p == nil; rarely useful</span>
<span class="kd">var</span> <span class="nx">v</span>  <span class="p">[]</span><span class="kt">int</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span> <span class="c1">// the slice v now refers to a new array of 100 ints</span>

<span class="c1">// Unnecessarily complex:</span>
<span class="kd">var</span> <span class="nx">p</span> <span class="o">*</span><span class="p">[]</span><span class="kt">int</span> <span class="p">=</span> <span class="nb">new</span><span class="p">([]</span><span class="kt">int</span><span class="p">)</span>
<span class="o">*</span><span class="nx">p</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>

<span class="c1">// Idiomatic:</span>
<span class="nx">v</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>make</strong> はマップ、スライス、およびチャンネルにのみ適用され、ポインターを返さないことに注意してください。明示的なポインタを取得するには、newで割り当てるか、変数のアドレスを明示的に取得します。</p>
</div>
<div class="section" id="id20">
<h3>配列<a class="headerlink" href="#id20" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>配列は、メモリレイアウトの詳細がわかっているときに役立ち、割り当てを回避するのに役立つ場合があります。しかし、主に次のセクションの主題であるスライスの素材として使われます。 そのスライスの基礎を築くために、配列に関するいくつかの言葉を以下に示します。</p>
<p>GoとCで配列が機能する方法には大きな違いがあります。Goでは</p>
<ul class="simple">
<li><p>配列は値です。ある配列を別の配列に割り当てると、すべての要素がコピーされます。</p></li>
<li><p>特に、関数に配列を渡すと、配列へのポインターではなく配列のコピーを受け取ります。</p></li>
<li><p>配列のサイズはその型の一部です。型 <strong>[10]int</strong> と <strong>[20]int</strong> は区別されます。</p></li>
</ul>
<p>配列が値である性質は便利ですが、高コストでもあります。 Cのような動作と効率が必要な場合は、配列のポインターを渡すことができます。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">Sum</span><span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="kt">float64</span><span class="p">)</span> <span class="p">(</span><span class="nx">sum</span> <span class="kt">float64</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="o">*</span><span class="nx">a</span> <span class="p">{</span>
        <span class="nx">sum</span> <span class="o">+=</span> <span class="nx">v</span>
    <span class="p">}</span>
    <span class="k">return</span>
<span class="p">}</span>

<span class="nx">array</span> <span class="o">:=</span> <span class="p">[</span><span class="o">...</span><span class="p">]</span><span class="kt">float64</span><span class="p">{</span><span class="mf">7.0</span><span class="p">,</span> <span class="mf">8.5</span><span class="p">,</span> <span class="mf">9.1</span><span class="p">}</span>
<span class="nx">x</span> <span class="o">:=</span> <span class="nx">Sum</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">array</span><span class="p">)</span>  <span class="c1">// Note the explicit address-of operator</span>
</pre></div>
</div>
<p>しかしこの書き方はGoらしくありません。代わりにスライスを使います。</p>
</div>
<div class="section" id="id21">
<h3>スライス<a class="headerlink" href="#id21" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>スライスは配列をラップして、連続データへのより一般的で強力かつ便利なインターフェイスを提供します。変換行列などの明示的な次元を持つ項目を除き、Goのほとんどの配列プログラミングは、単純な配列ではなくスライスを使用して行われます。</p>
<p>スライスは、基礎となる配列への参照を保持します。あるスライスを別のスライスに割り当てると、両方とも同じ配列を参照します。 関数がスライスを引数を取る場合、スライスの要素に加えられた変更は呼び出し元に表示されます。これは、基礎となる配列へのポインターの受け渡しに似ています。 したがって <code class="docutils literal notranslate"><span class="pre">Read</span></code> 関数の引数には、ポインターと要素数の値ではなくスライスを受け入れることができます。 スライス内の長さは、読み取るデータ量の上限を設定します。 パッケージ <code class="docutils literal notranslate"><span class="pre">os</span></code> の型 <code class="docutils literal notranslate"><span class="pre">File</span></code> の <code class="docutils literal notranslate"><span class="pre">Read</span></code> メソッドのシグネチャは次のとおりです。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="o">*</span><span class="nx">File</span><span class="p">)</span> <span class="nx">Read</span><span class="p">(</span><span class="nx">buf</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
</pre></div>
</div>
<p>このメソッドは、読み取られたバイト数とエラー値(存在する場合)を返します。大きなバッファー <code class="docutils literal notranslate"><span class="pre">buf</span></code> の最初の32バイトに読み込むには、バッファーを小さくスライスします。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">n</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">f</span><span class="p">.</span><span class="nx">Read</span><span class="p">(</span><span class="nx">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">32</span><span class="p">])</span>
</pre></div>
</div>
<p>このようなスライスは一般的で効率的です。実際、効率性を無視すれば、次のスニペットはバッファーの最初の32バイトを読み取ります。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">n</span> <span class="kt">int</span>
<span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">32</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
    <span class="nx">nbytes</span><span class="p">,</span> <span class="nx">e</span> <span class="o">:=</span> <span class="nx">f</span><span class="p">.</span><span class="nx">Read</span><span class="p">(</span><span class="nx">buf</span><span class="p">[</span><span class="nx">i</span><span class="p">:</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>  <span class="c1">// Read one byte.</span>
    <span class="nx">n</span> <span class="o">+=</span> <span class="nx">nbytes</span>
    <span class="k">if</span> <span class="nx">nbytes</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">e</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">err</span> <span class="p">=</span> <span class="nx">e</span>
        <span class="k">break</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>スライスの長さは、もとになる配列の制限内に収まる限り変更できます。 それを自分自身のスライスに割り当てるだけです。 組み込み関数 <strong>cap</strong> でアクセス可能なスライスの容量は、スライスが想定できる最大長を報告します。 以下の <strong>append</strong> はスライスにデータを追加する関数です。 データが容量を超える場合、再割り当てされたスライスが返されます。 この関数は <strong>nil</strong> スライスに適用されるときに <strong>len</strong> と <strong>cap</strong> が有効であることを使用し、0を返します。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">Append</span><span class="p">(</span><span class="nx">slice</span><span class="p">,</span> <span class="nx">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">{</span>
    <span class="nx">l</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">slice</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">l</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">&gt;</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">slice</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// reallocate</span>
        <span class="c1">// Allocate double what&#39;s needed, for future growth.</span>
        <span class="nx">newSlice</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="p">(</span><span class="nx">l</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="nx">data</span><span class="p">))</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span>
        <span class="c1">// The copy function is predeclared and works for any slice type.</span>
        <span class="nb">copy</span><span class="p">(</span><span class="nx">newSlice</span><span class="p">,</span> <span class="nx">slice</span><span class="p">)</span>
        <span class="nx">slice</span> <span class="p">=</span> <span class="nx">newSlice</span>
    <span class="p">}</span>
    <span class="nx">slice</span> <span class="p">=</span> <span class="nx">slice</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="nx">l</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="nx">data</span><span class="p">)]</span>
    <span class="nb">copy</span><span class="p">(</span><span class="nx">slice</span><span class="p">[</span><span class="nx">l</span><span class="p">:],</span> <span class="nx">data</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">slice</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Appendはスライスの要素を変更できますが、スライス自体(ポインター、長さ、および容量を保持する実行時のデータ構造)は値によって渡されるため、あとからスライスを返すべきです。</p>
<p>スライスに追加するという考え方は非常に便利で、組み込みの <strong>append</strong> 関数によって実現できます。 ただし、その関数の設計を理解するには、もう少し情報が必要なので、後で説明します。</p>
</div>
<div class="section" id="id22">
<h3>二次元スライス<a class="headerlink" href="#id22" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Goの配列とスライスは1次元です。 二次元配列またはスライスに相当するものを作成するには、次のように配列の配列またはスライスのスライスを定義する必要があります。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">Transform</span> <span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span><span class="kt">float64</span>  <span class="c1">// A 3x3 array, really an array of arrays.</span>
<span class="kd">type</span> <span class="nx">LinesOfText</span> <span class="p">[][]</span><span class="kt">byte</span>     <span class="c1">// A slice of byte slices.</span>
</pre></div>
</div>
<p>スライスは可変長であるため、スライスの中にあるスライスを異なる長さにすることができます。 <code class="docutils literal notranslate"><span class="pre">LinesOfText</span></code> の例のように、これは一般的な状況です。各行には独立した長さがあります。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">text</span> <span class="o">:=</span> <span class="nx">LinesOfText</span><span class="p">{</span>
    <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&quot;Now is the time&quot;</span><span class="p">),</span>
    <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&quot;for all good gophers&quot;</span><span class="p">),</span>
    <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&quot;to bring some fun to the party.&quot;</span><span class="p">),</span>
<span class="p">}</span>
</pre></div>
</div>
<p>場合によっては、二次元スライスを割り当てる必要があります。これは、たとえば、ピクセル行をスキャンするときに発生する可能性がある状況です。 これを達成するには2つの方法があります。 1つは、各スライスを個別に割り当てることです。 もう1つは、単一の配列を割り当て、個々のスライスをその配列に向けることです。 どちらを使用するかは、アプリケーションによって異なります。 スライスが拡大または縮小する可能性がある場合は、次の行を上書きしないように、個別に割り当てる必要があります。 そうでない場合は、単一の割り当てでオブジェクトを構築する方が効率的です。 参考のために、2つの方法の概要を以下に示します。 まず、1行ずつことなる長さを割り当てる場合です。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// Allocate the top-level slice.</span>
<span class="nx">picture</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([][]</span><span class="kt">uint8</span><span class="p">,</span> <span class="nx">YSize</span><span class="p">)</span> <span class="c1">// One row per unit of y.</span>
<span class="c1">// Loop over the rows, allocating the slice for each row.</span>
<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">picture</span> <span class="p">{</span>
    <span class="nx">picture</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">uint8</span><span class="p">,</span> <span class="nx">XSize</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>次に、1つのスライスに行を割り当てる方法です。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// Allocate the top-level slice, the same as before.</span>
<span class="nx">picture</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([][]</span><span class="kt">uint8</span><span class="p">,</span> <span class="nx">YSize</span><span class="p">)</span> <span class="c1">// One row per unit of y.</span>
<span class="c1">// Allocate one large slice to hold all the pixels.</span>
<span class="nx">pixels</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">uint8</span><span class="p">,</span> <span class="nx">XSize</span><span class="o">*</span><span class="nx">YSize</span><span class="p">)</span> <span class="c1">// Has type []uint8 even though picture is [][]uint8.</span>
<span class="c1">// Loop over the rows, slicing each row from the front of the remaining pixels slice.</span>
<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">picture</span> <span class="p">{</span>
    <span class="nx">picture</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">pixels</span> <span class="p">=</span> <span class="nx">pixels</span><span class="p">[:</span><span class="nx">XSize</span><span class="p">],</span> <span class="nx">pixels</span><span class="p">[</span><span class="nx">XSize</span><span class="p">:]</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id23">
<h3>マップ<a class="headerlink" href="#id23" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>マップは、ある型(キー)の値を別の型(要素または値)の値に関連付ける便利で強力な組み込みのデータ構造です。 キーは、整数、浮動小数点および複素数、文字列、ポインター、インターフェイス(動的な型が等価をサポートしている限り)、構造体、配列など、等号演算子が定義されている任意の型にすることができます。 スライスは等価が定義されていないため、マップのキーとして使用できません。 スライスと同様に、マップは背後にあるデータ構造への参照を保持します。 マップの内容を変更する関数にマップを渡すと、変更は呼び出し元に表示されます。</p>
<p>マップは、コロンで区切られたキーと値のペアを使用した通常の複合リテラル構文を使用して構築できるため、簡単に初期化することができます。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">timeZone</span> <span class="p">=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span>
    <span class="s">&quot;UTC&quot;</span><span class="p">:</span>  <span class="mi">0</span><span class="o">*</span><span class="mi">60</span><span class="o">*</span><span class="mi">60</span><span class="p">,</span>
    <span class="s">&quot;EST&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">5</span><span class="o">*</span><span class="mi">60</span><span class="o">*</span><span class="mi">60</span><span class="p">,</span>
    <span class="s">&quot;CST&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">6</span><span class="o">*</span><span class="mi">60</span><span class="o">*</span><span class="mi">60</span><span class="p">,</span>
    <span class="s">&quot;MST&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">7</span><span class="o">*</span><span class="mi">60</span><span class="o">*</span><span class="mi">60</span><span class="p">,</span>
    <span class="s">&quot;PST&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">8</span><span class="o">*</span><span class="mi">60</span><span class="o">*</span><span class="mi">60</span><span class="p">,</span>
<span class="p">}</span>
</pre></div>
</div>
<p>マップへの値の割り当てと取得は、キーが整数でなくてもよいことを除いて、配列とスライスの場合と同じような構文に見えます。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">offset</span> <span class="o">:=</span> <span class="nx">timeZone</span><span class="p">[</span><span class="s">&quot;EST&quot;</span><span class="p">]</span>
</pre></div>
</div>
<p>マップに存在しないキーを使用してマップから値を取得しようとすると、マップ内のエントリの型のゼロ値が返されます。 たとえば、マップの値として整数が含まれている場合、存在しないキーを検索すると0が返されます。Setのデータ構造は、boolを値として保持するマップとして実装できます。 マップエントリをtrueに設定して値をセットに入れてから、単純なインデックス作成によってテストします。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">attended</span> <span class="o">:=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">bool</span><span class="p">{</span>
    <span class="s">&quot;Ann&quot;</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
    <span class="s">&quot;Joe&quot;</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
    <span class="o">...</span>
<span class="p">}</span>

<span class="k">if</span> <span class="nx">attended</span><span class="p">[</span><span class="nx">person</span><span class="p">]</span> <span class="p">{</span> <span class="c1">// will be false if person is not in the map</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">person</span><span class="p">,</span> <span class="s">&quot;was at the meeting&quot;</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>存在しないエントリをゼロ値と区別する必要がある場合があります。 「UTC」のエントリはあるか、マップに存在せずゼロ値になるかのどちらかです。 多値を同時に割り当てる形式で区別できます。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">seconds</span> <span class="kt">int</span>
<span class="kd">var</span> <span class="nx">ok</span> <span class="kt">bool</span>
<span class="nx">seconds</span><span class="p">,</span> <span class="nx">ok</span> <span class="p">=</span> <span class="nx">timeZone</span><span class="p">[</span><span class="nx">tz</span><span class="p">]</span>
</pre></div>
</div>
<p>自明な理由により、上記は「コンマOK」イディオムと呼ばれます。 この例では、tzのエントリが存在する場合、秒が適切に設定され、okがtrueになります。 そうでない場合、秒はゼロに設定され、okはfalseになります。 以下は、素晴らしいエラーメッセージと一緒に機能する関数です。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">offset</span><span class="p">(</span><span class="nx">tz</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">seconds</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">timeZone</span><span class="p">[</span><span class="nx">tz</span><span class="p">];</span> <span class="nx">ok</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">seconds</span>
    <span class="p">}</span>
    <span class="nx">log</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;unknown time zone:&quot;</span><span class="p">,</span> <span class="nx">tz</span><span class="p">)</span>
    <span class="k">return</span> <span class="mi">0</span>
<span class="p">}</span>
</pre></div>
</div>
<p>実際の値を気にせずにマップ内の存在をテストするには、値の変数として通常の変数の代わりに <a class="reference external" href="#blank">ブランク識別子</a> を使用できます。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">_</span><span class="p">,</span> <span class="nx">present</span> <span class="o">:=</span> <span class="nx">timeZone</span><span class="p">[</span><span class="nx">tz</span><span class="p">]</span>
</pre></div>
</div>
<p>マップエントリを削除するには組み込み関数である <strong>delete</strong> を使用します。この組み込み関数の引数は、マップと削除するキーです。キーがマップに既に存在しない場合でも、これを行うのは安全です。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nb">delete</span><span class="p">(</span><span class="nx">timeZone</span><span class="p">,</span> <span class="s">&quot;PDT&quot;</span><span class="p">)</span>  <span class="c1">// Now on Standard Time</span>
</pre></div>
</div>
</div>
<div class="section" id="id25">
<h3>プリント<a class="headerlink" href="#id25" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Goの書式付きプリントでは、Cのprintfファミリーに似たスタイルが使用されますが、より機能的で一般的です。 関数は <strong>fmt</strong> パッケージに存在し、大文字の名前が付いています。<code class="docutils literal notranslate"><span class="pre">fmt.Printf</span></code> , <code class="docutils literal notranslate"><span class="pre">fmt.Fprintf</span></code> , <code class="docutils literal notranslate"><span class="pre">fmt.Sprintf</span></code> などです。文字列関数( <code class="docutils literal notranslate"><span class="pre">Sprintf</span></code> など) は、提供されたバッファを埋めるのではなく、文字列を返します。</p>
<p>書式文字列を提供する必要はありません。<code class="docutils literal notranslate"><span class="pre">Printf</span></code> , <code class="docutils literal notranslate"><span class="pre">Fprintf</span></code> , <code class="docutils literal notranslate"><span class="pre">Sprintf</span></code> のそれぞれについて、別のペアの関数、たとえば <code class="docutils literal notranslate"><span class="pre">Print</span></code> と <code class="docutils literal notranslate"><span class="pre">Println</span></code> があります。 これらの関数はフォーマット文字列を取りませんが、代わりに各引数のデフォルトフォーマットを生成します。また <code class="docutils literal notranslate"><span class="pre">Println</span></code> 版は引数の間に空白を挿入し、出力に改行を追加します。しかし <code class="docutils literal notranslate"><span class="pre">Print</span></code> 版は隣り合うどちらの側のオペランドも <code class="docutils literal notranslate"><span class="pre">string</span></code> でない場合にのみ空白を追加します。 この例では、各行は同じ出力を生成します。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;Hello %d\n&quot;</span><span class="p">,</span> <span class="mi">23</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprint</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span><span class="p">,</span> <span class="s">&quot;Hello &quot;</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="s">&quot;\n&quot;</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;Hello&quot;</span><span class="p">,</span> <span class="mi">23</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprint</span><span class="p">(</span><span class="s">&quot;Hello &quot;</span><span class="p">,</span> <span class="mi">23</span><span class="p">))</span>
</pre></div>
</div>
<p>フォーマットされたプリント関数 <strong>fmt.Fprint</strong> と類似する関数は <strong>io.Writer</strong> インターフェイスを実装するオブジェクトを最初の引数として受け取ります。変数 <strong>os.Stdout</strong> と <strong>os.Stderr</strong> はよく知られたインスタンスです。</p>
<p>ここからCと異なります。最初に <strong>%d</strong> などの数値形式は、符号付きまたは大きさのフラグを取りません。 代わりに、プリントルーチンは引数の型を使用してこれらのプロパティを決定します。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">x</span> <span class="kt">uint64</span> <span class="p">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">64</span> <span class="o">-</span> <span class="mi">1</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%d %x; %d %x\n&quot;</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">x</span><span class="p">),</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">x</span><span class="p">))</span>
</pre></div>
</div>
<p>上記は以下のように表示されます。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="mi">18446744073709551615</span> <span class="nx">ffffffffffffffff</span><span class="p">;</span> <span class="o">-</span><span class="mi">1</span> <span class="o">-</span><span class="mi">1</span>
</pre></div>
</div>
<p>整数の小数など、デフォルトの変換だけが必要な場合は、すべてで用いることのできる形式 <strong>%v</strong> を使用できます。 結果はPrintとPrintlnが生成するものとまったく同じです。 さらに、その形式では、配列、スライス、構造体、マップなど、任意の値を出力できます。 これは、前のセクションで定義したタイムゾーンマップのprintステートメントです。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%v\n&quot;</span><span class="p">,</span> <span class="nx">timeZone</span><span class="p">)</span>  <span class="c1">// or just fmt.Println(timeZone)</span>
</pre></div>
</div>
<p>以下のように表示されます。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">map</span><span class="p">[</span><span class="nx">CST</span><span class="p">:</span><span class="o">-</span><span class="mi">21600</span> <span class="nx">EST</span><span class="p">:</span><span class="o">-</span><span class="mi">18000</span> <span class="nx">MST</span><span class="p">:</span><span class="o">-</span><span class="mi">25200</span> <span class="nx">PST</span><span class="p">:</span><span class="o">-</span><span class="mi">28800</span> <span class="nx">UTC</span><span class="p">:</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<p>マップの場合、 <strong>Printf</strong> や周辺の関数は、キーの辞書順でソートして表示します。</p>
<p>構造体をプリントする場合、拡張された形式 <strong>%+v</strong> は構造体のフィールドに名前を付けて注釈を付けます。値があれば代替の形式 <strong>%#v</strong> は値を完全なGo構文でプリントします。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">T</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">a</span> <span class="kt">int</span>
    <span class="nx">b</span> <span class="kt">float64</span>
    <span class="nx">c</span> <span class="kt">string</span>
<span class="p">}</span>
<span class="nx">t</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">T</span><span class="p">{</span> <span class="mi">7</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.35</span><span class="p">,</span> <span class="s">&quot;abc\tdef&quot;</span> <span class="p">}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%v\n&quot;</span><span class="p">,</span> <span class="nx">t</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%+v\n&quot;</span><span class="p">,</span> <span class="nx">t</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%#v\n&quot;</span><span class="p">,</span> <span class="nx">t</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%#v\n&quot;</span><span class="p">,</span> <span class="nx">timeZone</span><span class="p">)</span>
</pre></div>
</div>
<p>以下のように表示されます。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="o">&amp;</span><span class="p">{</span><span class="mi">7</span> <span class="o">-</span><span class="mf">2.35</span> <span class="nx">abc</span>   <span class="nx">def</span><span class="p">}</span>
<span class="o">&amp;</span><span class="p">{</span><span class="nx">a</span><span class="p">:</span><span class="mi">7</span> <span class="nx">b</span><span class="p">:</span><span class="o">-</span><span class="mf">2.35</span> <span class="nx">c</span><span class="p">:</span><span class="nx">abc</span>     <span class="nx">def</span><span class="p">}</span>
<span class="o">&amp;</span><span class="nx">main</span><span class="p">.</span><span class="nx">T</span><span class="p">{</span><span class="nx">a</span><span class="p">:</span><span class="mi">7</span><span class="p">,</span> <span class="nx">b</span><span class="p">:</span><span class="o">-</span><span class="mf">2.35</span><span class="p">,</span> <span class="nx">c</span><span class="p">:</span><span class="s">&quot;abc\tdef&quot;</span><span class="p">}</span>
<span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="s">&quot;CST&quot;</span><span class="p">:</span><span class="o">-</span><span class="mi">21600</span><span class="p">,</span> <span class="s">&quot;EST&quot;</span><span class="p">:</span><span class="o">-</span><span class="mi">18000</span><span class="p">,</span> <span class="s">&quot;MST&quot;</span><span class="p">:</span><span class="o">-</span><span class="mi">25200</span><span class="p">,</span> <span class="s">&quot;PST&quot;</span><span class="p">:</span><span class="o">-</span><span class="mi">28800</span><span class="p">,</span> <span class="s">&quot;UTC&quot;</span><span class="p">:</span><span class="mi">0</span><span class="p">}</span>
</pre></div>
</div>
<p>(アンパサンド <code class="docutils literal notranslate"><span class="pre">&amp;</span></code> に注意してください。)この引用符付き文字列形式は <strong>string</strong> 型または <strong>[]byte</strong> 型の値に適用される場合 <strong>%q</strong> でも使用できます。 別の書式 <strong>%#q</strong> は、可能であれば代わりにバッククォートを使用します。 ( <strong>%q</strong> 形式は、整数とルーンにも適用され、単一引用符で囲まれたルーン定数を生成します。)また <strong>%x</strong> は、文字列、バイト配列、バイトスライス、および整数で機能し、長い16進数文字列を生成し、スペースを使用します フォーマット( <strong>%x</strong> )では、バイト間にスペースを入れます。</p>
<p>もう1つの便利な形式は <strong>%T</strong> です。これは、値の型を出力します。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%T\n&quot;</span><span class="p">,</span> <span class="nx">timeZone</span><span class="p">)</span>
</pre></div>
</div>
<p>以下のように表示されます。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span>
</pre></div>
</div>
<p>デフォルトの書式を拡張したい場合 <strong>String() string</strong> のシグネチャを持つメソッドを型に定義する必要があります。以下のシンプルな型Tは以下のようになります。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">T</span><span class="p">)</span> <span class="nx">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&quot;%d/%g/%q&quot;</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nx">a</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nx">b</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nx">c</span><span class="p">)</span>
<span class="p">}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%v\n&quot;</span><span class="p">,</span> <span class="nx">t</span><span class="p">)</span>
</pre></div>
</div>
<p>フォーマットの出力をします。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="mi">7</span><span class="o">/-</span><span class="mf">2.35</span><span class="o">/</span><span class="s">&quot;abc\tdef&quot;</span>
</pre></div>
</div>
<p>(T型と*T型でプリントする必要がある場合、Stringのレシーバーは値型でなければなりません。この例では、構造体型の方が効率的で慣用的であるため、ポインターを使用しました。 詳細については <a class="reference external" href="#pointers_vs_values">ポインター vs 値のレシーバ</a> をご覧ください。)</p>
<p>String() メソッドは、プリントルーチンが完全にリエントラントであり、このようにラップできるため、Sprintfを呼び出すことができます。 ただし、このアプローチについて理解する必要がある重要な詳細が1つあります。Sprintfを呼び出してStringメソッドを無期限に再帰する方法で実装しないでください。 これは、Sprintfの呼び出しがレシーバーを文字列として直接プリントしようとした場合に発生する可能性があり、その結果、メソッドが再度呼び出されます。 この例が示すように、これはよくある間違いです。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">MyString</span> <span class="kt">string</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="nx">MyString</span><span class="p">)</span> <span class="nx">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&quot;MyString=%s&quot;</span><span class="p">,</span> <span class="nx">m</span><span class="p">)</span> <span class="c1">// Error: will recur forever.</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition-todo admonition" id="id26">
<p class="admonition-title">課題</p>
<p>詳細を示す</p>
</div>
<p>修正も簡単です。引数をメソッドを持たない基本的なstring型に変換します。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">MyString</span> <span class="kt">string</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="nx">MyString</span><span class="p">)</span> <span class="nx">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&quot;MyString=%s&quot;</span><span class="p">,</span> <span class="nb">string</span><span class="p">(</span><span class="nx">m</span><span class="p">))</span> <span class="c1">// OK: note conversion.</span>
<span class="p">}</span>
</pre></div>
</div>
<p>初期化セクションでは、この再帰を回避する別の手法を紹介します。</p>
<p>別のプリントするテクニックは、プリントルーチンの引数を別のルーチンに直接渡すことです。 Printfのシグネチャは、最後の引数に型 <strong>...interface{}</strong> を使用して、フォーマットの後に任意の数のパラメーター(任意の型)を表示できることを指定します。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">Printf</span><span class="p">(</span><span class="nx">format</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">v</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</pre></div>
</div>
<p>Printf関数内では v は <strong>[]interface{}</strong> 型の変数のように機能しますが、別の可変長引数を持つ関数に渡されると、通常の引数リストのように機能します。 上記で使用した <code class="docutils literal notranslate"><span class="pre">log.Println</span></code> 関数の実装を次に示します。 実際の書式設定のために、引数をfmt.Sprintlnに直接渡します。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// Println prints to the standard logger in the manner of fmt.Println.</span>
<span class="kd">func</span> <span class="nx">Println</span><span class="p">(</span><span class="nx">v</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
    <span class="nx">std</span><span class="p">.</span><span class="nx">Output</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintln</span><span class="p">(</span><span class="nx">v</span><span class="o">...</span><span class="p">))</span>  <span class="c1">// Output takes parameters (int, string)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Sprintlnへのネストされた呼び出しでvの後に <strong>...</strong> を記述して、vを引数のリストとして扱うようコンパイラーに指示します。それ以外の場合は、vを単一のスライス引数として渡します。</p>
<p>ここで説明した以外にも、プリントにはさらに多くの機能があります。詳細については、パッケージfmtのgodocドキュメントを参照してください。</p>
<p>ちなみに <strong>...</strong> パラメータは型として指定することができます。たとえば、整数のリストの最小のものを選択するmin関数の場合、パラメータの引数の型は <strong>...int</strong> です。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">Min</span><span class="p">(</span><span class="nx">a</span> <span class="o">...</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="nx">min</span> <span class="o">:=</span> <span class="nb">int</span><span class="p">(^</span><span class="nb">uint</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1">// largest int</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">a</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">min</span> <span class="p">{</span>
            <span class="nx">min</span> <span class="p">=</span> <span class="nx">i</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">min</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="append">
<h3>Append<a class="headerlink" href="#append" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>これで <strong>append</strong> 組み込み関数の設計を説明するために必要な準備が揃いました。appendのシグネチャは、上記で説明したカスタムAppend関数とは異なります。概略的には、次のようなものです。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nb">append</span><span class="p">(</span><span class="nx">slice</span> <span class="p">[]</span><span class="nx">T</span><span class="p">,</span> <span class="nx">elements</span> <span class="o">...</span><span class="nx">T</span><span class="p">)</span> <span class="p">[]</span><span class="nx">T</span>
</pre></div>
</div>
<p>ここで <strong>T</strong> は任意の型のプレースホルダーです。 Goでは、呼び出し側によって型Tが決定される関数を実際に書くことはできません。それがappendが組み込まれている理由です：コンパイラからのサポートが必要です。</p>
<p><strong>append</strong> が実施するのは、要素をスライスの最後に追加して、結果のスライスを返すことです。カスタムのAppend関数と同様に、もとになる配列が変更される可能性があるため、結果を返す必要があります。この簡単な例を示します。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">x</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">}</span>
<span class="nx">x</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>
</pre></div>
</div>
<p>[1 2 3 4 5 6]をプリントします。したがって、appendはPrintfのように機能し、任意の数の引数を受け取ります。</p>
<p>しかしカスタムのAppendが行うことを行い、スライスにスライスを追加する場合はどうでしょうか。答えは簡単です。：上記のOutputの呼び出しで行ったように、呼び出す側で <strong>...</strong> を使用します。このスニペットは、上記のものと同じ出力を生成します。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">x</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">}</span>
<span class="nx">y</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">}</span>
<span class="nx">x</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="o">...</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>...</strong> の識別子がなければ、型が間違っているためコンパイルできません。 yは <strong>int</strong> 型ではありません。</p>
</div>
</div>
<div class="section" id="id27">
<h2>初期化<a class="headerlink" href="#id27" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>見た目はCやC++の初期化と大きく異なりませんが、Goの初期化はより強力です。 初期化中に複雑な構造を構築でき、異なるパッケージ間であっても、初期化されたオブジェクト間の順序の問題は正しく処理されます。</p>
<div class="section" id="id28">
<h3>定数<a class="headerlink" href="#id28" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Goの定数は、まさにその定数です。関数でローカル変数として定義されている場合でも、コンパイル時に作成され、数字、文字(ルーン)、文字列、またはブール値のみを使用できます。 コンパイル時の制限のため、それらを定義する式は、コンパイラーによって評価可能な定数式でなければなりません。 たとえば、 <strong>1 &lt;&lt; 3</strong> は定数式ですが <strong>math.Sin(math.Pi/4)</strong> は <strong>math.Sin</strong> の関数呼び出しが実行時に発生する必要があるため、定数ではありません。</p>
<p>Goでは <strong>iota</strong> 列挙子を使用して列挙定数が作成されます。 iotaは式の一部であり、式は暗黙的に繰り返される可能性があるため、複雑な値のセットを簡単に作成できます。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">ByteSize</span> <span class="kt">float64</span>

<span class="kd">const</span> <span class="p">(</span>
    <span class="nx">_</span>           <span class="p">=</span> <span class="kc">iota</span> <span class="c1">// ignore first value by assigning to blank identifier</span>
    <span class="nx">KB</span> <span class="nx">ByteSize</span> <span class="p">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">10</span> <span class="o">*</span> <span class="kc">iota</span><span class="p">)</span>
    <span class="nx">MB</span>
    <span class="nx">GB</span>
    <span class="nx">TB</span>
    <span class="nx">PB</span>
    <span class="nx">EB</span>
    <span class="nx">ZB</span>
    <span class="nx">YB</span>
<span class="p">)</span>
</pre></div>
</div>
<p><strong>String</strong> などのメソッドをユーザーが定義した任意の型に付属する機能により、任意の値をプリント用に自動的にフォーマットできます。 構造体に最も頻繁に適用されることがわかりますが、この手法は <strong>ByteSize</strong> などの浮動小数点型などのスカラー型にも役立ちます。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="nx">ByteSize</span><span class="p">)</span> <span class="nx">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nx">b</span> <span class="o">&gt;=</span> <span class="nx">YB</span><span class="p">:</span>
        <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&quot;%.2fYB&quot;</span><span class="p">,</span> <span class="nx">b</span><span class="o">/</span><span class="nx">YB</span><span class="p">)</span>
    <span class="k">case</span> <span class="nx">b</span> <span class="o">&gt;=</span> <span class="nx">ZB</span><span class="p">:</span>
        <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&quot;%.2fZB&quot;</span><span class="p">,</span> <span class="nx">b</span><span class="o">/</span><span class="nx">ZB</span><span class="p">)</span>
    <span class="k">case</span> <span class="nx">b</span> <span class="o">&gt;=</span> <span class="nx">EB</span><span class="p">:</span>
        <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&quot;%.2fEB&quot;</span><span class="p">,</span> <span class="nx">b</span><span class="o">/</span><span class="nx">EB</span><span class="p">)</span>
    <span class="k">case</span> <span class="nx">b</span> <span class="o">&gt;=</span> <span class="nx">PB</span><span class="p">:</span>
        <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&quot;%.2fPB&quot;</span><span class="p">,</span> <span class="nx">b</span><span class="o">/</span><span class="nx">PB</span><span class="p">)</span>
    <span class="k">case</span> <span class="nx">b</span> <span class="o">&gt;=</span> <span class="nx">TB</span><span class="p">:</span>
        <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&quot;%.2fTB&quot;</span><span class="p">,</span> <span class="nx">b</span><span class="o">/</span><span class="nx">TB</span><span class="p">)</span>
    <span class="k">case</span> <span class="nx">b</span> <span class="o">&gt;=</span> <span class="nx">GB</span><span class="p">:</span>
        <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&quot;%.2fGB&quot;</span><span class="p">,</span> <span class="nx">b</span><span class="o">/</span><span class="nx">GB</span><span class="p">)</span>
    <span class="k">case</span> <span class="nx">b</span> <span class="o">&gt;=</span> <span class="nx">MB</span><span class="p">:</span>
        <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&quot;%.2fMB&quot;</span><span class="p">,</span> <span class="nx">b</span><span class="o">/</span><span class="nx">MB</span><span class="p">)</span>
    <span class="k">case</span> <span class="nx">b</span> <span class="o">&gt;=</span> <span class="nx">KB</span><span class="p">:</span>
        <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&quot;%.2fKB&quot;</span><span class="p">,</span> <span class="nx">b</span><span class="o">/</span><span class="nx">KB</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&quot;%.2fB&quot;</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>式 <strong>YB</strong> は1.00YBとして表示され、ByteSize(1e13)は9.09TBとして表示されます。</p>
<p>ここでSprintfを使用してByteSizeのStringメソッドを実装することは、変換のためではなく、文字列形式ではない <strong>%f</strong> でSprintfを呼び出すため、安全です(無限に繰り返されることを防ぎます)。Sprintfは、文字列が必要な場合にのみStringメソッドを呼び出します。また <strong>%f</strong> は浮動小数点(float)の値が必要です。</p>
</div>
<div class="section" id="id29">
<h3>変数<a class="headerlink" href="#id29" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>変数は定数と同様に初期化できますが、初期化子は実行時に計算される一般な式にすることができます。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="p">(</span>
    <span class="nx">home</span>   <span class="p">=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Getenv</span><span class="p">(</span><span class="s">&quot;HOME&quot;</span><span class="p">)</span>
    <span class="nx">user</span>   <span class="p">=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Getenv</span><span class="p">(</span><span class="s">&quot;USER&quot;</span><span class="p">)</span>
    <span class="nx">gopath</span> <span class="p">=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Getenv</span><span class="p">(</span><span class="s">&quot;GOPATH&quot;</span><span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="init">
<h3>init関数<a class="headerlink" href="#init" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>最後に、各ソースファイルは独自のinit関数を定義して、必要な状態を設定できます。(実際、各ファイルには複数のinit関数を含めることができます。)init関数は、パッケージやインポートされているパッケージに含まれるすべての宣言されている変数がそれらの初期化子で評価されたあとに呼び出されます。</p>
<p>宣言として表現できない初期化に加えて、init関数の一般的な使用法は、実際の実行が始まる前にプログラムの状態の正当性を検証または修復することです。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">init</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">user</span> <span class="o">==</span> <span class="s">&quot;&quot;</span> <span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="s">&quot;$USER not set&quot;</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">home</span> <span class="o">==</span> <span class="s">&quot;&quot;</span> <span class="p">{</span>
        <span class="nx">home</span> <span class="p">=</span> <span class="s">&quot;/home/&quot;</span> <span class="o">+</span> <span class="nx">user</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">gopath</span> <span class="o">==</span> <span class="s">&quot;&quot;</span> <span class="p">{</span>
        <span class="nx">gopath</span> <span class="p">=</span> <span class="nx">home</span> <span class="o">+</span> <span class="s">&quot;/go&quot;</span>
    <span class="p">}</span>
    <span class="c1">// gopath may be overridden by --gopath flag on command line.</span>
    <span class="nx">flag</span><span class="p">.</span><span class="nx">StringVar</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gopath</span><span class="p">,</span> <span class="s">&quot;gopath&quot;</span><span class="p">,</span> <span class="nx">gopath</span><span class="p">,</span> <span class="s">&quot;override default GOPATH&quot;</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id30">
<h2>メソッド<a class="headerlink" href="#id30" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="id31">
<h3>ポインター vs 値<a class="headerlink" href="#id31" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">ByteSize</span></code> で見たように、メソッドはポインターとインターフェースを除く、名前付きの型に定義することができます。構造体である必要はありません。</p>
<p>上記のスライスの説明では独自のAppend関数を実装しました。スライスのメソッドとして定義することができます。それにはまず、メソッドを紐付ける型に名前を宣言する必要があります。次にメソッドのレシーバーをその名前をつけた型にします。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">ByteSlice</span> <span class="p">[]</span><span class="kt">byte</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">slice</span> <span class="nx">ByteSlice</span><span class="p">)</span> <span class="nx">Append</span><span class="p">(</span><span class="nx">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">{</span>
    <span class="c1">// Body exactly the same as the Append function defined above.</span>
<span class="p">}</span>
</pre></div>
</div>
<p>この場合でもメソッドは更新したスライスを返す必要があります。レシーバーとして型のポインターを取得するようにメソッドを定義しておけば、スライスを返すことなく、引数のスライスを上書きすることができます。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">ByteSlice</span><span class="p">)</span> <span class="nx">Append</span><span class="p">(</span><span class="nx">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">slice</span> <span class="o">:=</span> <span class="o">*</span><span class="nx">p</span>
    <span class="c1">// Body as above, without the return.</span>
    <span class="o">*</span><span class="nx">p</span> <span class="p">=</span> <span class="nx">slice</span>
<span class="p">}</span>
</pre></div>
</div>
<p>実際、もっと改善することができます。以下のように、標準ライブラリの <code class="docutils literal notranslate"><span class="pre">Write</span></code> メソッドのように書きかえることができます。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">ByteSlice</span><span class="p">)</span> <span class="nx">Write</span><span class="p">(</span><span class="nx">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">slice</span> <span class="o">:=</span> <span class="o">*</span><span class="nx">p</span>
    <span class="c1">// Again as above.</span>
    <span class="o">*</span><span class="nx">p</span> <span class="p">=</span> <span class="nx">slice</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nx">data</span><span class="p">),</span> <span class="kc">nil</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">ByteSlice</span></code> 型は標準ライブラリである <code class="docutils literal notranslate"><span class="pre">io.Write</span></code> を満たします。これは便利です。例えば以下のように出力することができます。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">b</span> <span class="nx">ByteSlice</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">b</span><span class="p">,</span> <span class="s">&quot;This hour has %d days\n&quot;</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">ByteSlice</span></code> のアドレスを関数に渡すことができます。これは <code class="docutils literal notranslate"><span class="pre">*ByteSlice</span></code>  型が <code class="docutils literal notranslate"><span class="pre">io.Writer</span></code> インターフェースを満たすためです。ポインタと値に関する規約として、ポインタと値型に対して値のメソッドを呼び出すことができます。ポインタメソッドはポインタのメソッドのみを呼び出すことができます。</p>
<p>この規約はポインターメソッドがレシーバを変更できるために発生します。値として呼び出されると、メソッドは引数のコピーを取得します。よって関数内での変更は破棄されます。言語はこの間違えを許可しません。ただし便利な例外として、変数がメソッドを呼び出す場合に、変数の値がアドレス可能である場合、言語がアドレス演算子を自動的に挿入することによって、値に対してポインタメソッドを呼び出すことができます。上記の例では、変数 <code class="docutils literal notranslate"><span class="pre">b</span></code> はアドレス可能であるため、 <code class="docutils literal notranslate"><span class="pre">b.Write</span></code> をするだけで、 <code class="docutils literal notranslate"><span class="pre">Write</span></code> メソッドを呼び出すことができます。コンパイラは <code class="docutils literal notranslate"><span class="pre">b</span></code> を <code class="docutils literal notranslate"><span class="pre">*b</span></code> に変換します。</p>
<p>余談ですが、 byte のスライスで <code class="docutils literal notranslate"><span class="pre">Write</span></code> を使用する考え方は、 <code class="docutils literal notranslate"><span class="pre">bytes.Buffer</span></code> の実装の中心的なところです。</p>
</div>
</div>
<div class="section" id="id32">
<h2>インターフェースとその他の型<a class="headerlink" href="#id32" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="id33">
<h3>インターフェース<a class="headerlink" href="#id33" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Goのインターフェイスは、オブジェクトの振る舞いを提供します。このセクションではインタフェースにより実現できることすべてを説明します。すでにいくつかの簡単な例を見てきました。カスタムの出力はStringメソッドで実装できますが、FprintfはWriteメソッドであらゆるものに出力できます。1つまたは2つのメソッドのみを持つインターフェイスはGoコードでは一般的であり、通常は、Writeを実装するio.Writerなど、メソッドから派生した名前が付けられます。</p>
<p>型は複数のインターフェースを実装できます。 たとえば、コレクションは <strong>Len()</strong> , <strong>Less(i, j int) bool</strong> , <strong>Swap(i、j int)</strong> を含むsort.Interfaceを実装している場合、パッケージsortのメソッドを用いてソートできます。カスタム出力も同様です。以下の <code class="docutils literal notranslate"><span class="pre">Sequence</span></code> 構造体の例では、どちらのインターフェースも満たしています。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">Sequence</span> <span class="p">[]</span><span class="kt">int</span>

<span class="c1">// Methods required by sort.Interface.</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="nx">Sequence</span><span class="p">)</span> <span class="nx">Len</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="nx">Sequence</span><span class="p">)</span> <span class="nx">Less</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">&lt;</span> <span class="nx">s</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="nx">Sequence</span><span class="p">)</span> <span class="nx">Swap</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">s</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">s</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span> <span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
<span class="p">}</span>

<span class="c1">// Copy returns a copy of the Sequence.</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="nx">Sequence</span><span class="p">)</span> <span class="nx">Copy</span><span class="p">()</span> <span class="nx">Sequence</span> <span class="p">{</span>
    <span class="nx">copy</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="nx">Sequence</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">))</span>
    <span class="k">return</span> <span class="nb">append</span><span class="p">(</span><span class="nx">copy</span><span class="p">,</span> <span class="nx">s</span><span class="o">...</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Method for printing - sorts the elements before printing.</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="nx">Sequence</span><span class="p">)</span> <span class="nx">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="nx">s</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">Copy</span><span class="p">()</span> <span class="c1">// Make a copy; don&#39;t overwrite argument.</span>
    <span class="nx">sort</span><span class="p">.</span><span class="nx">Sort</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
    <span class="nx">str</span> <span class="o">:=</span> <span class="s">&quot;[&quot;</span>
    <span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">elem</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span> <span class="p">{</span> <span class="c1">// Loop is O(N²); will fix that in next example.</span>
        <span class="k">if</span> <span class="nx">i</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="nx">str</span> <span class="o">+=</span> <span class="s">&quot; &quot;</span>
        <span class="p">}</span>
        <span class="nx">str</span> <span class="o">+=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprint</span><span class="p">(</span><span class="nx">elem</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">str</span> <span class="o">+</span> <span class="s">&quot;]&quot;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id34">
<h3>変換<a class="headerlink" href="#id34" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>SequenceのStringメソッドは、Sprintがスライスに対してすでに行っている内容を再作成しています。(複雑なO(N²)もあります。これはナイーブな実装です。)Sprintを呼び出す前にSequenceを純粋な <strong>[]int</strong> に変換すると、既存の処理を利用することができます(また、高速化できます)。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="nx">Sequence</span><span class="p">)</span> <span class="nx">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="nx">s</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">Copy</span><span class="p">()</span>
    <span class="nx">sort</span><span class="p">.</span><span class="nx">Sort</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprint</span><span class="p">([]</span><span class="nb">int</span><span class="p">(</span><span class="nx">s</span><span class="p">))</span>
<span class="p">}</span>
</pre></div>
</div>
<p>このメソッドは、StringメソッドからSprintfを安全に呼び出すための変換手法の別の例です。 型名を無視する場合、2つの型( <strong>Sequence</strong> と <strong>[]int</strong> )は同じであるため、それらの間で変換することは正当です。 変換は新しい値を作成するのではなく、既存の値に新しい型があるかのように一時的に動作するだけです。(整数から浮動小数点への変換など、新しい値を作成する他の有効な変換があります。)</p>
<p>式の型を変換して別のメソッドセットにアクセスすることは、Goプログラムのイディオムです。例として、既存のsort.IntSlice型を使用して、例全体を以下のように実装量を削減することができます。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">Sequence</span> <span class="p">[]</span><span class="kt">int</span>

<span class="c1">// Method for printing - sorts the elements before printing</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="nx">Sequence</span><span class="p">)</span> <span class="nx">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="nx">s</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">Copy</span><span class="p">()</span>
    <span class="nx">sort</span><span class="p">.</span><span class="nx">IntSlice</span><span class="p">(</span><span class="nx">s</span><span class="p">).</span><span class="nx">Sort</span><span class="p">()</span>
    <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprint</span><span class="p">([]</span><span class="nb">int</span><span class="p">(</span><span class="nx">s</span><span class="p">))</span>
<span class="p">}</span>
</pre></div>
</div>
<p>現在、Sequenceに複数のインターフェイス(ソートとプリント)を実装する代わりに、データ項目の機能を使用して、複数の型(Sequence、sort.IntSlice、[]int)に変換します。これは実際にはほとんどありませんが、効果的です。</p>
</div>
<div class="section" id="id35">
<h3>インターフェースの変換と型アサーション<a class="headerlink" href="#id35" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>型 <code class="docutils literal notranslate"><span class="pre">switch</span></code> は変換の形式です。 <code class="docutils literal notranslate"><span class="pre">switch</span></code> はインターフェイスを取得し、 <code class="docutils literal notranslate"><span class="pre">switch`</span> <span class="pre">`の各ケースについて、ある意味でそのケースの型に変換します。</span> <span class="pre">以下は</span> <span class="pre">``fmt.Printf</span></code> の内部で、型 <code class="docutils literal notranslate"><span class="pre">switch</span></code> を使用して値を文字列に変換する方法の簡易的な実装です。 すでに string である場合は、インターフェイスが保持する実際の文字列の値が必要です。一方、String() メソッドがある場合は、メソッドを呼び出した結果が必要です。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">Stringer</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nx">String</span><span class="p">()</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">value</span> <span class="kd">interface</span><span class="p">{}</span> <span class="c1">// Value provided by caller.</span>
<span class="k">switch</span> <span class="nx">str</span> <span class="o">:=</span> <span class="nx">value</span><span class="p">.(</span><span class="kd">type</span><span class="p">)</span> <span class="p">{</span>
<span class="k">case</span> <span class="kt">string</span><span class="p">:</span>
    <span class="k">return</span> <span class="nx">str</span>
<span class="k">case</span> <span class="nx">Stringer</span><span class="p">:</span>
    <span class="k">return</span> <span class="nx">str</span><span class="p">.</span><span class="nx">String</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>
</div>
<p>最初の <code class="docutils literal notranslate"><span class="pre">case</span></code> は具体的な string の値を見つけます。 2番目は、インターフェイスを別のインターフェイスに変換します。このように型をまぜこぜにすることはまったく問題ありません。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">value</span><span class="p">.(</span><span class="nx">typeName</span><span class="p">)</span>
</pre></div>
</div>
<p>結果は、静的な型 <code class="docutils literal notranslate"><span class="pre">typeName</span></code> を持つ新しい値です。その型は、インターフェイスが保持する具象型か、値を変換できるインターフェイス型でなければなりません。値に含まれていることがわかっている文字列を抽出するには、次のように記述できます。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">str</span> <span class="o">:=</span> <span class="nx">value</span><span class="p">.(</span><span class="kt">string</span><span class="p">)</span>
</pre></div>
</div>
<p>しかし、値に文字列が含まれていないことが判明した場合、プログラムは実行時エラーでクラッシュします。これを防ぐには、 <code class="docutils literal notranslate"><span class="pre">、ok</span></code> というイディオムを使用して、値が文字列かどうかを安全に確認します。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">str</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">value</span><span class="p">.(</span><span class="kt">string</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">ok</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;string value is: %q\n&quot;</span><span class="p">,</span> <span class="nx">str</span><span class="p">)</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;value is not a string\n&quot;</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>型のアサーションが失敗した場合 <code class="docutils literal notranslate"><span class="pre">str</span></code> はゼロ値の string 型です。つまり空の文字列になります。</p>
<p>上記の型変換の例として、このセクションで説明した型 <code class="docutils literal notranslate"><span class="pre">switch``に相当する</span> <span class="pre">``if-else</span></code> ステートメントを次に示します。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="nx">str</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">value</span><span class="p">.(</span><span class="kt">string</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">str</span>
<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">str</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">value</span><span class="p">.(</span><span class="nx">Stringer</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">str</span><span class="p">.</span><span class="nx">String</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id36">
<h3>概説<a class="headerlink" href="#id36" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>インターフェースを実装するためだけに型が存在し、そのインターフェースを超えてメソッドを公開する必要がない場合、型自体を公開する必要はありません。インターフェースのみを公開すると、値がインターフェースで説明されている以上の興味深い動作を持たないことが明確になります。また、共通メソッドのすべてのインスタンスでドキュメントを繰り返す必要がなくなります。</p>
<p>このような場合、コンストラクターは具象型ではなくインターフェイス値を返す必要があります。例として、ハッシュライブラリでは <code class="docutils literal notranslate"><span class="pre">crc32.NewIEEE</span></code> と <code class="docutils literal notranslate"><span class="pre">adler32.New</span></code> の両方がインターフェイス型 <code class="docutils literal notranslate"><span class="pre">hash.Hash32</span></code> を返します。 Goプログラムで <code class="docutils literal notranslate"><span class="pre">Adler-32</span></code> を <code class="docutils literal notranslate"><span class="pre">CRC-32</span></code> アルゴリズムに置き換えるには、コンストラクター呼び出しを変更するだけです。 残りのコードは、アルゴリズムの変更による影響を受けません。</p>
<p>同様のアプローチにより、さまざまな <code class="docutils literal notranslate"><span class="pre">crypto</span></code> パッケージのストリーミング暗号化アルゴリズムを、一連の暗号化されたブロック暗号から分離できます。 <code class="docutils literal notranslate"><span class="pre">crypto/cipher</span></code> パッケージのブロックインターフェイスは、ブロック暗号の動作を指定します。ブロック暗号は、単一のデータブロックの暗号化を提供します。 次に、bufioパッケージと同様に、このインターフェイスを実装する暗号パッケージを使用して、ブロック暗号化の詳細を知らなくても、Streamインターフェイスで表されるストリーミング暗号を構築できます。</p>
<div class="admonition-todo admonition" id="id37">
<p class="admonition-title">課題</p>
<p>英語がよくわからない</p>
</div>
<p>下は <code class="docutils literal notranslate"><span class="pre">crypto/cipher</span></code> 内のインタフェースです。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">Block</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nx">BlockSize</span><span class="p">()</span> <span class="kt">int</span>
    <span class="nx">Encrypt</span><span class="p">(</span><span class="nx">dst</span><span class="p">,</span> <span class="nx">src</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span>
    <span class="nx">Decrypt</span><span class="p">(</span><span class="nx">dst</span><span class="p">,</span> <span class="nx">src</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Stream</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nx">XORKeyStream</span><span class="p">(</span><span class="nx">dst</span><span class="p">,</span> <span class="nx">src</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>次に、ブロック暗号をストリーミング暗号に変換するカウンターモード(CTR)ストリームの定義を示します。ブロック暗号の詳細が抽象化されていることに注意してください。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// NewCTR returns a Stream that encrypts/decrypts using the given Block in</span>
<span class="c1">// counter mode. The length of iv must be the same as the Block&#39;s block size.</span>
<span class="kd">func</span> <span class="nx">NewCTR</span><span class="p">(</span><span class="nx">block</span> <span class="nx">Block</span><span class="p">,</span> <span class="nx">iv</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="nx">Stream</span>
</pre></div>
</div>
<p>NewCTRは、1つの特定の暗号化アルゴリズムとデータソースだけでなく、BlockインターフェイスとStreamの実装にも適用されます。 インターフェイス値を返すため、CTR暗号化を他の暗号化モードに置き換えることは局所的な変更です。 コンストラクターの呼び出しは修正する必要がありますが、周囲のコードは結果をストリームとしてのみ処理する必要があるため、違いに気付かないでしょう。</p>
</div>
<div class="section" id="id38">
<h3>インターフェースとメソッド<a class="headerlink" href="#id38" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>ほとんどすべての型にメソッドを実装でき、インターフェースを満たすことができます。 1つの実例は <strong>http</strong> パッケージにあり、これは <strong>Handler</strong> インターフェースを定義します。 Handler を実装するオブジェクトは、HTTPリクエストを処理できます。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">Handler</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nx">ServeHTTP</span><span class="p">(</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="o">*</span><span class="nx">Request</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>ResponseWriter自体は、クライアントに応答を返すために必要なメソッドを提供するインターフェースです。これらのメソッドには標準のWriteメソッドが含まれているため <code class="docutils literal notranslate"><span class="pre">io.Writer</span></code> を用いてhttp.ResponseWriterを使用できます。リクエストは、クライアントからのリクエストを解析した結果を含む構造体です。</p>
<p>簡潔のために、POSTを無視し、HTTPリクエストは常にGETであると仮定しましょう。この仮定は Handler のセットアップ方法には影響しません。これは、ページがアクセスされた回数をカウントするための Handler の簡易的な実装ですが、完全です。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// Simple counter server.</span>
<span class="kd">type</span> <span class="nx">Counter</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">n</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">ctr</span> <span class="o">*</span><span class="nx">Counter</span><span class="p">)</span> <span class="nx">ServeHTTP</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">req</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">ctr</span><span class="p">.</span><span class="nx">n</span><span class="o">++</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="s">&quot;counter = %d\n&quot;</span><span class="p">,</span> <span class="nx">ctr</span><span class="p">.</span><span class="nx">n</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>(今回のテーマに気を留めながら <code class="docutils literal notranslate"><span class="pre">Fprintf</span></code> が <code class="docutils literal notranslate"><span class="pre">http.ResponseWriter</span></code> に出力する方法に注意してください。)参考のために、このようなサーバーをURLのパスとして表現する方法を示します。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="s">&quot;net/http&quot;</span>
<span class="o">...</span>
<span class="nx">ctr</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">Counter</span><span class="p">)</span>
<span class="nx">http</span><span class="p">.</span><span class="nx">Handle</span><span class="p">(</span><span class="s">&quot;/counter&quot;</span><span class="p">,</span> <span class="nx">ctr</span><span class="p">)</span>
</pre></div>
</div>
<p>しかし、なぜCounterを構造体にするのでしょうか？必要なのは整数だけです。(レシーバは、呼び出し元に増えたカウント n が参照できるようにポインターである必要があります。)</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// Simpler counter server.</span>
<span class="kd">type</span> <span class="nx">Counter</span> <span class="kt">int</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">ctr</span> <span class="o">*</span><span class="nx">Counter</span><span class="p">)</span> <span class="nx">ServeHTTP</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">req</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">*</span><span class="nx">ctr</span><span class="o">++</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="s">&quot;counter = %d\n&quot;</span><span class="p">,</span> <span class="o">*</span><span class="nx">ctr</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>自作プログラムが内部ステータスを持っていて、そこにページが訪問されたことを通知しなければならないとしたらどうすればよいでしょうか。このようなときは、次のようにチャネルとウェブページとを関連付けてください。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// A channel that sends a notification on each visit.</span>
<span class="c1">// (Probably want the channel to be buffered.)</span>
<span class="kd">type</span> <span class="nx">Chan</span> <span class="kd">chan</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">ch</span> <span class="nx">Chan</span><span class="p">)</span> <span class="nx">ServeHTTP</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">req</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">ch</span> <span class="o">&lt;-</span> <span class="nx">req</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprint</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="s">&quot;notification sent&quot;</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>最後に、サーバーバイナリを呼び出すときに使用される引数を <code class="docutils literal notranslate"><span class="pre">/args</span></code> に渡したいとします。引数を出力する関数を書くのは簡単です。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">ArgServer</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Args</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>これをどのようにしてHTTPサーバーに変換しますか?ArgServerを、値を無視するタイプのメソッドにすることもできますが、より明確な方法があります。ポインターとインターフェイスを除くすべての型にメソッドを定義できるため、関数のメソッドを記述できます。httpパッケージには次のコードが含まれています。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// The HandlerFunc type is an adapter to allow the use of</span>
<span class="c1">// ordinary functions as HTTP handlers.  If f is a function</span>
<span class="c1">// with the appropriate signature, HandlerFunc(f) is a</span>
<span class="c1">// Handler object that calls f.</span>
<span class="kd">type</span> <span class="nx">HandlerFunc</span> <span class="kd">func</span><span class="p">(</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="o">*</span><span class="nx">Request</span><span class="p">)</span>

<span class="c1">// ServeHTTP calls f(w, req).</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="nx">HandlerFunc</span><span class="p">)</span> <span class="nx">ServeHTTP</span><span class="p">(</span><span class="nx">w</span> <span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">req</span> <span class="o">*</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">f</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="nx">req</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong>HandlerFunc</strong> は <strong>ServeHTTP</strong> というメソッドを持つ型であるため、その型の値はHTTPリクエストを処理できます。メソッドの実装を見てください。レシーバは関数 <code class="docutils literal notranslate"><span class="pre">f</span></code> であり、メソッドは <code class="docutils literal notranslate"><span class="pre">f</span></code> を呼び出します。それは不思議に思えるかもしれませんが、例えば、レシーバーがチャンネルであり、チャンネルで送信するメソッドとそれほど違いはありません。</p>
<p>ArgServerをHTTPサーバーにするには、まずHTTPリクエストを処理できるようにシグネチャを変更します。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// Argument server.</span>
<span class="kd">func</span> <span class="nx">ArgServer</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">req</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintln</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Args</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>ArgServerは <strong>HandlerFunc</strong> と同じシグネチャを持つようになったので、メソッドにアクセスするためにその型に変換できます。前のセクションでSequenceの型をIntSliceの型に変換してIntSlice.Sortにアクセスしたようなものです。実装するコードは簡潔です。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">http</span><span class="p">.</span><span class="nx">Handle</span><span class="p">(</span><span class="s">&quot;/args&quot;</span><span class="p">,</span> <span class="nx">http</span><span class="p">.</span><span class="nx">HandlerFunc</span><span class="p">(</span><span class="nx">ArgServer</span><span class="p">))</span>
</pre></div>
</div>
<p>誰かがパス <code class="docutils literal notranslate"><span class="pre">/args</span></code> にアクセスすると、そのパスに紐付いているハンドラーの値はArgServerであり、HandlerFuncと入力されます。 HTTPサーバーは、ArgServerをレシーバーとして、そのタイプのServeHTTPメソッドを呼び出します。これは、ArgServerを呼び出します(HandlerFunc.ServeHTTP内の呼び出し <strong>f(w, req)</strong> を経由します)。そして、引数が表示されます。</p>
<p>このセクションでは、構造体、整数、チャネル、および関数からHTTPサーバーを作成しました。これは、インターフェイスがほとんど任意の型に対して定義できる単なるメソッドのセットであることを示すためです。</p>
</div>
</div>
<div class="section" id="id39">
<h2>ブランク識別子<a class="headerlink" href="#id39" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>ブランク識別子については、 <code class="docutils literal notranslate"><span class="pre">for</span></code> の <code class="docutils literal notranslate"><span class="pre">range</span></code> ループや <code class="docutils literal notranslate"><span class="pre">map</span></code> で何度か言及しました。ブランク識別子は型の値に関係なく、使うことができます。問題なく値は破棄されます。Unixの <code class="docutils literal notranslate"><span class="pre">/dev/null</span></code> への書き込みに似ています。書き込みが必要な値のプレースホルダーとして扱われます。実際の値は関係ありません。すでに見てきた以上に使われます。</p>
<div class="section" id="id40">
<h3>いろいろな場所におけるブランク識別子<a class="headerlink" href="#id40" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">for</span> <span class="pre">range</span></code> ループの中でのブランク識別子の用途は、ブランク識別子の特殊なケースです。複数の値が返却される場合において、一方の値のみしかプログラム中で使用しない場合、ブランク識別子を宣言することによって、ダミーの変数を作成する必要がなくなります。値は破棄されます。例えば、値とエラーを返すが、エラーのみが重要な場合、ブランク識別子を使用して、必要のない値を破棄します。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Stat</span><span class="p">(</span><span class="nx">path</span><span class="p">);</span> <span class="nx">os</span><span class="p">.</span><span class="nx">IsNotExist</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%s does not exist\n&quot;</span><span class="p">,</span> <span class="nx">path</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>エラーを無視するために、エラー値を破棄するコードを見かけるかもしれません。これはとても悪い習慣です。常に返ってくるエラーをチェックすべきです。エラーには理由があります。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// Bad! This code will crash if path does not exist.</span>
<span class="nx">fi</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Stat</span><span class="p">(</span><span class="nx">path</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">fi</span><span class="p">.</span><span class="nx">IsDir</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%s is a directory\n&quot;</span><span class="p">,</span> <span class="nx">path</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id41">
<h3>未使用のインポートと変数<a class="headerlink" href="#id41" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>インポートしたパッケージや変数を使用せずに、宣言するとエラーになります。未使用のインポートはプログラムを肥大化させ、コンパイルを遅くします。一方、初期化されているが使用されていない変数は、少なくとも無駄な計算であり、大きなバグを示しているでしょう。 しかし、プログラムが活発に開発されている場合、未使用のインポートと変数が頻繁に発生し、コンパイルするために削除します。後で追加するのは面倒です。空白の識別子は回避策を提供します。</p>
<p>以下の途中まで実装されているプログラムでは <code class="docutils literal notranslate"><span class="pre">fmt</span></code> と <code class="docutils literal notranslate"><span class="pre">io</span></code> という2つの未使用のインポートがあります。また、 <code class="docutils literal notranslate"><span class="pre">fd</span></code> という未使用の変数があります。そのためコンパイルできませんが、コードが正しいことを示すために良い方法があります。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&quot;fmt&quot;</span>
    <span class="s">&quot;io&quot;</span>
    <span class="s">&quot;log&quot;</span>
    <span class="s">&quot;os&quot;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">fd</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Open</span><span class="p">(</span><span class="s">&quot;test.go&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="c1">// TODO: use fd.</span>
<span class="p">}</span>
</pre></div>
</div>
<p>未使用のインポートの警告を抑えるために、ブランク識別子をインポートパッケージのシンボルにすることができます。同様に未使用の変数( <code class="docutils literal notranslate"><span class="pre">fd</span></code> )もブランク識別子を使うことで警告をコンパイルエラーを抑えることができます。そうすると、以下のようにコンパイルすることができます。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&quot;fmt&quot;</span>
    <span class="s">&quot;io&quot;</span>
    <span class="s">&quot;log&quot;</span>
    <span class="s">&quot;os&quot;</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="nx">_</span> <span class="p">=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span> <span class="c1">// For debugging; delete when done.</span>
<span class="kd">var</span> <span class="nx">_</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Reader</span>    <span class="c1">// For debugging; delete when done.</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">fd</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Open</span><span class="p">(</span><span class="s">&quot;test.go&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="c1">// TODO: use fd.</span>
    <span class="nx">_</span> <span class="p">=</span> <span class="nx">fd</span>
<span class="p">}</span>
</pre></div>
</div>
<p>慣習により、インポートエラーを抑えるためのグローバル宣言はインポート文のすぐ後に記述します。これは、わかりやすするためであって、後ほど忘れずにきれいにすることを忘れずにするためです。</p>
</div>
<div class="section" id="id42">
<h3>インポートの副作用<a class="headerlink" href="#id42" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>前の例の <code class="docutils literal notranslate"><span class="pre">fmt</span></code> や <code class="docutils literal notranslate"><span class="pre">io</span></code> などの未使用のインポートは、最終的に使用または削除する必要があります。ブランク識別子に割り当てたオブジェクトは、開発中のコードであると認識します。ただし、明示的な使用をせずに、副作用のみのためにパッケージをインポートすると便利な場合があります。たとえば、 <code class="docutils literal notranslate"><span class="pre">net/http/pprof</span></code> パッケージは、init関数の実行中に、デバッグ情報を提供するHTTPハンドラーを登録します。公開されているAPIがありますが、ほとんどのクライアントはハンドラーの登録とWebページへのアクセスを介したデバッグ情報へのアクセスのみを必要とします。副作用のためだけにパッケージをインポートするには、パッケージの名前をブランク識別子に変更します。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nx">_</span> <span class="s">&quot;net/http/pprof&quot;</span>
</pre></div>
</div>
<p>この形式のインポートは、パッケージがその副作用のためにインポートされていることを明確にします。これは、ソースコードの中でパッケージを使用することがないためです。(もし名前があって使用しなかった場合、コンパイルエラーになります。)</p>
</div>
<div class="section" id="id43">
<h3>インターフェースのチェック<a class="headerlink" href="#id43" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>上記のインターフェイスの説明で見たように、型はインターフェイスを実装することを明示的に宣言する必要はありません。 代わりに、型はインターフェイスのメソッドを実装するだけでインターフェイスを実装します。 実際には、ほとんどのインターフェイスの変換は静的であるため、コンパイル時にチェックされます。 たとえば、io.Readerが必要な関数に <code class="docutils literal notranslate"><span class="pre">*os.File</span></code> を渡すと <code class="docutils literal notranslate"><span class="pre">*os.File</span></code> は <code class="docutils literal notranslate"><span class="pre">io.Reader</span></code> インターフェイスを実装しない限りコンパイルされません。</p>
<p>ただし、一部のインターフェイスのチェックは実行時に行われます。1つのインスタンスは <code class="docutils literal notranslate"><span class="pre">encoding/json</span></code> パッケージです。Marshalerインターフェイスを定義します。JSONエンコーダーは、そのインターフェイスを実装する値を受け取ると、標準の変換を行う代わりに、値をマーシャルするメソッドを呼び出してJSONに変換します。エンコーダーは、実行時にこの変換をするために、次のような型アサーションでチェックします。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">m</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">val</span><span class="p">.(</span><span class="nx">json</span><span class="p">.</span><span class="nx">Marshaler</span><span class="p">)</span>
</pre></div>
</div>
<p>実際にインターフェイス自体を使用せずに、エラーチェックの一部として、型がインターフェイスを実装しているかどうかを確認するだけの場合は、ブランク識別子を使用して型アサーションした値を無視します。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">val</span><span class="p">.(</span><span class="nx">json</span><span class="p">.</span><span class="nx">Marshaler</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;value %v of type %T implements json.Marshaler\n&quot;</span><span class="p">,</span> <span class="nx">val</span><span class="p">,</span> <span class="nx">val</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>この状況が発生する場所の1つは、型を実装するパッケージ内で、実際にインターフェースを満たすことを保証する必要がある場合です。 型(json.RawMessageなど)がカスタムJSON表現を必要とする場合、json.Marshalerを実装する必要がありますが、コンパイラがこれを自動的に検証できる、明示的な変換はありません。型が意図せずインターフェイスを満たさない場合でも、JSONエンコーダーは動作しますが、カスタム実装は使用しません。実装が正しいことを保証するために、ブランク識別子を使用するグローバル宣言をパッケージで使用できます。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">_</span> <span class="nx">json</span><span class="p">.</span><span class="nx">Marshaler</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">RawMessage</span><span class="p">)(</span><span class="kc">nil</span><span class="p">)</span>
</pre></div>
</div>
<p>この宣言では <code class="docutils literal notranslate"><span class="pre">*RawMessage</span></code> が <code class="docutils literal notranslate"><span class="pre">Marshaler</span></code> インターフェースを実装する必要とするような <code class="docutils literal notranslate"><span class="pre">*RawMessage</span></code> から <code class="docutils literal notranslate"><span class="pre">Marshaler</span></code> への変換をする場合、型がインターフェースを実装しているかどうかは、コンパイル時にチェックされます。json.Marshalerインターフェースが変更された場合、このパッケージはコンパイルされなくなり、ソースコードを修正する必要であることがわかります。</p>
<p>この構造内のブランク識別子は、変数を作成するためではなく、型チェックのためだけに宣言が存在することを示しています。 ただし、インターフェイスを満たすすべての型に対してこれを実行しないでください。慣例により、このような宣言は、コードに静的な変換が存在しない場合にのみ使用されます。これはあまりありません。</p>
</div>
</div>
<div class="section" id="id44">
<h2>埋め込み<a class="headerlink" href="#id44" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Goは、典型的な型のサブクラス化の概念を提供しませんが、構造体またはインターフェイス内に型を埋め込むことにより、実装の一部を「借りる」機能を備えています。</p>
<p>インターフェイスの埋め込みは非常に簡単です。 以前に <strong>io.Reader</strong> および <strong>io.Writer</strong> インターフェースについて言及しました。定義は次のとおりです。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">Reader</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nx">Read</span><span class="p">(</span><span class="nx">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Writer</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nx">Write</span><span class="p">(</span><span class="nx">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>ioパッケージは、そのようないくつかのメソッドを実装できるオブジェクトを持つインターフェースも公開しています。 たとえば、読み取りと書き込みの両方を含むインターフェイスである <strong>io.ReadWriter</strong> があります。 2つのメソッドを明示的にリストすることで <strong>io.ReadWriter</strong> を指定できますが、次のように2つのインターフェイスを埋め込んで新しいインターフェイスを作成する方が簡単で示唆に富んでいます。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// ReadWriter is the interface that combines the Reader and Writer interfaces.</span>
<span class="kd">type</span> <span class="nx">ReadWriter</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nx">Reader</span>
    <span class="nx">Writer</span>
<span class="p">}</span>
</pre></div>
</div>
<p>これは、見た目だけを示しています。 <strong>ReadWriter</strong> は、Readerの機能とWriterの機能を実行できます。 これは、組み込みインターフェース(メソッドの互いに素なセットでなければなりません)の結合です。 インターフェイスにのみ埋め込むことができます。</p>
<p>同じ基本的な考え方は構造体にも当てはまりますが、より広範囲に影響を及ぼします。 <strong>bufio</strong> パッケージには、bufio.Readerとbufio.Writerの2つの構造体タイプがあり、それぞれがパッケージioから類似のインターフェースを実装しています。 またbufioは、バッファー付きの Reader/Writer も実装します。これは、埋め込みを使用して Reader と Writer を1つの構造に結合することで行います。構造内の型をリストしますが、フィールド名は付けません。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// ReadWriter stores pointers to a Reader and a Writer.</span>
<span class="c1">// It implements io.ReadWriter.</span>
<span class="kd">type</span> <span class="nx">ReadWriter</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="o">*</span><span class="nx">Reader</span>  <span class="c1">// *bufio.Reader</span>
    <span class="o">*</span><span class="nx">Writer</span>  <span class="c1">// *bufio.Writer</span>
<span class="p">}</span>
</pre></div>
</div>
<p>埋め込まれた要素は構造体へのポインタであり、使用する前に有効な構造体を指すように初期化する必要があります。 <strong>ReadWriter</strong> 構造体は次のように記述できます。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">ReadWriter</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">reader</span> <span class="o">*</span><span class="nx">Reader</span>
    <span class="nx">writer</span> <span class="o">*</span><span class="nx">Writer</span>
<span class="p">}</span>
</pre></div>
</div>
<p>しかし、フィールドのメソッドを用いるためioインターフェースを満たすために、次のような転送するメソッドも提供する必要があります。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="p">(</span><span class="nx">rw</span> <span class="o">*</span><span class="nx">ReadWriter</span><span class="p">)</span> <span class="nx">Read</span><span class="p">(</span><span class="nx">p</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">rw</span><span class="p">.</span><span class="nx">reader</span><span class="p">.</span><span class="nx">Read</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>構造体を直接埋め込むことにより、この問題を回避します。埋め込みした型のメソッドは透過的に提供されます。つまりbufio.ReadWriterにはbufio.Readerとbufio.Writerのメソッドがあるだけでなく、io.Reader、io.Writer、およびio.ReadWriterの3つのすべてのインターフェイスも満たします。</p>
<p>埋め込みがサブクラス化と異なる重要な点があります。型を埋め込むと、その型のメソッドは外側の型のメソッドになりますが、呼び出されると、メソッドのレシーバーは外側の型ではなく内側の型になります。 この例では、bufio.ReadWriterのReadメソッドが呼び出されると、上記の転送するメソッドとまったく同じ効果があります。レシーバーは、ReadWriter自体ではなく、ReadWriterのreaderフィールド(の型)です。</p>
<p>埋め込みも簡単にできます。次の例では埋め込みフィールドと通常の名前つきフィールドとが一緒になったものです。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">Job</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Command</span> <span class="kt">string</span>
    <span class="o">*</span><span class="nx">log</span><span class="p">.</span><span class="nx">Logger</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Jobの構造体には、Print、Printf、Println、および <a href="#id45"><span class="problematic" id="id46">*</span></a>log.Logger の他のメソッドが追加されました。もちろん、Loggerにフィールド名を付けることもできますが、そうする必要はありません。そして今、初期化されたら、Jobにロギングすることができます。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">job</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;starting now...&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>LoggerはJob構造体の通常のフィールドなので、このようにJobのコンストラクター内で通常の方法で初期化できます。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">NewJob</span><span class="p">(</span><span class="nx">command</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">logger</span> <span class="o">*</span><span class="nx">log</span><span class="p">.</span><span class="nx">Logger</span><span class="p">)</span> <span class="o">*</span><span class="nx">Job</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="nx">Job</span><span class="p">{</span><span class="nx">command</span><span class="p">,</span> <span class="nx">logger</span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>複合リテラルを使用した場合は以下のとおりです。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">job</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Job</span><span class="p">{</span><span class="nx">command</span><span class="p">,</span> <span class="nx">log</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stderr</span><span class="p">,</span> <span class="s">&quot;Job: &quot;</span><span class="p">,</span> <span class="nx">log</span><span class="p">.</span><span class="nx">Ldate</span><span class="p">)}</span>
</pre></div>
</div>
<p>埋め込みフィールドを直接参照する必要がある場合、フィールドの型名は、パッケージ修飾子を無視して、ReadWriter構造体のReadメソッドと同様にフィールド名として機能します。 ここで、Job変数 <code class="docutils literal notranslate"><span class="pre">job</span></code> の <a href="#id47"><span class="problematic" id="id48">*</span></a>log.Logger にアクセスする必要がある場合、job.Loggerを記述します。これはLoggerのメソッドを拡張したい場合に役立ちます。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="p">(</span><span class="nx">job</span> <span class="o">*</span><span class="nx">Job</span><span class="p">)</span> <span class="nx">Printf</span><span class="p">(</span><span class="nx">format</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">args</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
    <span class="nx">job</span><span class="p">.</span><span class="nx">Logger</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%q: %s&quot;</span><span class="p">,</span> <span class="nx">job</span><span class="p">.</span><span class="nx">Command</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="nx">format</span><span class="p">,</span> <span class="nx">args</span><span class="o">...</span><span class="p">))</span>
<span class="p">}</span>
</pre></div>
</div>
<p>型を埋め込むと、名前の競合の問題が発生しますが、それらを解決するルールは簡単です。 まず、フィールドまたはメソッドXは奥深くにネストされた型のXを隠してしまいます。 log.LoggerにCommandというフィールドまたはメソッドが含まれている場合、JobのCommandフィールドが優先されます。</p>
<p>次に、同じ名前が同じネストレベルにある場合、通常はエラーになります。 Job構造体にLoggerという別のフィールドまたはメソッドが含まれている場合、log.Loggerを埋め込むのは誤りです。 ただし、型定義以外のプログラムから重複した名前が参照されていない場合は、問題になりません。この制限は、外部から埋め込まれた型の変更から元のプログラムを守ります。重複している名前のフィールドが使用されていない場合、競合するフィールドが追加されても問題はありません。</p>
</div>
<div class="section" id="id49">
<h2>並行処理<a class="headerlink" href="#id49" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="id50">
<h3>通信による共有<a class="headerlink" href="#id50" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Concurrent programming is a large topic and there is space only for some
Go-specific highlights here.</p>
<p>Concurrent programming in many environments is made difficult by the
subtleties required to implement correct access to shared variables. Go
encourages a different approach in which shared values are passed around
on channels and, in fact, never actively shared by separate threads of
execution. Only one goroutine has access to the value at any given time.
Data races cannot occur, by design. To encourage this way of thinking we
have reduced it to a slogan:</p>
<blockquote>
<div><p>Do not communicate by sharing memory; instead, share memory by
communicating.</p>
</div></blockquote>
<p>This approach can be taken too far. Reference counts may be best done by
putting a mutex around an integer variable, for instance. But as a
high-level approach, using channels to control access makes it easier to
write clear, correct programs.</p>
<p>One way to think about this model is to consider a typical
single-threaded program running on one CPU. It has no need for
synchronization primitives. Now run another such instance; it too needs
no synchronization. Now let those two communicate; if the communication
is the synchronizer, there's still no need for other synchronization.
Unix pipelines, for example, fit this model perfectly. Although Go's
approach to concurrency originates in Hoare's Communicating Sequential
Processes (CSP), it can also be seen as a type-safe generalization of
Unix pipes.</p>
</div>
<div class="section" id="id51">
<h3>ゴルーチン<a class="headerlink" href="#id51" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>They're called <em>goroutines</em> because the existing terms—threads,
coroutines, processes, and so on—convey inaccurate connotations. A
goroutine has a simple model: it is a function executing concurrently
with other goroutines in the same address space. It is lightweight,
costing little more than the allocation of stack space. And the stacks
start small, so they are cheap, and grow by allocating (and freeing)
heap storage as required.</p>
<p>Goroutines are multiplexed onto multiple OS threads so if one should
block, such as while waiting for I/O, others continue to run. Their
design hides many of the complexities of thread creation and management.</p>
<p>Prefix a function or method call with the <strong>go</strong> keyword to run the call
in a new goroutine. When the call completes, the goroutine exits,
silently. (The effect is similar to the Unix shell's <strong>&amp;</strong> notation for
running a command in the background.)</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="k">go</span> <span class="nx">list</span><span class="p">.</span><span class="nx">Sort</span><span class="p">()</span>  <span class="c1">// run list.Sort concurrently; don&#39;t wait for it.</span>
</pre></div>
</div>
<p>A function literal can be handy in a goroutine invocation.</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">Announce</span><span class="p">(</span><span class="nx">message</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">delay</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">time</span><span class="p">.</span><span class="nx">Sleep</span><span class="p">(</span><span class="nx">delay</span><span class="p">)</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">message</span><span class="p">)</span>
    <span class="p">}()</span>  <span class="c1">// Note the parentheses - must call the function.</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In Go, function literals are closures: the implementation makes sure the
variables referred to by the function survive as long as they are
active.</p>
<p>These examples aren't too practical because the functions have no way of
signaling completion. For that, we need channels.</p>
</div>
<div class="section" id="id52">
<h3>チャンネル<a class="headerlink" href="#id52" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Like maps, channels are allocated with <strong>make</strong>, and the resulting value
acts as a reference to an underlying data structure. If an optional
integer parameter is provided, it sets the buffer size for the channel.
The default is zero, for an unbuffered or synchronous channel.</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">ci</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>            <span class="c1">// unbuffered channel of integers</span>
<span class="nx">cj</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>         <span class="c1">// unbuffered channel of integers</span>
<span class="nx">cs</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="o">*</span><span class="nx">os</span><span class="p">.</span><span class="nx">File</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>  <span class="c1">// buffered channel of pointers to Files</span>
</pre></div>
</div>
<p>Unbuffered channels combine communication—the exchange of a value—with
synchronization—guaranteeing that two calculations (goroutines) are in a
known state.</p>
<p>There are lots of nice idioms using channels. Here's one to get us
started. In the previous section we launched a sort in the background. A
channel can allow the launching goroutine to wait for the sort to
complete.</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">c</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>  <span class="c1">// Allocate a channel.</span>
<span class="c1">// Start the sort in a goroutine; when it completes, signal on the channel.</span>
<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">list</span><span class="p">.</span><span class="nx">Sort</span><span class="p">()</span>
    <span class="nx">c</span> <span class="o">&lt;-</span> <span class="mi">1</span>  <span class="c1">// Send a signal; value does not matter.</span>
<span class="p">}()</span>
<span class="nx">doSomethingForAWhile</span><span class="p">()</span>
<span class="o">&lt;-</span><span class="nx">c</span>   <span class="c1">// Wait for sort to finish; discard sent value.</span>
</pre></div>
</div>
<p>Receivers always block until there is data to receive. If the channel is
unbuffered, the sender blocks until the receiver has received the value.
If the channel has a buffer, the sender blocks only until the value has
been copied to the buffer; if the buffer is full, this means waiting
until some receiver has retrieved a value.</p>
<p>A buffered channel can be used like a semaphore, for instance to limit
throughput. In this example, incoming requests are passed to <strong>handle</strong>,
which sends a value into the channel, processes the request, and then
receives a value from the channel to ready the “semaphore” for the next
consumer. The capacity of the channel buffer limits the number of
simultaneous calls to <strong>process</strong>.</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">sem</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">MaxOutstanding</span><span class="p">)</span>

<span class="kd">func</span> <span class="nx">handle</span><span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">sem</span> <span class="o">&lt;-</span> <span class="mi">1</span>    <span class="c1">// Wait for active queue to drain.</span>
    <span class="nx">process</span><span class="p">(</span><span class="nx">r</span><span class="p">)</span>  <span class="c1">// May take a long time.</span>
    <span class="o">&lt;-</span><span class="nx">sem</span>       <span class="c1">// Done; enable next request to run.</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">Serve</span><span class="p">(</span><span class="nx">queue</span> <span class="kd">chan</span> <span class="o">*</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">{</span>
        <span class="nx">req</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">queue</span>
        <span class="k">go</span> <span class="nx">handle</span><span class="p">(</span><span class="nx">req</span><span class="p">)</span>  <span class="c1">// Don&#39;t wait for handle to finish.</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Once <strong>MaxOutstanding</strong> handlers are executing <strong>process</strong>, any more
will block trying to send into the filled channel buffer, until one of
the existing handlers finishes and receives from the buffer.</p>
<p>This design has a problem, though: <strong>Serve</strong> creates a new goroutine for
every incoming request, even though only <strong>MaxOutstanding</strong> of them can
run at any moment. As a result, the program can consume unlimited
resources if the requests come in too fast. We can address that
deficiency by changing <strong>Serve</strong> to gate the creation of the goroutines.
Here's an obvious solution, but beware it has a bug we'll fix
subsequently:</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">Serve</span><span class="p">(</span><span class="nx">queue</span> <span class="kd">chan</span> <span class="o">*</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">req</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">queue</span> <span class="p">{</span>
        <span class="nx">sem</span> <span class="o">&lt;-</span> <span class="mi">1</span>
        <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
            <span class="nx">process</span><span class="p">(</span><span class="nx">req</span><span class="p">)</span> <span class="c1">// Buggy; see explanation below.</span>
            <span class="o">&lt;-</span><span class="nx">sem</span>
        <span class="p">}()</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The bug is that in a Go <strong>for</strong> loop, the loop variable is reused for
each iteration, so the <strong>req</strong> variable is shared across all goroutines.
That's not what we want. We need to make sure that <strong>req</strong> is unique for
each goroutine. Here's one way to do that, passing the value of <strong>req</strong>
as an argument to the closure in the goroutine:</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">Serve</span><span class="p">(</span><span class="nx">queue</span> <span class="kd">chan</span> <span class="o">*</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">req</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">queue</span> <span class="p">{</span>
        <span class="nx">sem</span> <span class="o">&lt;-</span> <span class="mi">1</span>
        <span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">req</span> <span class="o">*</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">process</span><span class="p">(</span><span class="nx">req</span><span class="p">)</span>
            <span class="o">&lt;-</span><span class="nx">sem</span>
        <span class="p">}(</span><span class="nx">req</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Compare this version with the previous to see the difference in how the
closure is declared and run. Another solution is just to create a new
variable with the same name, as in this example:</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">Serve</span><span class="p">(</span><span class="nx">queue</span> <span class="kd">chan</span> <span class="o">*</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">req</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">queue</span> <span class="p">{</span>
        <span class="nx">req</span> <span class="o">:=</span> <span class="nx">req</span> <span class="c1">// Create new instance of req for the goroutine.</span>
        <span class="nx">sem</span> <span class="o">&lt;-</span> <span class="mi">1</span>
        <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
            <span class="nx">process</span><span class="p">(</span><span class="nx">req</span><span class="p">)</span>
            <span class="o">&lt;-</span><span class="nx">sem</span>
        <span class="p">}()</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>It may seem odd to write</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">req</span> <span class="o">:=</span> <span class="nx">req</span>
</pre></div>
</div>
<p>but it's legal and idiomatic in Go to do this. You get a fresh version
of the variable with the same name, deliberately shadowing the loop
variable locally but unique to each goroutine.</p>
<p>Going back to the general problem of writing the server, another
approach that manages resources well is to start a fixed number of
<strong>handle</strong> goroutines all reading from the request channel. The number
of goroutines limits the number of simultaneous calls to <strong>process</strong>.
This <strong>Serve</strong> function also accepts a channel on which it will be told
to exit; after launching the goroutines it blocks receiving from that
channel.</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">handle</span><span class="p">(</span><span class="nx">queue</span> <span class="kd">chan</span> <span class="o">*</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">r</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">queue</span> <span class="p">{</span>
        <span class="nx">process</span><span class="p">(</span><span class="nx">r</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">Serve</span><span class="p">(</span><span class="nx">clientRequests</span> <span class="kd">chan</span> <span class="o">*</span><span class="nx">Request</span><span class="p">,</span> <span class="nx">quit</span> <span class="kd">chan</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Start handlers</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">MaxOutstanding</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="k">go</span> <span class="nx">handle</span><span class="p">(</span><span class="nx">clientRequests</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="o">&lt;-</span><span class="nx">quit</span>  <span class="c1">// Wait to be told to exit.</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="channels-of-channels">
<span id="chan-of-chan"></span><h3>Channels of channels<a class="headerlink" href="#channels-of-channels" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>One of the most important properties of Go is that a channel is a
first-class value that can be allocated and passed around like any
other. A common use of this property is to implement safe, parallel
demultiplexing.</p>
<p>In the example in the previous section, <strong>handle</strong> was an idealized
handler for a request but we didn't define the type it was handling. If
that type includes a channel on which to reply, each client can provide
its own path for the answer. Here's a schematic definition of type
<strong>Request</strong>.</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">Request</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">args</span>        <span class="p">[]</span><span class="kt">int</span>
    <span class="nx">f</span>           <span class="kd">func</span><span class="p">([]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span>
    <span class="nx">resultChan</span>  <span class="kd">chan</span> <span class="kt">int</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The client provides a function and its arguments, as well as a channel
inside the request object on which to receive the answer.</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">sum</span><span class="p">(</span><span class="nx">a</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="nx">s</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">a</span> <span class="p">{</span>
        <span class="nx">s</span> <span class="o">+=</span> <span class="nx">v</span>
    <span class="p">}</span>
    <span class="k">return</span>
<span class="p">}</span>

<span class="nx">request</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Request</span><span class="p">{[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">},</span> <span class="nx">sum</span><span class="p">,</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)}</span>
<span class="c1">// Send request</span>
<span class="nx">clientRequests</span> <span class="o">&lt;-</span> <span class="nx">request</span>
<span class="c1">// Wait for response.</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;answer: %d\n&quot;</span><span class="p">,</span> <span class="o">&lt;-</span><span class="nx">request</span><span class="p">.</span><span class="nx">resultChan</span><span class="p">)</span>
</pre></div>
</div>
<p>On the server side, the handler function is the only thing that changes.</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">handle</span><span class="p">(</span><span class="nx">queue</span> <span class="kd">chan</span> <span class="o">*</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">req</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">queue</span> <span class="p">{</span>
        <span class="nx">req</span><span class="p">.</span><span class="nx">resultChan</span> <span class="o">&lt;-</span> <span class="nx">req</span><span class="p">.</span><span class="nx">f</span><span class="p">(</span><span class="nx">req</span><span class="p">.</span><span class="nx">args</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>There's clearly a lot more to do to make it realistic, but this code is
a framework for a rate-limited, parallel, non-blocking RPC system, and
there's not a mutex in sight.</p>
</div>
<div class="section" id="parallelization">
<span id="parallel"></span><h3>Parallelization<a class="headerlink" href="#parallelization" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Another application of these ideas is to parallelize a calculation
across multiple CPU cores. If the calculation can be broken into
separate pieces that can execute independently, it can be parallelized,
with a channel to signal when each piece completes.</p>
<p>Let's say we have an expensive operation to perform on a vector of
items, and that the value of the operation on each item is independent,
as in this idealized example.</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">Vector</span> <span class="p">[]</span><span class="kt">float64</span>

<span class="c1">// Apply the operation to v[i], v[i+1] ... up to v[n-1].</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="nx">Vector</span><span class="p">)</span> <span class="nx">DoSome</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">u</span> <span class="nx">Vector</span><span class="p">,</span> <span class="nx">c</span> <span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="nx">v</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">+=</span> <span class="nx">u</span><span class="p">.</span><span class="nx">Op</span><span class="p">(</span><span class="nx">v</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
    <span class="p">}</span>
    <span class="nx">c</span> <span class="o">&lt;-</span> <span class="mi">1</span>    <span class="c1">// signal that this piece is done</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We launch the pieces independently in a loop, one per CPU. They can
complete in any order but it doesn't matter; we just count the
completion signals by draining the channel after launching all the
goroutines.</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">const</span> <span class="nx">numCPU</span> <span class="p">=</span> <span class="mi">4</span> <span class="c1">// number of CPU cores</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="nx">Vector</span><span class="p">)</span> <span class="nx">DoAll</span><span class="p">(</span><span class="nx">u</span> <span class="nx">Vector</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">c</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">numCPU</span><span class="p">)</span>  <span class="c1">// Buffering optional but sensible.</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">numCPU</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="k">go</span> <span class="nx">v</span><span class="p">.</span><span class="nx">DoSome</span><span class="p">(</span><span class="nx">i</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span><span class="o">/</span><span class="nx">numCPU</span><span class="p">,</span> <span class="p">(</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span><span class="o">/</span><span class="nx">numCPU</span><span class="p">,</span> <span class="nx">u</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="c1">// Drain the channel.</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">numCPU</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="o">&lt;-</span><span class="nx">c</span>    <span class="c1">// wait for one task to complete</span>
    <span class="p">}</span>
    <span class="c1">// All done.</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Rather than create a constant value for numCPU, we can ask the runtime
what value is appropriate. The function <strong>runtime.NumCPU</strong> returns the
number of hardware CPU cores in the machine, so we could write</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">numCPU</span> <span class="p">=</span> <span class="nx">runtime</span><span class="p">.</span><span class="nx">NumCPU</span><span class="p">()</span>
</pre></div>
</div>
<p>There is also a function <strong>runtime.GOMAXPROCS</strong>, which reports (or sets)
the user-specified number of cores that a Go program can have running
simultaneously. It defaults to the value of <strong>runtime.NumCPU</strong> but can
be overridden by setting the similarly named shell environment variable
or by calling the function with a positive number. Calling it with zero
just queries the value. Therefore if we want to honor the user's
resource request, we should write</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">numCPU</span> <span class="p">=</span> <span class="nx">runtime</span><span class="p">.</span><span class="nx">GOMAXPROCS</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>Be sure not to confuse the ideas of concurrency—structuring a program as
independently executing components—and parallelism—executing
calculations in parallel for efficiency on multiple CPUs. Although the
concurrency features of Go can make some problems easy to structure as
parallel computations, Go is a concurrent language, not a parallel one,
and not all parallelization problems fit Go's model. For a discussion of
the distinction, see the talk cited in <a class="reference external" href="//blog.golang.org/2013/01/concurrency-is-not-parallelism.html">this blog
post</a>.</p>
</div>
<div class="section" id="a-leaky-buffer">
<span id="leaky-buffer"></span><h3>A leaky buffer<a class="headerlink" href="#a-leaky-buffer" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>The tools of concurrent programming can even make non-concurrent ideas
easier to express. Here's an example abstracted from an RPC package. The
client goroutine loops receiving data from some source, perhaps a
network. To avoid allocating and freeing buffers, it keeps a free list,
and uses a buffered channel to represent it. If the channel is empty, a
new buffer gets allocated. Once the message buffer is ready, it's sent
to the server on <strong>serverChan</strong>.</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">freeList</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="o">*</span><span class="nx">Buffer</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="kd">var</span> <span class="nx">serverChan</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="o">*</span><span class="nx">Buffer</span><span class="p">)</span>

<span class="kd">func</span> <span class="nx">client</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">b</span> <span class="o">*</span><span class="nx">Buffer</span>
        <span class="c1">// Grab a buffer if available; allocate if not.</span>
        <span class="k">select</span> <span class="p">{</span>
        <span class="k">case</span> <span class="nx">b</span> <span class="p">=</span> <span class="o">&lt;-</span><span class="nx">freeList</span><span class="p">:</span>
            <span class="c1">// Got one; nothing more to do.</span>
        <span class="k">default</span><span class="p">:</span>
            <span class="c1">// None free, so allocate a new one.</span>
            <span class="nx">b</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">Buffer</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="nx">load</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span>              <span class="c1">// Read next message from the net.</span>
        <span class="nx">serverChan</span> <span class="o">&lt;-</span> <span class="nx">b</span>      <span class="c1">// Send to server.</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The server loop receives each message from the client, processes it, and
returns the buffer to the free list.</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">server</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">{</span>
        <span class="nx">b</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">serverChan</span>    <span class="c1">// Wait for work.</span>
        <span class="nx">process</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span>
        <span class="c1">// Reuse buffer if there&#39;s room.</span>
        <span class="k">select</span> <span class="p">{</span>
        <span class="k">case</span> <span class="nx">freeList</span> <span class="o">&lt;-</span> <span class="nx">b</span><span class="p">:</span>
            <span class="c1">// Buffer on free list; nothing more to do.</span>
        <span class="k">default</span><span class="p">:</span>
            <span class="c1">// Free list full, just carry on.</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The client attempts to retrieve a buffer from <strong>freeList</strong>; if none is
available, it allocates a fresh one. The server's send to <strong>freeList</strong>
puts <strong>b</strong> back on the free list unless the list is full, in which case
the buffer is dropped on the floor to be reclaimed by the garbage
collector. (The <strong>default</strong> clauses in the <strong>select</strong> statements execute
when no other case is ready, meaning that the <strong>selects</strong> never block.)
This implementation builds a leaky bucket free list in just a few lines,
relying on the buffered channel and the garbage collector for
bookkeeping.</p>
</div>
</div>
<div class="section" id="id53">
<h2>エラー<a class="headerlink" href="#id53" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>多くの場合、ライブラリルーチンは、呼び出し元に何らかのエラー表示を返す必要があります。 前述のとおり、Goは複数の値を返すことができるため、通常の戻り値とともに詳細なエラーの説明を簡単に返すことができます。この特徴を使用して詳細なエラー情報を提供するのは良いスタイルです。 たとえば、後で説明するように、 <code class="docutils literal notranslate"><span class="pre">os.Open</span></code> は失敗した場合にnilポインターを返すだけでなく、エラーの内容を示すエラー値も返します。</p>
<p>Goでは慣例としてエラーはシンプルなビルトインインターフェースである <code class="docutils literal notranslate"><span class="pre">error</span></code> インターフェース型を持つことになっています。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="kt">error</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nx">Error</span><span class="p">()</span> <span class="kt">string</span>
<span class="p">}</span>
</pre></div>
</div>
<p>ライブラリの作成者は、このインターフェースをより情報に富んだモデルを用いて、自由に実装できます。エラーを確認できるだけでなく、コンテキストを提供することもできます。前述のように、通常の <code class="docutils literal notranslate"><span class="pre">*os.File</span></code> の戻り値とともに <code class="docutils literal notranslate"><span class="pre">os.Open</span></code> はエラー値も返します。ファイルが正常に開かれた場合、エラーは <code class="docutils literal notranslate"><span class="pre">nil</span></code> になりますが、問題がある場合は <code class="docutils literal notranslate"><span class="pre">os.PathError</span></code> を保持します。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// PathError records an error and the operation and</span>
<span class="c1">// file path that caused it.</span>
<span class="kd">type</span> <span class="nx">PathError</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Op</span> <span class="kt">string</span>    <span class="c1">// &quot;open&quot;, &quot;unlink&quot;, etc.</span>
    <span class="nx">Path</span> <span class="kt">string</span>  <span class="c1">// The associated file.</span>
    <span class="nx">Err</span> <span class="kt">error</span>    <span class="c1">// Returned by the system call.</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">PathError</span><span class="p">)</span> <span class="nx">Error</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">e</span><span class="p">.</span><span class="nx">Op</span> <span class="o">+</span> <span class="s">&quot; &quot;</span> <span class="o">+</span> <span class="nx">e</span><span class="p">.</span><span class="nx">Path</span> <span class="o">+</span> <span class="s">&quot;: &quot;</span> <span class="o">+</span> <span class="nx">e</span><span class="p">.</span><span class="nx">Err</span><span class="p">.</span><span class="nx">Error</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">PathError</span></code> の <code class="docutils literal notranslate"><span class="pre">Error</span></code> は、次のような文字列を生成します。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">open</span> <span class="o">/</span><span class="nx">etc</span><span class="o">/</span><span class="nx">passwx</span><span class="p">:</span> <span class="nx">no</span> <span class="nx">such</span> <span class="nx">file</span> <span class="nx">or</span> <span class="nx">directory</span>
</pre></div>
</div>
<p>呼び出された問題のあるファイル名、操作、およびオペレーティングシステムエラーを含むこのようなエラーは、ライブラリのエラーが発生した場所から関係の薄い場所から呼び出されて表示された場合でも有益です。単純な「 <code class="docutils literal notranslate"><span class="pre">no</span> <span class="pre">such</span> <span class="pre">file</span> <span class="pre">or</span> <span class="pre">directory</span></code> 」よりもはるかに有益です。</p>
<p>できるかぎり、エラーの文字列は、その発生元を識別する必要があるため、エラーを引き起こした操作またはパッケージにプレフィックスを付けるなどをすることを推奨します。たとえば、<code class="docutils literal notranslate"><span class="pre">image</span></code> パッケージでは、不明な形式によるデコードエラーを表す文字列は「 <code class="docutils literal notranslate"><span class="pre">image：</span> <span class="pre">unknown</span> <span class="pre">format</span></code> 」です。</p>
<p>呼び出し元から、エラーの詳細を詳しく知りたい場合は、型スイッチまたは型アサーションを使用して、特定のエラーを探し、詳細を抽出できます。 <code class="docutils literal notranslate"><span class="pre">PathErrors</span></code> の場合、エラーから回復するために内部の <code class="docutils literal notranslate"><span class="pre">Err</span></code> フィールドを調べることができます。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="nx">try</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">try</span> <span class="p">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="nx">try</span><span class="o">++</span> <span class="p">{</span>
    <span class="nx">file</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Create</span><span class="p">(</span><span class="nx">filename</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">e</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">err</span><span class="p">.(</span><span class="o">*</span><span class="nx">os</span><span class="p">.</span><span class="nx">PathError</span><span class="p">);</span> <span class="nx">ok</span> <span class="o">&amp;&amp;</span> <span class="nx">e</span><span class="p">.</span><span class="nx">Err</span> <span class="o">==</span> <span class="nx">syscall</span><span class="p">.</span><span class="nx">ENOSPC</span> <span class="p">{</span>
        <span class="nx">deleteTempFiles</span><span class="p">()</span>  <span class="c1">// Recover some space.</span>
        <span class="k">continue</span>
    <span class="p">}</span>
    <span class="k">return</span>
<span class="p">}</span>
</pre></div>
</div>
<p>ここの2番目の <code class="docutils literal notranslate"><span class="pre">if</span></code> ステートメントは別の型アサーションです。 失敗した場合 <code class="docutils literal notranslate"><span class="pre">ok</span></code> は <code class="docutils literal notranslate"><span class="pre">false</span></code> になり、<code class="docutils literal notranslate"><span class="pre">e</span></code> は <code class="docutils literal notranslate"><span class="pre">nil</span></code> になります。 成功した場合、 <code class="docutils literal notranslate"><span class="pre">ok</span></code> は <code class="docutils literal notranslate"><span class="pre">true</span></code> になります。これは、エラーのタイプが <code class="docutils literal notranslate"><span class="pre">*os.PathError</span></code> であったことを意味し、続いて <code class="docutils literal notranslate"><span class="pre">e</span></code> もエラーの詳細について調べることができます。</p>
<div class="section" id="panic">
<h3>Panic<a class="headerlink" href="#panic" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>The usual way to report an error to a caller is to return an <strong>error</strong>
as an extra return value. The canonical <strong>Read</strong> method is a well-known
instance; it returns a byte count and an <strong>error</strong>. But what if the
error is unrecoverable? Sometimes the program simply cannot continue.</p>
<p>For this purpose, there is a built-in function <strong>panic</strong> that in effect
creates a run-time error that will stop the program (but see the next
section). The function takes a single argument of arbitrary type—often a
string—to be printed as the program dies. It's also a way to indicate
that something impossible has happened, such as exiting an infinite
loop.</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// A toy implementation of cube root using Newton&#39;s method.</span>
<span class="kd">func</span> <span class="nx">CubeRoot</span><span class="p">(</span><span class="nx">x</span> <span class="kt">float64</span><span class="p">)</span> <span class="kt">float64</span> <span class="p">{</span>
    <span class="nx">z</span> <span class="o">:=</span> <span class="nx">x</span><span class="o">/</span><span class="mi">3</span>   <span class="c1">// Arbitrary initial value</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mf">1e6</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="nx">prevz</span> <span class="o">:=</span> <span class="nx">z</span>
        <span class="nx">z</span> <span class="o">-=</span> <span class="p">(</span><span class="nx">z</span><span class="o">*</span><span class="nx">z</span><span class="o">*</span><span class="nx">z</span><span class="o">-</span><span class="nx">x</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="nx">z</span><span class="o">*</span><span class="nx">z</span><span class="p">)</span>
        <span class="k">if</span> <span class="nx">veryClose</span><span class="p">(</span><span class="nx">z</span><span class="p">,</span> <span class="nx">prevz</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">z</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// A million iterations has not converged; something is wrong.</span>
    <span class="nb">panic</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&quot;CubeRoot(%g) did not converge&quot;</span><span class="p">,</span> <span class="nx">x</span><span class="p">))</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This is only an example but real library functions should avoid
<strong>panic</strong>. If the problem can be masked or worked around, it's always
better to let things continue to run rather than taking down the whole
program. One possible counterexample is during initialization: if the
library truly cannot set itself up, it might be reasonable to panic, so
to speak.</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">user</span> <span class="p">=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Getenv</span><span class="p">(</span><span class="s">&quot;USER&quot;</span><span class="p">)</span>

<span class="kd">func</span> <span class="nx">init</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">user</span> <span class="o">==</span> <span class="s">&quot;&quot;</span> <span class="p">{</span>
        <span class="nb">panic</span><span class="p">(</span><span class="s">&quot;no value for $USER&quot;</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="recover">
<h3>Recover<a class="headerlink" href="#recover" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>When <strong>panic</strong> is called, including implicitly for run-time errors such
as indexing a slice out of bounds or failing a type assertion, it
immediately stops execution of the current function and begins unwinding
the stack of the goroutine, running any deferred functions along the
way. If that unwinding reaches the top of the goroutine's stack, the
program dies. However, it is possible to use the built-in function
<strong>recover</strong> to regain control of the goroutine and resume normal
execution.</p>
<p>A call to <strong>recover</strong> stops the unwinding and returns the argument
passed to <strong>panic</strong>. Because the only code that runs while unwinding is
inside deferred functions, <strong>recover</strong> is only useful inside deferred
functions.</p>
<p>One application of <strong>recover</strong> is to shut down a failing goroutine
inside a server without killing the other executing goroutines.</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">server</span><span class="p">(</span><span class="nx">workChan</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="o">*</span><span class="nx">Work</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">work</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">workChan</span> <span class="p">{</span>
        <span class="k">go</span> <span class="nx">safelyDo</span><span class="p">(</span><span class="nx">work</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">safelyDo</span><span class="p">(</span><span class="nx">work</span> <span class="o">*</span><span class="nx">Work</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nb">recover</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="nx">log</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;work failed:&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}()</span>
    <span class="nx">do</span><span class="p">(</span><span class="nx">work</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In this example, if <strong>do(work)</strong> panics, the result will be logged and
the goroutine will exit cleanly without disturbing the others. There's
no need to do anything else in the deferred closure; calling <strong>recover</strong>
handles the condition completely.</p>
<p>Because <strong>recover</strong> always returns <strong>nil</strong> unless called directly from a
deferred function, deferred code can call library routines that
themselves use <strong>panic</strong> and <strong>recover</strong> without failing. As an example,
the deferred function in <strong>safelyDo</strong> might call a logging function
before calling <strong>recover</strong>, and that logging code would run unaffected
by the panicking state.</p>
<p>With our recovery pattern in place, the <strong>do</strong> function (and anything it
calls) can get out of any bad situation cleanly by calling <strong>panic</strong>. We
can use that idea to simplify error handling in complex software. Let's
look at an idealized version of a <strong>regexp</strong> package, which reports
parsing errors by calling <strong>panic</strong> with a local error type. Here's the
definition of <strong>Error</strong>, an <strong>error</strong> method, and the <strong>Compile</strong>
function.</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// Error is the type of a parse error; it satisfies the error interface.</span>
<span class="kd">type</span> <span class="nx">Error</span> <span class="kt">string</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">e</span> <span class="nx">Error</span><span class="p">)</span> <span class="nx">Error</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">string</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// error is a method of *Regexp that reports parsing errors by</span>
<span class="c1">// panicking with an Error.</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">regexp</span> <span class="o">*</span><span class="nx">Regexp</span><span class="p">)</span> <span class="nb">error</span><span class="p">(</span><span class="nx">err</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">panic</span><span class="p">(</span><span class="nx">Error</span><span class="p">(</span><span class="nx">err</span><span class="p">))</span>
<span class="p">}</span>

<span class="c1">// Compile returns a parsed representation of the regular expression.</span>
<span class="kd">func</span> <span class="nx">Compile</span><span class="p">(</span><span class="nx">str</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">regexp</span> <span class="o">*</span><span class="nx">Regexp</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">regexp</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">Regexp</span><span class="p">)</span>
    <span class="c1">// doParse will panic if there is a parse error.</span>
    <span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">e</span> <span class="o">:=</span> <span class="nb">recover</span><span class="p">();</span> <span class="nx">e</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="nx">regexp</span> <span class="p">=</span> <span class="kc">nil</span>    <span class="c1">// Clear return value.</span>
            <span class="nx">err</span> <span class="p">=</span> <span class="nx">e</span><span class="p">.(</span><span class="nx">Error</span><span class="p">)</span> <span class="c1">// Will re-panic if not a parse error.</span>
        <span class="p">}</span>
    <span class="p">}()</span>
    <span class="k">return</span> <span class="nx">regexp</span><span class="p">.</span><span class="nx">doParse</span><span class="p">(</span><span class="nx">str</span><span class="p">),</span> <span class="kc">nil</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If <strong>doParse</strong> panics, the recovery block will set the return value to
<strong>nil</strong>—deferred functions can modify named return values. It will then
check, in the assignment to <strong>err</strong>, that the problem was a parse error
by asserting that it has the local type <strong>Error</strong>. If it does not, the
type assertion will fail, causing a run-time error that continues the
stack unwinding as though nothing had interrupted it. This check means
that if something unexpected happens, such as an index out of bounds,
the code will fail even though we are using <strong>panic</strong> and <strong>recover</strong> to
handle parse errors.</p>
<p>With error handling in place, the <strong>error</strong> method (because it's a
method bound to a type, it's fine, even natural, for it to have the same
name as the builtin <strong>error</strong> type) makes it easy to report parse errors
without worrying about unwinding the parse stack by hand:</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="nx">pos</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="nx">re</span><span class="p">.</span><span class="nb">error</span><span class="p">(</span><span class="s">&quot;&#39;*&#39; illegal at start of expression&quot;</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Useful though this pattern is, it should be used only within a package.
<strong>Parse</strong> turns its internal <strong>panic</strong> calls into <strong>error</strong> values; it
does not expose <strong>panics</strong> to its client. That is a good rule to follow.</p>
<p>By the way, this re-panic idiom changes the panic value if an actual
error occurs. However, both the original and new failures will be
presented in the crash report, so the root cause of the problem will
still be visible. Thus this simple re-panic approach is usually
sufficient—it's a crash after all—but if you want to display only the
original value, you can write a little more code to filter unexpected
problems and re-panic with the original error. That's left as an
exercise for the reader.</p>
</div>
</div>
<div class="section" id="web">
<span id="web-server"></span><h2>Webサーバー<a class="headerlink" href="#web" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>完全なGoのプログラムであるWebサーバを仕上げて終わりにしましょう。これは実際には一種の中継サーバです。Googleは <strong>chart.apis.google.com</strong> としてデータをチャートおよびグラフに自動的にフォーマットするサービスを提供しています。ただし、データをクエリとしてURLに送信する必要があるため、インタラクティブに使用することは困難です。ここでのプログラムはデータの1形式へのよりよいインターフェースを提供します。短いテキストを与えると、チャートサーバを呼び出し、テキストをエンコードする二次元のQRコードを生成します。その画像を携帯電話のカメラで取得して、たとえばURLとして解釈し、携帯電話の小さなキーボードにURLを入力する手間を省くことができます。</p>
<p>ここに完全なプログラムがあります。以下に従って説明します。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// Copyright 2009 The Go Authors. All rights reserved.</span>
<span class="c1">// Use of this source code is governed by a BSD-style</span>
<span class="c1">// license that can be found in the LICENSE file.</span>

<span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&quot;flag&quot;</span>
	<span class="s">&quot;html/template&quot;</span>
	<span class="s">&quot;log&quot;</span>
	<span class="s">&quot;net/http&quot;</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="nx">addr</span> <span class="p">=</span> <span class="nx">flag</span><span class="p">.</span><span class="nx">String</span><span class="p">(</span><span class="s">&quot;addr&quot;</span><span class="p">,</span> <span class="s">&quot;:1718&quot;</span><span class="p">,</span> <span class="s">&quot;http service address&quot;</span><span class="p">)</span> <span class="c1">// Q=17, R=18</span>

<span class="kd">var</span> <span class="nx">templ</span> <span class="p">=</span> <span class="nx">template</span><span class="p">.</span><span class="nx">Must</span><span class="p">(</span><span class="nx">template</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="s">&quot;qr&quot;</span><span class="p">).</span><span class="nx">Parse</span><span class="p">(</span><span class="nx">templateStr</span><span class="p">))</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">flag</span><span class="p">.</span><span class="nx">Parse</span><span class="p">()</span>
	<span class="nx">http</span><span class="p">.</span><span class="nx">Handle</span><span class="p">(</span><span class="s">&quot;/&quot;</span><span class="p">,</span> <span class="nx">http</span><span class="p">.</span><span class="nx">HandlerFunc</span><span class="p">(</span><span class="nx">QR</span><span class="p">))</span>
	<span class="nx">err</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ListenAndServe</span><span class="p">(</span><span class="o">*</span><span class="nx">addr</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">log</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="s">&quot;ListenAndServe:&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">QR</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">req</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">templ</span><span class="p">.</span><span class="nx">Execute</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="nx">req</span><span class="p">.</span><span class="nx">FormValue</span><span class="p">(</span><span class="s">&quot;s&quot;</span><span class="p">))</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">templateStr</span> <span class="p">=</span> <span class="s">`</span>
<span class="s">&lt;html&gt;</span>
<span class="s">&lt;head&gt;</span>
<span class="s">&lt;title&gt;QR Link Generator&lt;/title&gt;</span>
<span class="s">&lt;/head&gt;</span>
<span class="s">&lt;body&gt;</span>
<span class="s">{{if .}}</span>
<span class="s">&lt;img src=&quot;http://chart.apis.google.com/chart?chs=300x300&amp;cht=qr&amp;choe=UTF-8&amp;chl={{.}}&quot; /&gt;</span>
<span class="s">&lt;br&gt;</span>
<span class="s">{{.}}</span>
<span class="s">&lt;br&gt;</span>
<span class="s">&lt;br&gt;</span>
<span class="s">{{end}}</span>
<span class="s">&lt;form action=&quot;/&quot; name=f method=&quot;GET&quot;&gt;</span>
<span class="s">	&lt;input maxLength=1024 size=70 name=s value=&quot;&quot; title=&quot;Text to QR Encode&quot;&gt;</span>
<span class="s">	&lt;input type=submit value=&quot;Show QR&quot; name=qr&gt;</span>
<span class="s">&lt;/form&gt;</span>
<span class="s">&lt;/body&gt;</span>
<span class="s">&lt;/html&gt;</span>
<span class="s">`</span>
</pre></div>
</div>
<p>mainまでの部分は簡単に理解できるはずです。 1つのフラグは、サーバーのデフォルトHTTPポートを設定します。 テンプレート変数templは、面白いことが起こる場所です。 ページを表示するためにサーバーによって実行されるHTMLテンプレートを作成します。 それについてはすぐに説明します。</p>
<p>メイン関数はフラグを解析し、上で説明したメカニズムを使用して、関数 <strong>QR</strong> をサーバーのルートパスにバインドします。 次に、サーバーを起動するために <strong>http.ListenAndServe</strong> が呼び出されます。 サーバーの実行中はブロックされます。</p>
<p><strong>QR</strong> はフォームデータを含むリクエストを受信し、 <strong>s</strong> という名前のフォーム値のデータに対してテンプレートを実行します。</p>
<p>テンプレートパッケージ <strong>html/template</strong> は強力です。 このプログラムは、その機能に触れています。 本質的に、 <strong>templ.Execute</strong> に渡されるデータ項目(この場合はフォーム値)から派生した要素を置き換えることにより、HTMLテキストを即座に書き換えます。 テンプレートテキスト(templateStr)内で、二重括弧で区切られた部分はテンプレートアクションを示します。 <strong>{{if .}}</strong> から <strong>{{end}}</strong> の部分は、<strong>.</strong> と呼ばれる現在のデータ項目が空でない場合のみ実行されます。つまり、文字列が空の場合、テンプレートのこの部分は抑制されます。</p>
<p>2つのスニペット <strong>{{.}}</strong> は、テンプレートに提示されたデータ(クエリ文字列)をWebページに表示することを示しています。 HTMLテンプレートパッケージは、適切なエスケープを自動的に提供するため、テキストを安全に表示できます。</p>
<p>テンプレート文字列の残りの部分は、ページが読み込まれたときに表示するHTMLです。 説明が速すぎる場合は、テンプレートパッケージの <a class="reference external" href="https://golang.org/pkg/html/template/">ドキュメント</a> で詳細を確認してください。</p>
<p>数行のコードといくつかのデータ駆動型HTMLテキストの便利なWebサーバーをあなたは持っています。 Goは、数行で多くのことを実行できるほど強力です。</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">目次</a></h3>
  <ul>
<li><a class="reference internal" href="#">Effective Go</a><ul>
<li><a class="reference internal" href="#id1">イントロダクション</a><ul>
<li><a class="reference internal" href="#id3">例</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id5">フォーマット</a></li>
<li><a class="reference internal" href="#id6">コメント</a></li>
<li><a class="reference internal" href="#id7">命名</a><ul>
<li><a class="reference internal" href="#id8">パッケージ名</a></li>
<li><a class="reference internal" href="#id9">ゲッター</a></li>
<li><a class="reference internal" href="#id10">インターフェース名</a></li>
<li><a class="reference internal" href="#mixedcaps">MixedCaps</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id11">セミコロン</a></li>
<li><a class="reference internal" href="#control-structures">制御構造(Control structures)</a><ul>
<li><a class="reference internal" href="#if">If</a></li>
<li><a class="reference internal" href="#redeclaration">再宣言と再割り当て</a></li>
<li><a class="reference internal" href="#for">For</a></li>
<li><a class="reference internal" href="#switch">Switch</a></li>
<li><a class="reference internal" href="#type-switch">型の switch</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id15">関数</a><ul>
<li><a class="reference internal" href="#multiple-returns">複数の戻り値</a></li>
<li><a class="reference internal" href="#id17">名前付けされた戻り値</a></li>
<li><a class="reference internal" href="#defer">Defer</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id18">データ</a><ul>
<li><a class="reference internal" href="#new"><strong>new</strong> によるアロケーション</a></li>
<li><a class="reference internal" href="#id19">コンストラクタと複合リテラル</a></li>
<li><a class="reference internal" href="#make"><strong>make</strong> によるアロケーション</a></li>
<li><a class="reference internal" href="#id20">配列</a></li>
<li><a class="reference internal" href="#id21">スライス</a></li>
<li><a class="reference internal" href="#id22">二次元スライス</a></li>
<li><a class="reference internal" href="#id23">マップ</a></li>
<li><a class="reference internal" href="#id25">プリント</a></li>
<li><a class="reference internal" href="#append">Append</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id27">初期化</a><ul>
<li><a class="reference internal" href="#id28">定数</a></li>
<li><a class="reference internal" href="#id29">変数</a></li>
<li><a class="reference internal" href="#init">init関数</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id30">メソッド</a><ul>
<li><a class="reference internal" href="#id31">ポインター vs 値</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id32">インターフェースとその他の型</a><ul>
<li><a class="reference internal" href="#id33">インターフェース</a></li>
<li><a class="reference internal" href="#id34">変換</a></li>
<li><a class="reference internal" href="#id35">インターフェースの変換と型アサーション</a></li>
<li><a class="reference internal" href="#id36">概説</a></li>
<li><a class="reference internal" href="#id38">インターフェースとメソッド</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id39">ブランク識別子</a><ul>
<li><a class="reference internal" href="#id40">いろいろな場所におけるブランク識別子</a></li>
<li><a class="reference internal" href="#id41">未使用のインポートと変数</a></li>
<li><a class="reference internal" href="#id42">インポートの副作用</a></li>
<li><a class="reference internal" href="#id43">インターフェースのチェック</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id44">埋め込み</a></li>
<li><a class="reference internal" href="#id49">並行処理</a><ul>
<li><a class="reference internal" href="#id50">通信による共有</a></li>
<li><a class="reference internal" href="#id51">ゴルーチン</a></li>
<li><a class="reference internal" href="#id52">チャンネル</a></li>
<li><a class="reference internal" href="#channels-of-channels">Channels of channels</a></li>
<li><a class="reference internal" href="#parallelization">Parallelization</a></li>
<li><a class="reference internal" href="#a-leaky-buffer">A leaky buffer</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id53">エラー</a><ul>
<li><a class="reference internal" href="#panic">Panic</a></li>
<li><a class="reference internal" href="#recover">Recover</a></li>
</ul>
</li>
<li><a class="reference internal" href="#web">Webサーバー</a></li>
</ul>
</li>
</ul>

  <h4>前のトピックへ</h4>
  <p class="topless"><a href="../index.html"
                        title="前の章へ">Effective Go</a></p>
  <div role="note" aria-label="source link">
    <h3>このページ</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/documents/effective_go_ja.rst.txt"
            rel="nofollow">ソースコードを表示</a></li>
    </ul>
   </div><div>
    <h4>Page Info</h4>
    <p>
        <ul>
            <li>英数記号: 18892</li>
            <li>非アスキー: 26251</li>
            <li>合計文字数: 45143</li>
            <li>半角換算: 71394</li>
            <li>全角換算: 35697.0</li>
        </ul>
    </p>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">クイック検索</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="検索" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             >索引</a></li>
        <li class="right" >
          <a href="../index.html" title="Effective Go"
             >前へ</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">Effective Go  ドキュメント</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2020, d-tsuji.
      このドキュメントは <a href="http://sphinx-doc.org/">Sphinx</a> 2.4.1 で生成しました。
    </div>
  </body>
</html>