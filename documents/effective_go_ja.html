
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="ja">
  <head>
    <meta charset="utf-8" />
    <title>Effective Go &#8212; Effective Go  ドキュメント</title>
    <link rel="stylesheet" href="../_static/traditional.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="検索" href="../search.html" />
    <link rel="prev" title="Effective Go" href="../index.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../index.html" title="Effective Go"
             accesskey="P">前へ</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">Effective Go  ドキュメント</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="effective-go">
<h1>Effective Go<a class="headerlink" href="#effective-go" title="このヘッドラインへのパーマリンク">¶</a></h1>
<div class="section" id="id1">
<h2>イントロダクション<a class="headerlink" href="#id1" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Goは新しい言語です。既存の言語からアイデアを借りていますが、その言語の特徴で書かれたプログラムとは異なる、Goのプログラムを効果的にする興味深い特徴を持っています。C++やJavaで書かれたプログラムをそのままGoに移植しても、満足な結果は得られないでしょう。JavaのプログラムはGoではなく、Javaで書かれます。一方、Goの特徴を用いると、元のプログラムとは全く異なりますが、良いものが生まれるかもしれません。Goを適切に書くのは、その特徴とイディオムを理解することが重要です。そして、他のGoプログラマーが理解しやすいように、命名規則やフォーマット、プログラムの構成といったGoの慣習を知ることも重要です。</p>
<p>このドキュメントは明確で慣用的なGoのコードを書くためのヒントを示します。<a class="reference external" href="/ref/spec">言語仕様</a> や <a class="reference external" href="//tour.golang.org/">Tour of Go</a> や <a class="reference external" href="/doc/code.html">How to Write Go Code</a> を補強するもので、最初に読むべきものです。</p>
<div class="section" id="id3">
<h3>例<a class="headerlink" href="#id3" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Go本体のパッケージのソースはコアライブラリとしてだけではなく、Goをどのように扱うかというサンプルでもあります。さらに、多くのパッケージでは <a class="reference external" href="//golang.org">golang.org</a> から直接実行できる、動作する自己完結型の実行可能サンプルが含まれています。 <a class="reference external" href="//golang.org/pkg/strings/#example_Map">この</a> ようなものです。必要に応じて &quot;Example&quot; のボタンを押すと開きます。問題へのアプローチ方法や実装方法について質問がある場合は、ライブラリのドキュメントやコード、サンプルから回答やアイデア、背景を知ることができるでしょう。</p>
</div>
</div>
<div class="section" id="id5">
<h2>フォーマット<a class="headerlink" href="#id5" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>フォーマッティングは最も議論の多い問題ですが、それほど重要な問題ではありません。開発者はさまざまなフォーマッティングスタイルに適応できますが、同じスタイルを守っている場合は、この話題に費やす時間を短縮できます。問題は、長い規範的なスタイルガイドを用いずにこのユートピアにアプローチする方法です。</p>
<p>Goでは、通常とは異なるアプローチを採用し、ほとんどのフォーマットの問題をマシンに任せます。<code class="docutils literal notranslate"><span class="pre">gofmt</span></code> プログラム（ソースファイルレベルではなくパッケージレベルで動作する <code class="docutils literal notranslate"><span class="pre">go</span> <span class="pre">fmt</span></code> としても利用可能）は、Goプログラムを読み取り、標準スタイルのインデントと垂直方向の配置でソースを出力し、コメントを保持し、必要に応じて再フォーマットします。 新しいレイアウトの状況を処理する方法を知りたい場合は、 <code class="docutils literal notranslate"><span class="pre">gofmt</span></code> を実行します。 答えが正しくないと思われる場合は、プログラムを再配置（またはgofmtに関するバグを報告）してください。そのまま使わないでください。</p>
<p>例として、構造体のフィールドにコメントを並べるのに時間を費やす必要はありません。 Gofmtがそれを行います。以下に示します。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">T</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">name</span> <span class="kt">string</span> <span class="c1">// name of the object</span>
    <span class="nx">value</span> <span class="kt">int</span> <span class="c1">// its value</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong>gofmt</strong> カラムをフォーマットします:</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">T</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">name</span>    <span class="kt">string</span> <span class="c1">// name of the object</span>
    <span class="nx">value</span>   <span class="kt">int</span>    <span class="c1">// its value</span>
<span class="p">}</span>
</pre></div>
</div>
<p>標準パッケージのすべてのGoのコードは <code class="docutils literal notranslate"><span class="pre">gofmt</span></code> でフォーマットされています。</p>
<p>その他の書式設定の詳細が残っています。 簡潔に説明します。</p>
<dl class="simple">
<dt>インデント</dt><dd><p>インデントにタブを使用し <code class="docutils literal notranslate"><span class="pre">gofmt</span></code> はデフォルトでタブを出力します。必要な場合にのみスペースを使用してください。</p>
</dd>
<dt>行の長さ</dt><dd><p>Goには行の長さの制限はありません。パンチされたカードがあふれる心配はありません。行が長すぎると感じる場合は、それを折り返し、追加のタブでインデントします。</p>
</dd>
<dt>括弧</dt><dd><p>Goでは、CやJavaよりも括弧が少なくてすみます。制御構造( <code class="docutils literal notranslate"><span class="pre">if</span></code>, <code class="docutils literal notranslate"><span class="pre">for</span></code>, <code class="docutils literal notranslate"><span class="pre">switch</span></code> )の構文に括弧がありません。また、演算子の優先順位の階層は短く明確です。</p>
</dd>
</dl>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">x</span><span class="o">&lt;&lt;</span><span class="mi">8</span> <span class="o">+</span> <span class="nx">y</span><span class="o">&lt;&lt;</span><span class="mi">16</span>
</pre></div>
</div>
<p>他の言語とは異なり、スペースが意味することを意味します。</p>
</div>
<div class="section" id="id6">
<h2>コメント<a class="headerlink" href="#id6" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Go provides C-style <strong>/* */</strong> block comments and C++-style <strong>//</strong> line
comments. Line comments are the norm; block comments appear mostly as
package comments, but are useful within an expression or to disable
large swaths of code.</p>
<p>The program—and web server—<strong>godoc</strong> processes Go source files to
extract documentation about the contents of the package. Comments that
appear before top-level declarations, with no intervening newlines, are
extracted along with the declaration to serve as explanatory text for
the item. The nature and style of these comments determines the quality
of the documentation <strong>godoc</strong> produces.</p>
<p>Every package should have a <em>package comment</em>, a block comment preceding
the package clause. For multi-file packages, the package comment only
needs to be present in one file, and any one will do. The package
comment should introduce the package and provide information relevant to
the package as a whole. It will appear first on the <strong>godoc</strong> page and
should set up the detailed documentation that follows.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/*</span>
<span class="n">Package</span> <span class="n">regexp</span> <span class="n">implements</span> <span class="n">a</span> <span class="n">simple</span> <span class="n">library</span> <span class="k">for</span> <span class="n">regular</span> <span class="n">expressions</span><span class="o">.</span>

<span class="n">The</span> <span class="n">syntax</span> <span class="n">of</span> <span class="n">the</span> <span class="n">regular</span> <span class="n">expressions</span> <span class="n">accepted</span> <span class="ow">is</span><span class="p">:</span>

    <span class="n">regexp</span><span class="p">:</span>
        <span class="n">concatenation</span> <span class="p">{</span> <span class="s1">&#39;|&#39;</span> <span class="n">concatenation</span> <span class="p">}</span>
    <span class="n">concatenation</span><span class="p">:</span>
        <span class="p">{</span> <span class="n">closure</span> <span class="p">}</span>
    <span class="n">closure</span><span class="p">:</span>
        <span class="n">term</span> <span class="p">[</span> <span class="s1">&#39;*&#39;</span> <span class="o">|</span> <span class="s1">&#39;+&#39;</span> <span class="o">|</span> <span class="s1">&#39;?&#39;</span> <span class="p">]</span>
    <span class="n">term</span><span class="p">:</span>
        <span class="s1">&#39;^&#39;</span>
        <span class="s1">&#39;$&#39;</span>
        <span class="s1">&#39;.&#39;</span>
        <span class="n">character</span>
        <span class="s1">&#39;[&#39;</span> <span class="p">[</span> <span class="s1">&#39;^&#39;</span> <span class="p">]</span> <span class="n">character</span><span class="o">-</span><span class="n">ranges</span> <span class="s1">&#39;]&#39;</span>
        <span class="s1">&#39;(&#39;</span> <span class="n">regexp</span> <span class="s1">&#39;)&#39;</span>
<span class="o">*/</span>
<span class="n">package</span> <span class="n">regexp</span>
</pre></div>
</div>
<p>If the package is simple, the package comment can be brief.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Package</span> <span class="n">path</span> <span class="n">implements</span> <span class="n">utility</span> <span class="n">routines</span> <span class="k">for</span>
<span class="o">//</span> <span class="n">manipulating</span> <span class="n">slash</span><span class="o">-</span><span class="n">separated</span> <span class="n">filename</span> <span class="n">paths</span><span class="o">.</span>
</pre></div>
</div>
<p>Comments do not need extra formatting such as banners of stars. The
generated output may not even be presented in a fixed-width font, so
don't depend on spacing for alignment—<strong>godoc</strong>, like <strong>gofmt</strong>, takes
care of that. The comments are uninterpreted plain text, so HTML and
other annotations such as <strong>_this_</strong> will reproduce <em>verbatim</em> and
should not be used. One adjustment <strong>godoc</strong> does do is to display
indented text in a fixed-width font, suitable for program snippets. The
package comment for the <strong>`fmt</strong> package &lt;/pkg/fmt/&gt;`__ uses this to
good effect.</p>
<p>Depending on the context, <strong>godoc</strong> might not even reformat comments, so
make sure they look good straight up: use correct spelling, punctuation,
and sentence structure, fold long lines, and so on.</p>
<p>Inside a package, any comment immediately preceding a top-level
declaration serves as a <em>doc comment</em> for that declaration. Every
exported (capitalized) name in a program should have a doc comment.</p>
<p>Doc comments work best as complete sentences, which allow a wide variety
of automated presentations. The first sentence should be a one-sentence
summary that starts with the name being declared.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Compile</span> <span class="n">parses</span> <span class="n">a</span> <span class="n">regular</span> <span class="n">expression</span> <span class="ow">and</span> <span class="n">returns</span><span class="p">,</span> <span class="k">if</span> <span class="n">successful</span><span class="p">,</span>
<span class="o">//</span> <span class="n">a</span> <span class="n">Regexp</span> <span class="n">that</span> <span class="n">can</span> <span class="n">be</span> <span class="n">used</span> <span class="n">to</span> <span class="n">match</span> <span class="n">against</span> <span class="n">text</span><span class="o">.</span>
<span class="n">func</span> <span class="n">Compile</span><span class="p">(</span><span class="nb">str</span> <span class="n">string</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="n">Regexp</span><span class="p">,</span> <span class="n">error</span><span class="p">)</span> <span class="p">{</span>
</pre></div>
</div>
<p>If every doc comment begins with the name of the item it describes, you
can use the
<a class="reference external" href="/cmd/go/#hdr-Show_documentation_for_package_or_symbol">doc</a>
subcommand of the <a class="reference external" href="/cmd/go/">go</a> tool and run the output through
<strong>grep</strong>. Imagine you couldn't remember the name &quot;Compile&quot; but were
looking for the parsing function for regular expressions, so you ran the
command,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ go doc -all regexp | grep -i parse
</pre></div>
</div>
<p>If all the doc comments in the package began, &quot;This function...&quot;,
<strong>grep</strong> wouldn't help you remember the name. But because the package
starts each doc comment with the name, you'd see something like this,
which recalls the word you're looking for.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ go doc -all regexp | grep -i parse
    Compile parses a regular expression and returns, if successful, a Regexp
    MustCompile is like Compile but panics if the expression cannot be parsed.
    parsed. It simplifies safe initialization of global variables holding
$
</pre></div>
</div>
<p>Go's declaration syntax allows grouping of declarations. A single doc
comment can introduce a group of related constants or variables. Since
the whole declaration is presented, such a comment can often be
perfunctory.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Error</span> <span class="n">codes</span> <span class="n">returned</span> <span class="n">by</span> <span class="n">failures</span> <span class="n">to</span> <span class="n">parse</span> <span class="n">an</span> <span class="n">expression</span><span class="o">.</span>
<span class="n">var</span> <span class="p">(</span>
    <span class="n">ErrInternal</span>      <span class="o">=</span> <span class="n">errors</span><span class="o">.</span><span class="n">New</span><span class="p">(</span><span class="s2">&quot;regexp: internal error&quot;</span><span class="p">)</span>
    <span class="n">ErrUnmatchedLpar</span> <span class="o">=</span> <span class="n">errors</span><span class="o">.</span><span class="n">New</span><span class="p">(</span><span class="s2">&quot;regexp: unmatched &#39;(&#39;&quot;</span><span class="p">)</span>
    <span class="n">ErrUnmatchedRpar</span> <span class="o">=</span> <span class="n">errors</span><span class="o">.</span><span class="n">New</span><span class="p">(</span><span class="s2">&quot;regexp: unmatched &#39;)&#39;&quot;</span><span class="p">)</span>
    <span class="o">...</span>
<span class="p">)</span>
</pre></div>
</div>
<p>Grouping can also indicate relationships between items, such as the fact
that a set of variables is protected by a mutex.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">var</span> <span class="p">(</span>
    <span class="n">countLock</span>   <span class="n">sync</span><span class="o">.</span><span class="n">Mutex</span>
    <span class="n">inputCount</span>  <span class="n">uint32</span>
    <span class="n">outputCount</span> <span class="n">uint32</span>
    <span class="n">errorCount</span>  <span class="n">uint32</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id7">
<h2>命名<a class="headerlink" href="#id7" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>命名は他の言語と同様にGoでも重要です。セマンティックな効果もあります。外部パッケージから参照可視性は、その最小の文字が大文字かどうかで決まります。したがって、Goプログラムの命名規則について少し話をする価値があります。</p>
<div class="section" id="id8">
<h3>パッケージ名<a class="headerlink" href="#id8" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>パッケージがインポートされるとき、パッケージ名がコンテンツのアクセッサーになります。</p>
<p>以下のように</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="s2">&quot;bytes&quot;</span>
</pre></div>
</div>
<p>とパッケージをインポートすると、 <strong>bytes.Buffer</strong> としてパッケージを使うことができます。パッケージを使う人が同じ名前でパッケージのコンテンツを参照すると便利です。これはパッケージ名が適切であることを意味します。短く完結で分かりやすくあるべきです。慣例としてパッケージ名は小文字の単一の単語名にします。アンダースコアやmixedCapsである必要はありません。多くの人がパッケージ名を打ち込むことを考えて、簡潔すぎるほど簡潔にしてしまう場合があります。その場合でも衝突を心配する必要はありません。パッケージ名はインポートするときのデフォルトでしかないからです。ソースコード全体で唯一である必要はありません。衝突するようなまれな場合、インポートするパッケージ名に異なる名前をつけることができます。どのような場合でも、インポート機能においてファイル名がどのパッケージで使用されるかを決めるので、混乱することはまれです。別の慣例として、パッケージ名はソースディレクトリの名前であるこということです。 <strong>src/encoding/base64</strong> にあるパッケージは <strong>&quot;encoding/base64&quot;</strong> としてインポートされます。名前は <strong>base64</strong> であって、 <strong>encoding_base64</strong> でも <strong>encodingBase64</strong> でもありません。</p>
<p>The importer of a package will use the name to refer to its contents, so
exported names in the package can use that fact to avoid stutter. (Don't
use the <strong>import .</strong> notation, which can simplify tests that must run
outside the package they are testing, but should otherwise be avoided.)
For instance, the buffered reader type in the <strong>bufio</strong> package is
called <strong>Reader</strong>, not <strong>BufReader</strong>, because users see it as
<strong>bufio.Reader</strong>, which is a clear, concise name. Moreover, because
imported entities are always addressed with their package name,
<strong>bufio.Reader</strong> does not conflict with <strong>io.Reader</strong>. Similarly, the
function to make new instances of <strong>ring.Ring</strong>—which is the definition
of a <em>constructor</em> in Go—would normally be called <strong>NewRing</strong>, but since
<strong>Ring</strong> is the only type exported by the package, and since the package
is called <strong>ring</strong>, it's called just <strong>New</strong>, which clients of the
package see as <strong>ring.New</strong>. Use the package structure to help you
choose good names.</p>
<p>Another short example is <strong>once.Do</strong>; <strong>once.Do(setup)</strong> reads well and
would not be improved by writing <strong>once.DoOrWaitUntilDone(setup)</strong>. Long
names don't automatically make things more readable. A helpful doc
comment can often be more valuable than an extra long name.</p>
</div>
<div class="section" id="getters">
<span id="id9"></span><h3>ゲッター<a class="headerlink" href="#getters" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Go doesn't provide automatic support for getters and setters. There's
nothing wrong with providing getters and setters yourself, and it's
often appropriate to do so, but it's neither idiomatic nor necessary to
put <strong>Get</strong> into the getter's name. If you have a field called <strong>owner</strong>
(lower case, unexported), the getter method should be called <strong>Owner</strong>
(upper case, exported), not <strong>GetOwner</strong>. The use of upper-case names
for export provides the hook to discriminate the field from the method.
A setter function, if needed, will likely be called <strong>SetOwner</strong>. Both
names read well in practice:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">owner</span> <span class="p">:</span><span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">Owner</span><span class="p">()</span>
<span class="k">if</span> <span class="n">owner</span> <span class="o">!=</span> <span class="n">user</span> <span class="p">{</span>
    <span class="n">obj</span><span class="o">.</span><span class="n">SetOwner</span><span class="p">(</span><span class="n">user</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id10">
<h3>インターフェース名<a class="headerlink" href="#id10" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>By convention, one-method interfaces are named by the method name plus
an -er suffix or similar modification to construct an agent noun:
<strong>Reader</strong>, <strong>Writer</strong>, <strong>Formatter</strong>, <strong>CloseNotifier</strong> etc.</p>
<p>There are a number of such names and it's productive to honor them and
the function names they capture. <strong>Read</strong>, <strong>Write</strong>, <strong>Close</strong>,
<strong>Flush</strong>, <strong>String</strong> and so on have canonical signatures and meanings.
To avoid confusion, don't give your method one of those names unless it
has the same signature and meaning. Conversely, if your type implements
a method with the same meaning as a method on a well-known type, give it
the same name and signature; call your string-converter method
<strong>String</strong> not <strong>ToString</strong>.</p>
</div>
<div class="section" id="mixedcaps">
<span id="mixed-caps"></span><h3>MixedCaps<a class="headerlink" href="#mixedcaps" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Finally, the convention in Go is to use <strong>MixedCaps</strong> or <strong>mixedCaps</strong>
rather than underscores to write multiword names.</p>
</div>
</div>
<div class="section" id="id11">
<h2>セミコロン<a class="headerlink" href="#id11" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Like C, Go's formal grammar uses semicolons to terminate statements, but
unlike in C, those semicolons do not appear in the source. Instead the
lexer uses a simple rule to insert semicolons automatically as it scans,
so the input text is mostly free of them.</p>
<p>The rule is this. If the last token before a newline is an identifier
(which includes words like <strong>int</strong> and <strong>float64</strong>), a basic literal
such as a number or string constant, or one of the tokens</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">break</span> <span class="k">continue</span> <span class="n">fallthrough</span> <span class="k">return</span> <span class="o">++</span> <span class="o">--</span> <span class="p">)</span> <span class="p">}</span>
</pre></div>
</div>
<p>the lexer always inserts a semicolon after the token. This could be
summarized as, “if the newline comes after a token that could end a
statement, insert a semicolon”.</p>
<p>A semicolon can also be omitted immediately before a closing brace, so a
statement such as</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">go</span> <span class="n">func</span><span class="p">()</span> <span class="p">{</span> <span class="k">for</span> <span class="p">{</span> <span class="n">dst</span> <span class="o">&lt;-</span> <span class="o">&lt;-</span><span class="n">src</span> <span class="p">}</span> <span class="p">}()</span>
</pre></div>
</div>
<p>needs no semicolons. Idiomatic Go programs have semicolons only in
places such as <strong>for</strong> loop clauses, to separate the initializer,
condition, and continuation elements. They are also necessary to
separate multiple statements on a line, should you write code that way.</p>
<p>One consequence of the semicolon insertion rules is that you cannot put
the opening brace of a control structure (<strong>if</strong>, <strong>for</strong>, <strong>switch</strong>,
or <strong>select</strong>) on the next line. If you do, a semicolon will be inserted
before the brace, which could cause unwanted effects. Write them like
this</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">f</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">g</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>
</div>
<p>not like this</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>if i &lt; f()  // wrong!
{           // wrong!
    g()
}
</pre></div>
</div>
</div>
<div class="section" id="control-structures">
<h2>制御構造(Control structures)<a class="headerlink" href="#control-structures" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>The control structures of Go are related to those of C but differ in
important ways. There is no <strong>do</strong> or <strong>while</strong> loop, only a slightly
generalized <strong>for</strong>; <strong>switch</strong> is more flexible; <strong>if</strong> and <strong>switch</strong>
accept an optional initialization statement like that of <strong>for</strong>;
<strong>break</strong> and <strong>continue</strong> statements take an optional label to identify
what to break or continue; and there are new control structures
including a type switch and a multiway communications multiplexer,
<strong>select</strong>. The syntax is also slightly different: there are no
parentheses and the bodies must always be brace-delimited.</p>
<div class="section" id="if">
<h3>If<a class="headerlink" href="#if" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>In Go a simple <strong>if</strong> looks like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">y</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Mandatory braces encourage writing simple <strong>if</strong> statements on multiple
lines. It's good style to do so anyway, especially when the body
contains a control statement such as a <strong>return</strong> or <strong>break</strong>.</p>
<p>Since <strong>if</strong> and <strong>switch</strong> accept an initialization statement, it's
common to see one used to set up a local variable.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">err</span> <span class="p">:</span><span class="o">=</span> <span class="n">file</span><span class="o">.</span><span class="n">Chmod</span><span class="p">(</span><span class="mi">0664</span><span class="p">);</span> <span class="n">err</span> <span class="o">!=</span> <span class="n">nil</span> <span class="p">{</span>
    <span class="n">log</span><span class="o">.</span><span class="n">Print</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">err</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In the Go libraries, you'll find that when an <strong>if</strong> statement doesn't
flow into the next statement—that is, the body ends in <strong>break</strong>,
<strong>continue</strong>, <strong>goto</strong>, or <strong>return</strong>—the unnecessary <strong>else</strong> is
omitted.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">f</span><span class="p">,</span> <span class="n">err</span> <span class="p">:</span><span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">Open</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
<span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="n">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">err</span>
<span class="p">}</span>
<span class="n">codeUsing</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
</pre></div>
</div>
<p>This is an example of a common situation where code must guard against a
sequence of error conditions. The code reads well if the successful flow
of control runs down the page, eliminating error cases as they arise.
Since error cases tend to end in <strong>return</strong> statements, the resulting
code needs no <strong>else</strong> statements.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">f</span><span class="p">,</span> <span class="n">err</span> <span class="p">:</span><span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">Open</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
<span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="n">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">err</span>
<span class="p">}</span>
<span class="n">d</span><span class="p">,</span> <span class="n">err</span> <span class="p">:</span><span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">Stat</span><span class="p">()</span>
<span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="n">nil</span> <span class="p">{</span>
    <span class="n">f</span><span class="o">.</span><span class="n">Close</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">err</span>
<span class="p">}</span>
<span class="n">codeUsing</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="redeclaration-and-reassignment">
<span id="redeclaration"></span><h3>Redeclaration and reassignment<a class="headerlink" href="#redeclaration-and-reassignment" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>An aside: The last example in the previous section demonstrates a detail
of how the <strong>:=</strong> short declaration form works. The declaration that
calls <strong>os.Open</strong> reads,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">f</span><span class="p">,</span> <span class="n">err</span> <span class="p">:</span><span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">Open</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
</pre></div>
</div>
<p>This statement declares two variables, <strong>f</strong> and <strong>err</strong>. A few lines
later, the call to <strong>f.Stat</strong> reads,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">d</span><span class="p">,</span> <span class="n">err</span> <span class="p">:</span><span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">Stat</span><span class="p">()</span>
</pre></div>
</div>
<p>which looks as if it declares <strong>d</strong> and <strong>err</strong>. Notice, though, that
<strong>err</strong> appears in both statements. This duplication is legal: <strong>err</strong>
is declared by the first statement, but only <em>re-assigned</em> in the
second. This means that the call to <strong>f.Stat</strong> uses the existing <strong>err</strong>
variable declared above, and just gives it a new value.</p>
<p>In a <strong>:=</strong> declaration a variable <strong>v</strong> may appear even if it has
already been declared, provided:</p>
<ul class="simple">
<li><p>this declaration is in the same scope as the existing declaration of
<strong>v</strong> (if <strong>v</strong> is already declared in an outer scope, the
declaration will create a new variable §),</p></li>
<li><p>the corresponding value in the initialization is assignable to <strong>v</strong>,
and</p></li>
<li><p>there is at least one other variable that is created by the
declaration.</p></li>
</ul>
<p>This unusual property is pure pragmatism, making it easy to use a single
<strong>err</strong> value, for example, in a long <strong>if-else</strong> chain. You'll see it
used often.</p>
<p>§ It's worth noting here that in Go the scope of function parameters and
return values is the same as the function body, even though they appear
lexically outside the braces that enclose the body.</p>
</div>
<div class="section" id="for">
<h3>For<a class="headerlink" href="#for" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>The Go <strong>for</strong> loop is similar to—but not the same as—C's. It unifies
<strong>for</strong> and <strong>while</strong> and there is no <strong>do-while</strong>. There are three
forms, only one of which has semicolons.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Like</span> <span class="n">a</span> <span class="n">C</span> <span class="k">for</span>
<span class="k">for</span> <span class="n">init</span><span class="p">;</span> <span class="n">condition</span><span class="p">;</span> <span class="n">post</span> <span class="p">{</span> <span class="p">}</span>

<span class="o">//</span> <span class="n">Like</span> <span class="n">a</span> <span class="n">C</span> <span class="k">while</span>
<span class="k">for</span> <span class="n">condition</span> <span class="p">{</span> <span class="p">}</span>

<span class="o">//</span> <span class="n">Like</span> <span class="n">a</span> <span class="n">C</span> <span class="k">for</span><span class="p">(;;)</span>
<span class="k">for</span> <span class="p">{</span> <span class="p">}</span>
</pre></div>
</div>
<p>Short declarations make it easy to declare the index variable right in
the loop.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">sum</span> <span class="p">:</span><span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">i</span> <span class="p">:</span><span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
    <span class="nb">sum</span> <span class="o">+=</span> <span class="n">i</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If you're looping over an array, slice, string, or map, or reading from
a channel, a <strong>range</strong> clause can manage the loop.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="p">:</span><span class="o">=</span> <span class="nb">range</span> <span class="n">oldMap</span> <span class="p">{</span>
    <span class="n">newMap</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If you only need the first item in the range (the key or index), drop
the second:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">key</span> <span class="p">:</span><span class="o">=</span> <span class="nb">range</span> <span class="n">m</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">key</span><span class="o">.</span><span class="n">expired</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">delete</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If you only need the second item in the range (the value), use the
<em>blank identifier</em>, an underscore, to discard the first:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">sum</span> <span class="p">:</span><span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">value</span> <span class="p">:</span><span class="o">=</span> <span class="nb">range</span> <span class="n">array</span> <span class="p">{</span>
    <span class="nb">sum</span> <span class="o">+=</span> <span class="n">value</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The blank identifier has many uses, as described in <a class="reference external" href="#blank">a later
section</a>.</p>
<p>For strings, the <strong>range</strong> does more work for you, breaking out
individual Unicode code points by parsing the UTF-8. Erroneous encodings
consume one byte and produce the replacement rune U+FFFD. (The name
(with associated builtin type) <strong>rune</strong> is Go terminology for a single
Unicode code point. See <a class="reference external" href="/ref/spec#Rune_literals">the language
specification</a> for details.) The loop</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">pos</span><span class="p">,</span> <span class="n">char</span> <span class="p">:</span><span class="o">=</span> <span class="nb">range</span> <span class="s2">&quot;日本</span><span class="se">\x80</span><span class="s2">語&quot;</span> <span class="p">{</span> <span class="o">//</span> \<span class="n">x80</span> <span class="ow">is</span> <span class="n">an</span> <span class="n">illegal</span> <span class="n">UTF</span><span class="o">-</span><span class="mi">8</span> <span class="n">encoding</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s2">&quot;character %#U starts at byte position </span><span class="si">%d</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">char</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>prints</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">character</span> <span class="n">U</span><span class="o">+</span><span class="mf">65E5</span> <span class="s1">&#39;日&#39;</span> <span class="n">starts</span> <span class="n">at</span> <span class="n">byte</span> <span class="n">position</span> <span class="mi">0</span>
<span class="n">character</span> <span class="n">U</span><span class="o">+</span><span class="mi">672</span><span class="n">C</span> <span class="s1">&#39;本&#39;</span> <span class="n">starts</span> <span class="n">at</span> <span class="n">byte</span> <span class="n">position</span> <span class="mi">3</span>
<span class="n">character</span> <span class="n">U</span><span class="o">+</span><span class="n">FFFD</span> <span class="s1">&#39;�&#39;</span> <span class="n">starts</span> <span class="n">at</span> <span class="n">byte</span> <span class="n">position</span> <span class="mi">6</span>
<span class="n">character</span> <span class="n">U</span><span class="o">+</span><span class="mi">8</span><span class="n">A9E</span> <span class="s1">&#39;語&#39;</span> <span class="n">starts</span> <span class="n">at</span> <span class="n">byte</span> <span class="n">position</span> <span class="mi">7</span>
</pre></div>
</div>
<p>Finally, Go has no comma operator and <strong>++</strong> and <strong>--</strong> are statements
not expressions. Thus if you want to run multiple variables in a <strong>for</strong>
you should use parallel assignment (although that precludes <strong>++</strong> and
<strong>--</strong>).</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Reverse</span> <span class="n">a</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="p">:</span><span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">;</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="o">-</span><span class="mi">1</span> <span class="p">{</span>
    <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="switch">
<h3>Switch<a class="headerlink" href="#switch" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Go's <strong>switch</strong> is more general than C's. The expressions need not be
constants or even integers, the cases are evaluated top to bottom until
a match is found, and if the <strong>switch</strong> has no expression it switches on
<strong>true</strong>. It's therefore possible—and idiomatic—to write an
<strong>if</strong>-<strong>else</strong>-<strong>if</strong>-<strong>else</strong> chain as a <strong>switch</strong>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">func</span> <span class="n">unhex</span><span class="p">(</span><span class="n">c</span> <span class="n">byte</span><span class="p">)</span> <span class="n">byte</span> <span class="p">{</span>
    <span class="n">switch</span> <span class="p">{</span>
    <span class="n">case</span> <span class="s1">&#39;0&#39;</span> <span class="o">&lt;=</span> <span class="n">c</span> <span class="o">&amp;&amp;</span> <span class="n">c</span> <span class="o">&lt;=</span> <span class="s1">&#39;9&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">c</span> <span class="o">-</span> <span class="s1">&#39;0&#39;</span>
    <span class="n">case</span> <span class="s1">&#39;a&#39;</span> <span class="o">&lt;=</span> <span class="n">c</span> <span class="o">&amp;&amp;</span> <span class="n">c</span> <span class="o">&lt;=</span> <span class="s1">&#39;f&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">c</span> <span class="o">-</span> <span class="s1">&#39;a&#39;</span> <span class="o">+</span> <span class="mi">10</span>
    <span class="n">case</span> <span class="s1">&#39;A&#39;</span> <span class="o">&lt;=</span> <span class="n">c</span> <span class="o">&amp;&amp;</span> <span class="n">c</span> <span class="o">&lt;=</span> <span class="s1">&#39;F&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">c</span> <span class="o">-</span> <span class="s1">&#39;A&#39;</span> <span class="o">+</span> <span class="mi">10</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span>
<span class="p">}</span>
</pre></div>
</div>
<p>There is no automatic fall through, but cases can be presented in
comma-separated lists.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">func</span> <span class="n">shouldEscape</span><span class="p">(</span><span class="n">c</span> <span class="n">byte</span><span class="p">)</span> <span class="nb">bool</span> <span class="p">{</span>
    <span class="n">switch</span> <span class="n">c</span> <span class="p">{</span>
    <span class="n">case</span> <span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="s1">&#39;?&#39;</span><span class="p">,</span> <span class="s1">&#39;&amp;&#39;</span><span class="p">,</span> <span class="s1">&#39;=&#39;</span><span class="p">,</span> <span class="s1">&#39;#&#39;</span><span class="p">,</span> <span class="s1">&#39;+&#39;</span><span class="p">,</span> <span class="s1">&#39;%&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">true</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">false</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Although they are not nearly as common in Go as some other C-like
languages, <strong>break</strong> statements can be used to terminate a <strong>switch</strong>
early. Sometimes, though, it's necessary to break out of a surrounding
loop, not the switch, and in Go that can be accomplished by putting a
label on the loop and &quot;breaking&quot; to that label. This example shows both
uses.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Loop</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">n</span> <span class="p">:</span><span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">src</span><span class="p">);</span> <span class="n">n</span> <span class="o">+=</span> <span class="n">size</span> <span class="p">{</span>
        <span class="n">switch</span> <span class="p">{</span>
        <span class="n">case</span> <span class="n">src</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">sizeOne</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">validateOnly</span> <span class="p">{</span>
                <span class="k">break</span>
            <span class="p">}</span>
            <span class="n">size</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">update</span><span class="p">(</span><span class="n">src</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>

        <span class="n">case</span> <span class="n">src</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">sizeTwo</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">src</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">err</span> <span class="o">=</span> <span class="n">errShortInput</span>
                <span class="k">break</span> <span class="n">Loop</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="n">validateOnly</span> <span class="p">{</span>
                <span class="k">break</span>
            <span class="p">}</span>
            <span class="n">size</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="n">update</span><span class="p">(</span><span class="n">src</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="n">src</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="n">shift</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
</pre></div>
</div>
<p>Of course, the <strong>continue</strong> statement also accepts an optional label but
it applies only to loops.</p>
<p>To close this section, here's a comparison routine for byte slices that
uses two <strong>switch</strong> statements:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Compare</span> <span class="n">returns</span> <span class="n">an</span> <span class="n">integer</span> <span class="n">comparing</span> <span class="n">the</span> <span class="n">two</span> <span class="n">byte</span> <span class="n">slices</span><span class="p">,</span>
<span class="o">//</span> <span class="n">lexicographically</span><span class="o">.</span>
<span class="o">//</span> <span class="n">The</span> <span class="n">result</span> <span class="n">will</span> <span class="n">be</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">,</span> <span class="ow">and</span> <span class="o">+</span><span class="mi">1</span> <span class="k">if</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span>
<span class="n">func</span> <span class="n">Compare</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="p">[]</span><span class="n">byte</span><span class="p">)</span> <span class="nb">int</span> <span class="p">{</span>
    <span class="k">for</span> <span class="n">i</span> <span class="p">:</span><span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="n">switch</span> <span class="p">{</span>
        <span class="n">case</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="k">return</span> <span class="mi">1</span>
        <span class="n">case</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">switch</span> <span class="p">{</span>
    <span class="n">case</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="n">case</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">):</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="type-switch">
<span id="id12"></span><h3>Type switch<a class="headerlink" href="#type-switch" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>A switch can also be used to discover the dynamic type of an interface
variable. Such a <em>type switch</em> uses the syntax of a type assertion with
the keyword <strong>type</strong> inside the parentheses. If the switch declares a
variable in the expression, the variable will have the corresponding
type in each clause. It's also idiomatic to reuse the name in such
cases, in effect declaring a new variable with the same name but a
different type in each case.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">var</span> <span class="n">t</span> <span class="n">interface</span><span class="p">{}</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">functionOfSomeType</span><span class="p">()</span>
<span class="n">switch</span> <span class="n">t</span> <span class="p">:</span><span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="p">(</span><span class="nb">type</span><span class="p">)</span> <span class="p">{</span>
<span class="n">default</span><span class="p">:</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s2">&quot;unexpected type %T</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>     <span class="o">//</span> <span class="o">%</span><span class="n">T</span> <span class="n">prints</span> <span class="n">whatever</span> <span class="nb">type</span> <span class="n">t</span> <span class="n">has</span>
<span class="n">case</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s2">&quot;boolean %t</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>             <span class="o">//</span> <span class="n">t</span> <span class="n">has</span> <span class="nb">type</span> <span class="nb">bool</span>
<span class="n">case</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s2">&quot;integer </span><span class="si">%d</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>             <span class="o">//</span> <span class="n">t</span> <span class="n">has</span> <span class="nb">type</span> <span class="nb">int</span>
<span class="n">case</span> <span class="o">*</span><span class="nb">bool</span><span class="p">:</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s2">&quot;pointer to boolean %t</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span> <span class="o">//</span> <span class="n">t</span> <span class="n">has</span> <span class="nb">type</span> <span class="o">*</span><span class="nb">bool</span>
<span class="n">case</span> <span class="o">*</span><span class="nb">int</span><span class="p">:</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s2">&quot;pointer to integer </span><span class="si">%d</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span> <span class="o">//</span> <span class="n">t</span> <span class="n">has</span> <span class="nb">type</span> <span class="o">*</span><span class="nb">int</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id13">
<h2>関数<a class="headerlink" href="#id13" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="multiple-returns">
<span id="id14"></span><h3>多値返却<a class="headerlink" href="#multiple-returns" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>One of Go's unusual features is that functions and methods can return
multiple values. This form can be used to improve on a couple of clumsy
idioms in C programs: in-band error returns such as <strong>-1</strong> for <strong>EOF</strong>
and modifying an argument passed by address.</p>
<p>In C, a write error is signaled by a negative count with the error code
secreted away in a volatile location. In Go, <strong>Write</strong> can return a
count <em>and</em> an error: “Yes, you wrote some bytes but not all of them
because you filled the device”. The signature of the <strong>Write</strong> method on
files from package <strong>os</strong> is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">func</span> <span class="p">(</span><span class="n">file</span> <span class="o">*</span><span class="n">File</span><span class="p">)</span> <span class="n">Write</span><span class="p">(</span><span class="n">b</span> <span class="p">[]</span><span class="n">byte</span><span class="p">)</span> <span class="p">(</span><span class="n">n</span> <span class="nb">int</span><span class="p">,</span> <span class="n">err</span> <span class="n">error</span><span class="p">)</span>
</pre></div>
</div>
<p>and as the documentation says, it returns the number of bytes written
and a non-nil <strong>error</strong> when <strong>n</strong> <strong>!=</strong> <strong>len(b)</strong>. This is a common
style; see the section on error handling for more examples.</p>
<p>A similar approach obviates the need to pass a pointer to a return value
to simulate a reference parameter. Here's a simple-minded function to
grab a number from a position in a byte slice, returning the number and
the next position.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>func nextInt(b []byte, i int) (int, int) {
    for ; i &lt; len(b) &amp;&amp; !isDigit(b[i]); i++ {
    }
    x := 0
    for ; i &lt; len(b) &amp;&amp; isDigit(b[i]); i++ {
        x = x*10 + int(b[i]) - &#39;0&#39;
    }
    return x, i
}
</pre></div>
</div>
<p>You could use it to scan the numbers in an input slice <strong>b</strong> like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">i</span> <span class="p">:</span><span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">);</span> <span class="p">{</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="n">nextInt</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="named-result-parameters">
<span id="named-results"></span><h3>名前付き結果変数(Named result parameters)<a class="headerlink" href="#named-result-parameters" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>The return or result &quot;parameters&quot; of a Go function can be given names
and used as regular variables, just like the incoming parameters. When
named, they are initialized to the zero values for their types when the
function begins; if the function executes a <strong>return</strong> statement with no
arguments, the current values of the result parameters are used as the
returned values.</p>
<p>The names are not mandatory but they can make code shorter and clearer:
they're documentation. If we name the results of <strong>nextInt</strong> it becomes
obvious which returned <strong>int</strong> is which.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">func</span> <span class="n">nextInt</span><span class="p">(</span><span class="n">b</span> <span class="p">[]</span><span class="n">byte</span><span class="p">,</span> <span class="n">pos</span> <span class="nb">int</span><span class="p">)</span> <span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">nextPos</span> <span class="nb">int</span><span class="p">)</span> <span class="p">{</span>
</pre></div>
</div>
<p>Because named results are initialized and tied to an unadorned return,
they can simplify as well as clarify. Here's a version of
<strong>io.ReadFull</strong> that uses them well:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">func</span> <span class="n">ReadFull</span><span class="p">(</span><span class="n">r</span> <span class="n">Reader</span><span class="p">,</span> <span class="n">buf</span> <span class="p">[]</span><span class="n">byte</span><span class="p">)</span> <span class="p">(</span><span class="n">n</span> <span class="nb">int</span><span class="p">,</span> <span class="n">err</span> <span class="n">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nb">len</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">err</span> <span class="o">==</span> <span class="n">nil</span> <span class="p">{</span>
        <span class="n">var</span> <span class="n">nr</span> <span class="nb">int</span>
        <span class="n">nr</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">Read</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">+=</span> <span class="n">nr</span>
        <span class="n">buf</span> <span class="o">=</span> <span class="n">buf</span><span class="p">[</span><span class="n">nr</span><span class="p">:]</span>
    <span class="p">}</span>
    <span class="k">return</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="defer">
<h3>Defer<a class="headerlink" href="#defer" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Go's <strong>defer</strong> statement schedules a function call (the <em>deferred</em>
function) to be run immediately before the function executing the
<strong>defer</strong> returns. It's an unusual but effective way to deal with
situations such as resources that must be released regardless of which
path a function takes to return. The canonical examples are unlocking a
mutex or closing a file.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Contents</span> <span class="n">returns</span> <span class="n">the</span> <span class="n">file</span><span class="s1">&#39;s contents as a string.</span>
<span class="n">func</span> <span class="n">Contents</span><span class="p">(</span><span class="n">filename</span> <span class="n">string</span><span class="p">)</span> <span class="p">(</span><span class="n">string</span><span class="p">,</span> <span class="n">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">f</span><span class="p">,</span> <span class="n">err</span> <span class="p">:</span><span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">Open</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="n">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">err</span>
    <span class="p">}</span>
    <span class="n">defer</span> <span class="n">f</span><span class="o">.</span><span class="n">Close</span><span class="p">()</span>  <span class="o">//</span> <span class="n">f</span><span class="o">.</span><span class="n">Close</span> <span class="n">will</span> <span class="n">run</span> <span class="n">when</span> <span class="n">we</span><span class="s1">&#39;re finished.</span>

    <span class="n">var</span> <span class="n">result</span> <span class="p">[]</span><span class="n">byte</span>
    <span class="n">buf</span> <span class="p">:</span><span class="o">=</span> <span class="n">make</span><span class="p">([]</span><span class="n">byte</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
    <span class="k">for</span> <span class="p">{</span>
        <span class="n">n</span><span class="p">,</span> <span class="n">err</span> <span class="p">:</span><span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">Read</span><span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">:])</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">append</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">n</span><span class="p">]</span><span class="o">...</span><span class="p">)</span> <span class="o">//</span> <span class="n">append</span> <span class="ow">is</span> <span class="n">discussed</span> <span class="n">later</span><span class="o">.</span>
        <span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="n">nil</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">err</span> <span class="o">==</span> <span class="n">io</span><span class="o">.</span><span class="n">EOF</span> <span class="p">{</span>
                <span class="k">break</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">err</span>  <span class="o">//</span> <span class="n">f</span> <span class="n">will</span> <span class="n">be</span> <span class="n">closed</span> <span class="k">if</span> <span class="n">we</span> <span class="k">return</span> <span class="n">here</span><span class="o">.</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">string</span><span class="p">(</span><span class="n">result</span><span class="p">),</span> <span class="n">nil</span> <span class="o">//</span> <span class="n">f</span> <span class="n">will</span> <span class="n">be</span> <span class="n">closed</span> <span class="k">if</span> <span class="n">we</span> <span class="k">return</span> <span class="n">here</span><span class="o">.</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Deferring a call to a function such as <strong>Close</strong> has two advantages.
First, it guarantees that you will never forget to close the file, a
mistake that's easy to make if you later edit the function to add a new
return path. Second, it means that the close sits near the open, which
is much clearer than placing it at the end of the function.</p>
<p>The arguments to the deferred function (which include the receiver if
the function is a method) are evaluated when the <em>defer</em> executes, not
when the <em>call</em> executes. Besides avoiding worries about variables
changing values as the function executes, this means that a single
deferred call site can defer multiple function executions. Here's a
silly example.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">i</span> <span class="p">:</span><span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
    <span class="n">defer</span> <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> &quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Deferred functions are executed in LIFO order, so this code will cause
<strong>4 3 2 1 0</strong> to be printed when the function returns. A more plausible
example is a simple way to trace function execution through the program.
We could write a couple of simple tracing routines like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">func</span> <span class="n">trace</span><span class="p">(</span><span class="n">s</span> <span class="n">string</span><span class="p">)</span>   <span class="p">{</span> <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s2">&quot;entering:&quot;</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span> <span class="p">}</span>
<span class="n">func</span> <span class="n">untrace</span><span class="p">(</span><span class="n">s</span> <span class="n">string</span><span class="p">)</span> <span class="p">{</span> <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s2">&quot;leaving:&quot;</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span> <span class="p">}</span>

<span class="o">//</span> <span class="n">Use</span> <span class="n">them</span> <span class="n">like</span> <span class="n">this</span><span class="p">:</span>
<span class="n">func</span> <span class="n">a</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">trace</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">)</span>
    <span class="n">defer</span> <span class="n">untrace</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">)</span>
    <span class="o">//</span> <span class="n">do</span> <span class="n">something</span><span class="o">....</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We can do better by exploiting the fact that arguments to deferred
functions are evaluated when the <strong>defer</strong> executes. The tracing routine
can set up the argument to the untracing routine. This example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">func</span> <span class="n">trace</span><span class="p">(</span><span class="n">s</span> <span class="n">string</span><span class="p">)</span> <span class="n">string</span> <span class="p">{</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s2">&quot;entering:&quot;</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">s</span>
<span class="p">}</span>

<span class="n">func</span> <span class="n">un</span><span class="p">(</span><span class="n">s</span> <span class="n">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s2">&quot;leaving:&quot;</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
<span class="p">}</span>

<span class="n">func</span> <span class="n">a</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">defer</span> <span class="n">un</span><span class="p">(</span><span class="n">trace</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">))</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s2">&quot;in a&quot;</span><span class="p">)</span>
<span class="p">}</span>

<span class="n">func</span> <span class="n">b</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">defer</span> <span class="n">un</span><span class="p">(</span><span class="n">trace</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">))</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s2">&quot;in b&quot;</span><span class="p">)</span>
    <span class="n">a</span><span class="p">()</span>
<span class="p">}</span>

<span class="n">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">b</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>
</div>
<p>prints</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">entering</span><span class="p">:</span> <span class="n">b</span>
<span class="ow">in</span> <span class="n">b</span>
<span class="n">entering</span><span class="p">:</span> <span class="n">a</span>
<span class="ow">in</span> <span class="n">a</span>
<span class="n">leaving</span><span class="p">:</span> <span class="n">a</span>
<span class="n">leaving</span><span class="p">:</span> <span class="n">b</span>
</pre></div>
</div>
<p>For programmers accustomed to block-level resource management from other
languages, <strong>defer</strong> may seem peculiar, but its most interesting and
powerful applications come precisely from the fact that it's not
block-based but function-based. In the section on <strong>panic</strong> and
<strong>recover</strong> we'll see another example of its possibilities.</p>
</div>
</div>
<div class="section" id="data">
<h2>データ(Data)<a class="headerlink" href="#data" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="allocation-with-new">
<span id="allocation-new"></span><h3>Allocation with <strong>new</strong><a class="headerlink" href="#allocation-with-new" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Go has two allocation primitives, the built-in functions <strong>new</strong> and
<strong>make</strong>. They do different things and apply to different types, which
can be confusing, but the rules are simple. Let's talk about <strong>new</strong>
first. It's a built-in function that allocates memory, but unlike its
namesakes in some other languages it does not <em>initialize</em> the memory,
it only <em>zeros</em> it. That is, <strong>new(T)</strong> allocates zeroed storage for a
new item of type <strong>T</strong> and returns its address, a value of type <strong>*T</strong>.
In Go terminology, it returns a pointer to a newly allocated zero value
of type <strong>T</strong>.</p>
<p>Since the memory returned by <strong>new</strong> is zeroed, it's helpful to arrange
when designing your data structures that the zero value of each type can
be used without further initialization. This means a user of the data
structure can create one with <strong>new</strong> and get right to work. For
example, the documentation for <strong>bytes.Buffer</strong> states that &quot;the zero
value for <strong>Buffer</strong> is an empty buffer ready to use.&quot; Similarly,
<strong>sync.Mutex</strong> does not have an explicit constructor or <strong>Init</strong> method.
Instead, the zero value for a <strong>sync.Mutex</strong> is defined to be an
unlocked mutex.</p>
<p>The zero-value-is-useful property works transitively. Consider this type
declaration.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">type</span> <span class="n">SyncedBuffer</span> <span class="n">struct</span> <span class="p">{</span>
    <span class="n">lock</span>    <span class="n">sync</span><span class="o">.</span><span class="n">Mutex</span>
    <span class="n">buffer</span>  <span class="nb">bytes</span><span class="o">.</span><span class="n">Buffer</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Values of type <strong>SyncedBuffer</strong> are also ready to use immediately upon
allocation or just declaration. In the next snippet, both <strong>p</strong> and
<strong>v</strong> will work correctly without further arrangement.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">p</span> <span class="p">:</span><span class="o">=</span> <span class="n">new</span><span class="p">(</span><span class="n">SyncedBuffer</span><span class="p">)</span>  <span class="o">//</span> <span class="nb">type</span> <span class="o">*</span><span class="n">SyncedBuffer</span>
<span class="n">var</span> <span class="n">v</span> <span class="n">SyncedBuffer</span>      <span class="o">//</span> <span class="nb">type</span>  <span class="n">SyncedBuffer</span>
</pre></div>
</div>
</div>
<div class="section" id="constructors-and-composite-literals">
<span id="composite-literals"></span><h3>Constructors and composite literals<a class="headerlink" href="#constructors-and-composite-literals" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Sometimes the zero value isn't good enough and an initializing
constructor is necessary, as in this example derived from package
<strong>os</strong>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">func</span> <span class="n">NewFile</span><span class="p">(</span><span class="n">fd</span> <span class="nb">int</span><span class="p">,</span> <span class="n">name</span> <span class="n">string</span><span class="p">)</span> <span class="o">*</span><span class="n">File</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">fd</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">nil</span>
    <span class="p">}</span>
    <span class="n">f</span> <span class="p">:</span><span class="o">=</span> <span class="n">new</span><span class="p">(</span><span class="n">File</span><span class="p">)</span>
    <span class="n">f</span><span class="o">.</span><span class="n">fd</span> <span class="o">=</span> <span class="n">fd</span>
    <span class="n">f</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
    <span class="n">f</span><span class="o">.</span><span class="n">dirinfo</span> <span class="o">=</span> <span class="n">nil</span>
    <span class="n">f</span><span class="o">.</span><span class="n">nepipe</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="n">f</span>
<span class="p">}</span>
</pre></div>
</div>
<p>There's a lot of boiler plate in there. We can simplify it using a
<em>composite literal</em>, which is an expression that creates a new instance
each time it is evaluated.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">func</span> <span class="n">NewFile</span><span class="p">(</span><span class="n">fd</span> <span class="nb">int</span><span class="p">,</span> <span class="n">name</span> <span class="n">string</span><span class="p">)</span> <span class="o">*</span><span class="n">File</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">fd</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">nil</span>
    <span class="p">}</span>
    <span class="n">f</span> <span class="p">:</span><span class="o">=</span> <span class="n">File</span><span class="p">{</span><span class="n">fd</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">nil</span><span class="p">,</span> <span class="mi">0</span><span class="p">}</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="n">f</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Note that, unlike in C, it's perfectly OK to return the address of a
local variable; the storage associated with the variable survives after
the function returns. In fact, taking the address of a composite literal
allocates a fresh instance each time it is evaluated, so we can combine
these last two lines.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">return</span> <span class="o">&amp;</span><span class="n">File</span><span class="p">{</span><span class="n">fd</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">nil</span><span class="p">,</span> <span class="mi">0</span><span class="p">}</span>
</pre></div>
</div>
<p>The fields of a composite literal are laid out in order and must all be
present. However, by labeling the elements explicitly as
<em>field</em><strong>:</strong><em>value</em> pairs, the initializers can appear in any order,
with the missing ones left as their respective zero values. Thus we
could say</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">return</span> <span class="o">&amp;</span><span class="n">File</span><span class="p">{</span><span class="n">fd</span><span class="p">:</span> <span class="n">fd</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">name</span><span class="p">}</span>
</pre></div>
</div>
<p>As a limiting case, if a composite literal contains no fields at all, it
creates a zero value for the type. The expressions <strong>new(File)</strong> and
<strong>&amp;File{}</strong> are equivalent.</p>
<p>Composite literals can also be created for arrays, slices, and maps,
with the field labels being indices or map keys as appropriate. In these
examples, the initializations work regardless of the values of
<strong>Enone</strong>, <strong>Eio</strong>, and <strong>Einval</strong>, as long as they are distinct.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="p">:</span><span class="o">=</span> <span class="p">[</span><span class="o">...</span><span class="p">]</span><span class="n">string</span>   <span class="p">{</span><span class="n">Enone</span><span class="p">:</span> <span class="s2">&quot;no error&quot;</span><span class="p">,</span> <span class="n">Eio</span><span class="p">:</span> <span class="s2">&quot;Eio&quot;</span><span class="p">,</span> <span class="n">Einval</span><span class="p">:</span> <span class="s2">&quot;invalid argument&quot;</span><span class="p">}</span>
<span class="n">s</span> <span class="p">:</span><span class="o">=</span> <span class="p">[]</span><span class="n">string</span>      <span class="p">{</span><span class="n">Enone</span><span class="p">:</span> <span class="s2">&quot;no error&quot;</span><span class="p">,</span> <span class="n">Eio</span><span class="p">:</span> <span class="s2">&quot;Eio&quot;</span><span class="p">,</span> <span class="n">Einval</span><span class="p">:</span> <span class="s2">&quot;invalid argument&quot;</span><span class="p">}</span>
<span class="n">m</span> <span class="p">:</span><span class="o">=</span> <span class="nb">map</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span><span class="n">string</span><span class="p">{</span><span class="n">Enone</span><span class="p">:</span> <span class="s2">&quot;no error&quot;</span><span class="p">,</span> <span class="n">Eio</span><span class="p">:</span> <span class="s2">&quot;Eio&quot;</span><span class="p">,</span> <span class="n">Einval</span><span class="p">:</span> <span class="s2">&quot;invalid argument&quot;</span><span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="allocation-with-make">
<span id="allocation-make"></span><h3>Allocation with <strong>make</strong><a class="headerlink" href="#allocation-with-make" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Back to allocation. The built-in function <strong>make(T,</strong><em>args</em><strong>)</strong>
serves a purpose different from <strong>new(T)</strong>. It creates slices, maps, and
channels only, and it returns an <em>initialized</em> (not <em>zeroed</em>) value of
type <strong>T</strong> (not <strong>*T</strong>). The reason for the distinction is that these
three types represent, under the covers, references to data structures
that must be initialized before use. A slice, for example, is a
three-item descriptor containing a pointer to the data (inside an
array), the length, and the capacity, and until those items are
initialized, the slice is <strong>nil</strong>. For slices, maps, and channels,
<strong>make</strong> initializes the internal data structure and prepares the value
for use. For instance,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">make</span><span class="p">([]</span><span class="nb">int</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
</pre></div>
</div>
<p>allocates an array of 100 ints and then creates a slice structure with
length 10 and a capacity of 100 pointing at the first 10 elements of the
array. (When making a slice, the capacity can be omitted; see the
section on slices for more information.) In contrast, <strong>new([]int)</strong>
returns a pointer to a newly allocated, zeroed slice structure, that is,
a pointer to a <strong>nil</strong> slice value.</p>
<p>These examples illustrate the difference between <strong>new</strong> and <strong>make</strong>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">var</span> <span class="n">p</span> <span class="o">*</span><span class="p">[]</span><span class="nb">int</span> <span class="o">=</span> <span class="n">new</span><span class="p">([]</span><span class="nb">int</span><span class="p">)</span>       <span class="o">//</span> <span class="n">allocates</span> <span class="nb">slice</span> <span class="n">structure</span><span class="p">;</span> <span class="o">*</span><span class="n">p</span> <span class="o">==</span> <span class="n">nil</span><span class="p">;</span> <span class="n">rarely</span> <span class="n">useful</span>
<span class="n">var</span> <span class="n">v</span>  <span class="p">[]</span><span class="nb">int</span> <span class="o">=</span> <span class="n">make</span><span class="p">([]</span><span class="nb">int</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span> <span class="o">//</span> <span class="n">the</span> <span class="nb">slice</span> <span class="n">v</span> <span class="n">now</span> <span class="n">refers</span> <span class="n">to</span> <span class="n">a</span> <span class="n">new</span> <span class="n">array</span> <span class="n">of</span> <span class="mi">100</span> <span class="n">ints</span>

<span class="o">//</span> <span class="n">Unnecessarily</span> <span class="nb">complex</span><span class="p">:</span>
<span class="n">var</span> <span class="n">p</span> <span class="o">*</span><span class="p">[]</span><span class="nb">int</span> <span class="o">=</span> <span class="n">new</span><span class="p">([]</span><span class="nb">int</span><span class="p">)</span>
<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">make</span><span class="p">([]</span><span class="nb">int</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>

<span class="o">//</span> <span class="n">Idiomatic</span><span class="p">:</span>
<span class="n">v</span> <span class="p">:</span><span class="o">=</span> <span class="n">make</span><span class="p">([]</span><span class="nb">int</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
</pre></div>
</div>
<p>Remember that <strong>make</strong> applies only to maps, slices and channels and
does not return a pointer. To obtain an explicit pointer allocate with
<strong>new</strong> or take the address of a variable explicitly.</p>
</div>
<div class="section" id="id15">
<h3>配列<a class="headerlink" href="#id15" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Arrays are useful when planning the detailed layout of memory and
sometimes can help avoid allocation, but primarily they are a building
block for slices, the subject of the next section. To lay the foundation
for that topic, here are a few words about arrays.</p>
<p>There are major differences between the ways arrays work in Go and C. In
Go,</p>
<ul class="simple">
<li><p>Arrays are values. Assigning one array to another copies all the
elements.</p></li>
<li><p>In particular, if you pass an array to a function, it will receive a
<em>copy</em> of the array, not a pointer to it.</p></li>
<li><p>The size of an array is part of its type. The types <strong>[10]int</strong> and
<strong>[20]int</strong> are distinct.</p></li>
</ul>
<p>The value property can be useful but also expensive; if you want C-like
behavior and efficiency, you can pass a pointer to the array.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">func</span> <span class="n">Sum</span><span class="p">(</span><span class="n">a</span> <span class="o">*</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="n">float64</span><span class="p">)</span> <span class="p">(</span><span class="nb">sum</span> <span class="n">float64</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">v</span> <span class="p">:</span><span class="o">=</span> <span class="nb">range</span> <span class="o">*</span><span class="n">a</span> <span class="p">{</span>
        <span class="nb">sum</span> <span class="o">+=</span> <span class="n">v</span>
    <span class="p">}</span>
    <span class="k">return</span>
<span class="p">}</span>

<span class="n">array</span> <span class="p">:</span><span class="o">=</span> <span class="p">[</span><span class="o">...</span><span class="p">]</span><span class="n">float64</span><span class="p">{</span><span class="mf">7.0</span><span class="p">,</span> <span class="mf">8.5</span><span class="p">,</span> <span class="mf">9.1</span><span class="p">}</span>
<span class="n">x</span> <span class="p">:</span><span class="o">=</span> <span class="n">Sum</span><span class="p">(</span><span class="o">&amp;</span><span class="n">array</span><span class="p">)</span>  <span class="o">//</span> <span class="n">Note</span> <span class="n">the</span> <span class="n">explicit</span> <span class="n">address</span><span class="o">-</span><span class="n">of</span> <span class="n">operator</span>
</pre></div>
</div>
<p>But even this style isn't idiomatic Go. Use slices instead.</p>
</div>
<div class="section" id="id16">
<h3>スライス<a class="headerlink" href="#id16" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Slices wrap arrays to give a more general, powerful, and convenient
interface to sequences of data. Except for items with explicit dimension
such as transformation matrices, most array programming in Go is done
with slices rather than simple arrays.</p>
<p>Slices hold references to an underlying array, and if you assign one
slice to another, both refer to the same array. If a function takes a
slice argument, changes it makes to the elements of the slice will be
visible to the caller, analogous to passing a pointer to the underlying
array. A <strong>Read</strong> function can therefore accept a slice argument rather
than a pointer and a count; the length within the slice sets an upper
limit of how much data to read. Here is the signature of the <strong>Read</strong>
method of the <strong>File</strong> type in package <strong>os</strong>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">func</span> <span class="p">(</span><span class="n">f</span> <span class="o">*</span><span class="n">File</span><span class="p">)</span> <span class="n">Read</span><span class="p">(</span><span class="n">buf</span> <span class="p">[]</span><span class="n">byte</span><span class="p">)</span> <span class="p">(</span><span class="n">n</span> <span class="nb">int</span><span class="p">,</span> <span class="n">err</span> <span class="n">error</span><span class="p">)</span>
</pre></div>
</div>
<p>The method returns the number of bytes read and an error value, if any.
To read into the first 32 bytes of a larger buffer <strong>buf</strong>, <em>slice</em>
(here used as a verb) the buffer.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">n</span><span class="p">,</span> <span class="n">err</span> <span class="p">:</span><span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">Read</span><span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">32</span><span class="p">])</span>
</pre></div>
</div>
<p>Such slicing is common and efficient. In fact, leaving efficiency aside
for the moment, the following snippet would also read the first 32 bytes
of the buffer.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">var</span> <span class="n">n</span> <span class="nb">int</span>
<span class="n">var</span> <span class="n">err</span> <span class="n">error</span>
<span class="k">for</span> <span class="n">i</span> <span class="p">:</span><span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">32</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
    <span class="n">nbytes</span><span class="p">,</span> <span class="n">e</span> <span class="p">:</span><span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">Read</span><span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>  <span class="o">//</span> <span class="n">Read</span> <span class="n">one</span> <span class="n">byte</span><span class="o">.</span>
    <span class="n">n</span> <span class="o">+=</span> <span class="n">nbytes</span>
    <span class="k">if</span> <span class="n">nbytes</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">e</span> <span class="o">!=</span> <span class="n">nil</span> <span class="p">{</span>
        <span class="n">err</span> <span class="o">=</span> <span class="n">e</span>
        <span class="k">break</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The length of a slice may be changed as long as it still fits within the
limits of the underlying array; just assign it to a slice of itself. The
<em>capacity</em> of a slice, accessible by the built-in function <strong>cap</strong>,
reports the maximum length the slice may assume. Here is a function to
append data to a slice. If the data exceeds the capacity, the slice is
reallocated. The resulting slice is returned. The function uses the fact
that <strong>len</strong> and <strong>cap</strong> are legal when applied to the <strong>nil</strong> slice,
and return 0.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">func</span> <span class="n">Append</span><span class="p">(</span><span class="nb">slice</span><span class="p">,</span> <span class="n">data</span> <span class="p">[]</span><span class="n">byte</span><span class="p">)</span> <span class="p">[]</span><span class="n">byte</span> <span class="p">{</span>
    <span class="n">l</span> <span class="p">:</span><span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">slice</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">l</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">cap</span><span class="p">(</span><span class="nb">slice</span><span class="p">)</span> <span class="p">{</span>  <span class="o">//</span> <span class="n">reallocate</span>
        <span class="o">//</span> <span class="n">Allocate</span> <span class="n">double</span> <span class="n">what</span><span class="s1">&#39;s needed, for future growth.</span>
        <span class="n">newSlice</span> <span class="p">:</span><span class="o">=</span> <span class="n">make</span><span class="p">([]</span><span class="n">byte</span><span class="p">,</span> <span class="p">(</span><span class="n">l</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">))</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span>
        <span class="o">//</span> <span class="n">The</span> <span class="n">copy</span> <span class="n">function</span> <span class="ow">is</span> <span class="n">predeclared</span> <span class="ow">and</span> <span class="n">works</span> <span class="k">for</span> <span class="nb">any</span> <span class="nb">slice</span> <span class="nb">type</span><span class="o">.</span>
        <span class="n">copy</span><span class="p">(</span><span class="n">newSlice</span><span class="p">,</span> <span class="nb">slice</span><span class="p">)</span>
        <span class="nb">slice</span> <span class="o">=</span> <span class="n">newSlice</span>
    <span class="p">}</span>
    <span class="nb">slice</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">l</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)]</span>
    <span class="n">copy</span><span class="p">(</span><span class="nb">slice</span><span class="p">[</span><span class="n">l</span><span class="p">:],</span> <span class="n">data</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">slice</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We must return the slice afterwards because, although <strong>Append</strong> can
modify the elements of <strong>slice</strong>, the slice itself (the run-time data
structure holding the pointer, length, and capacity) is passed by value.</p>
<p>The idea of appending to a slice is so useful it's captured by the
<strong>append</strong> built-in function. To understand that function's design,
though, we need a little more information, so we'll return to it later.</p>
</div>
<div class="section" id="two-dimensional-slices">
<span id="id17"></span><h3>Two-dimensional slices<a class="headerlink" href="#two-dimensional-slices" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Go's arrays and slices are one-dimensional. To create the equivalent of
a 2D array or slice, it is necessary to define an array-of-arrays or
slice-of-slices, like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">type</span> <span class="n">Transform</span> <span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span><span class="n">float64</span>  <span class="o">//</span> <span class="n">A</span> <span class="mi">3</span><span class="n">x3</span> <span class="n">array</span><span class="p">,</span> <span class="n">really</span> <span class="n">an</span> <span class="n">array</span> <span class="n">of</span> <span class="n">arrays</span><span class="o">.</span>
<span class="nb">type</span> <span class="n">LinesOfText</span> <span class="p">[][]</span><span class="n">byte</span>     <span class="o">//</span> <span class="n">A</span> <span class="nb">slice</span> <span class="n">of</span> <span class="n">byte</span> <span class="n">slices</span><span class="o">.</span>
</pre></div>
</div>
<p>Because slices are variable-length, it is possible to have each inner
slice be a different length. That can be a common situation, as in our
<strong>LinesOfText</strong> example: each line has an independent length.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">text</span> <span class="p">:</span><span class="o">=</span> <span class="n">LinesOfText</span><span class="p">{</span>
    <span class="p">[]</span><span class="n">byte</span><span class="p">(</span><span class="s2">&quot;Now is the time&quot;</span><span class="p">),</span>
    <span class="p">[]</span><span class="n">byte</span><span class="p">(</span><span class="s2">&quot;for all good gophers&quot;</span><span class="p">),</span>
    <span class="p">[]</span><span class="n">byte</span><span class="p">(</span><span class="s2">&quot;to bring some fun to the party.&quot;</span><span class="p">),</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Sometimes it's necessary to allocate a 2D slice, a situation that can
arise when processing scan lines of pixels, for instance. There are two
ways to achieve this. One is to allocate each slice independently; the
other is to allocate a single array and point the individual slices into
it. Which to use depends on your application. If the slices might grow
or shrink, they should be allocated independently to avoid overwriting
the next line; if not, it can be more efficient to construct the object
with a single allocation. For reference, here are sketches of the two
methods. First, a line at a time:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Allocate</span> <span class="n">the</span> <span class="n">top</span><span class="o">-</span><span class="n">level</span> <span class="nb">slice</span><span class="o">.</span>
<span class="n">picture</span> <span class="p">:</span><span class="o">=</span> <span class="n">make</span><span class="p">([][]</span><span class="n">uint8</span><span class="p">,</span> <span class="n">YSize</span><span class="p">)</span> <span class="o">//</span> <span class="n">One</span> <span class="n">row</span> <span class="n">per</span> <span class="n">unit</span> <span class="n">of</span> <span class="n">y</span><span class="o">.</span>
<span class="o">//</span> <span class="n">Loop</span> <span class="n">over</span> <span class="n">the</span> <span class="n">rows</span><span class="p">,</span> <span class="n">allocating</span> <span class="n">the</span> <span class="nb">slice</span> <span class="k">for</span> <span class="n">each</span> <span class="n">row</span><span class="o">.</span>
<span class="k">for</span> <span class="n">i</span> <span class="p">:</span><span class="o">=</span> <span class="nb">range</span> <span class="n">picture</span> <span class="p">{</span>
    <span class="n">picture</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">make</span><span class="p">([]</span><span class="n">uint8</span><span class="p">,</span> <span class="n">XSize</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>And now as one allocation, sliced into lines:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Allocate</span> <span class="n">the</span> <span class="n">top</span><span class="o">-</span><span class="n">level</span> <span class="nb">slice</span><span class="p">,</span> <span class="n">the</span> <span class="n">same</span> <span class="k">as</span> <span class="n">before</span><span class="o">.</span>
<span class="n">picture</span> <span class="p">:</span><span class="o">=</span> <span class="n">make</span><span class="p">([][]</span><span class="n">uint8</span><span class="p">,</span> <span class="n">YSize</span><span class="p">)</span> <span class="o">//</span> <span class="n">One</span> <span class="n">row</span> <span class="n">per</span> <span class="n">unit</span> <span class="n">of</span> <span class="n">y</span><span class="o">.</span>
<span class="o">//</span> <span class="n">Allocate</span> <span class="n">one</span> <span class="n">large</span> <span class="nb">slice</span> <span class="n">to</span> <span class="n">hold</span> <span class="nb">all</span> <span class="n">the</span> <span class="n">pixels</span><span class="o">.</span>
<span class="n">pixels</span> <span class="p">:</span><span class="o">=</span> <span class="n">make</span><span class="p">([]</span><span class="n">uint8</span><span class="p">,</span> <span class="n">XSize</span><span class="o">*</span><span class="n">YSize</span><span class="p">)</span> <span class="o">//</span> <span class="n">Has</span> <span class="nb">type</span> <span class="p">[]</span><span class="n">uint8</span> <span class="n">even</span> <span class="n">though</span> <span class="n">picture</span> <span class="ow">is</span> <span class="p">[][]</span><span class="n">uint8</span><span class="o">.</span>
<span class="o">//</span> <span class="n">Loop</span> <span class="n">over</span> <span class="n">the</span> <span class="n">rows</span><span class="p">,</span> <span class="n">slicing</span> <span class="n">each</span> <span class="n">row</span> <span class="kn">from</span> <span class="nn">the</span> <span class="n">front</span> <span class="n">of</span> <span class="n">the</span> <span class="n">remaining</span> <span class="n">pixels</span> <span class="nb">slice</span><span class="o">.</span>
<span class="k">for</span> <span class="n">i</span> <span class="p">:</span><span class="o">=</span> <span class="nb">range</span> <span class="n">picture</span> <span class="p">{</span>
    <span class="n">picture</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">pixels</span> <span class="o">=</span> <span class="n">pixels</span><span class="p">[:</span><span class="n">XSize</span><span class="p">],</span> <span class="n">pixels</span><span class="p">[</span><span class="n">XSize</span><span class="p">:]</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="maps">
<h3>Maps<a class="headerlink" href="#maps" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Maps are a convenient and powerful built-in data structure that
associate values of one type (the <em>key</em>) with values of another type
(the <em>element</em> or <em>value</em>). The key can be of any type for which the
equality operator is defined, such as integers, floating point and
complex numbers, strings, pointers, interfaces (as long as the dynamic
type supports equality), structs and arrays. Slices cannot be used as
map keys, because equality is not defined on them. Like slices, maps
hold references to an underlying data structure. If you pass a map to a
function that changes the contents of the map, the changes will be
visible in the caller.</p>
<p>Maps can be constructed using the usual composite literal syntax with
colon-separated key-value pairs, so it's easy to build them during
initialization.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">var</span> <span class="n">timeZone</span> <span class="o">=</span> <span class="nb">map</span><span class="p">[</span><span class="n">string</span><span class="p">]</span><span class="nb">int</span><span class="p">{</span>
    <span class="s2">&quot;UTC&quot;</span><span class="p">:</span>  <span class="mi">0</span><span class="o">*</span><span class="mi">60</span><span class="o">*</span><span class="mi">60</span><span class="p">,</span>
    <span class="s2">&quot;EST&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">5</span><span class="o">*</span><span class="mi">60</span><span class="o">*</span><span class="mi">60</span><span class="p">,</span>
    <span class="s2">&quot;CST&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">6</span><span class="o">*</span><span class="mi">60</span><span class="o">*</span><span class="mi">60</span><span class="p">,</span>
    <span class="s2">&quot;MST&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">7</span><span class="o">*</span><span class="mi">60</span><span class="o">*</span><span class="mi">60</span><span class="p">,</span>
    <span class="s2">&quot;PST&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">8</span><span class="o">*</span><span class="mi">60</span><span class="o">*</span><span class="mi">60</span><span class="p">,</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Assigning and fetching map values looks syntactically just like doing
the same for arrays and slices except that the index doesn't need to be
an integer.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">offset</span> <span class="p">:</span><span class="o">=</span> <span class="n">timeZone</span><span class="p">[</span><span class="s2">&quot;EST&quot;</span><span class="p">]</span>
</pre></div>
</div>
<p>An attempt to fetch a map value with a key that is not present in the
map will return the zero value for the type of the entries in the map.
For instance, if the map contains integers, looking up a non-existent
key will return <strong>0</strong>. A set can be implemented as a map with value type
<strong>bool</strong>. Set the map entry to <strong>true</strong> to put the value in the set, and
then test it by simple indexing.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">attended</span> <span class="p">:</span><span class="o">=</span> <span class="nb">map</span><span class="p">[</span><span class="n">string</span><span class="p">]</span><span class="nb">bool</span><span class="p">{</span>
    <span class="s2">&quot;Ann&quot;</span><span class="p">:</span> <span class="n">true</span><span class="p">,</span>
    <span class="s2">&quot;Joe&quot;</span><span class="p">:</span> <span class="n">true</span><span class="p">,</span>
    <span class="o">...</span>
<span class="p">}</span>

<span class="k">if</span> <span class="n">attended</span><span class="p">[</span><span class="n">person</span><span class="p">]</span> <span class="p">{</span> <span class="o">//</span> <span class="n">will</span> <span class="n">be</span> <span class="n">false</span> <span class="k">if</span> <span class="n">person</span> <span class="ow">is</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">the</span> <span class="nb">map</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">person</span><span class="p">,</span> <span class="s2">&quot;was at the meeting&quot;</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Sometimes you need to distinguish a missing entry from a zero value. Is
there an entry for <strong>&quot;UTC&quot;</strong> or is that 0 because it's not in the map at
all? You can discriminate with a form of multiple assignment.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">var</span> <span class="n">seconds</span> <span class="nb">int</span>
<span class="n">var</span> <span class="n">ok</span> <span class="nb">bool</span>
<span class="n">seconds</span><span class="p">,</span> <span class="n">ok</span> <span class="o">=</span> <span class="n">timeZone</span><span class="p">[</span><span class="n">tz</span><span class="p">]</span>
</pre></div>
</div>
<p>For obvious reasons this is called the “comma ok” idiom. In this
example, if <strong>tz</strong> is present, <strong>seconds</strong> will be set appropriately and
<strong>ok</strong> will be true; if not, <strong>seconds</strong> will be set to zero and <strong>ok</strong>
will be false. Here's a function that puts it together with a nice error
report:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">func</span> <span class="n">offset</span><span class="p">(</span><span class="n">tz</span> <span class="n">string</span><span class="p">)</span> <span class="nb">int</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">seconds</span><span class="p">,</span> <span class="n">ok</span> <span class="p">:</span><span class="o">=</span> <span class="n">timeZone</span><span class="p">[</span><span class="n">tz</span><span class="p">];</span> <span class="n">ok</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">seconds</span>
    <span class="p">}</span>
    <span class="n">log</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s2">&quot;unknown time zone:&quot;</span><span class="p">,</span> <span class="n">tz</span><span class="p">)</span>
    <span class="k">return</span> <span class="mi">0</span>
<span class="p">}</span>
</pre></div>
</div>
<p>To test for presence in the map without worrying about the actual value,
you can use the <a class="reference external" href="#blank">blank identifier</a> (<strong>_</strong>) in place of the
usual variable for the value.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">_</span><span class="p">,</span> <span class="n">present</span> <span class="p">:</span><span class="o">=</span> <span class="n">timeZone</span><span class="p">[</span><span class="n">tz</span><span class="p">]</span>
</pre></div>
</div>
<p>To delete a map entry, use the <strong>delete</strong> built-in function, whose
arguments are the map and the key to be deleted. It's safe to do this
even if the key is already absent from the map.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">delete</span><span class="p">(</span><span class="n">timeZone</span><span class="p">,</span> <span class="s2">&quot;PDT&quot;</span><span class="p">)</span>  <span class="o">//</span> <span class="n">Now</span> <span class="n">on</span> <span class="n">Standard</span> <span class="n">Time</span>
</pre></div>
</div>
</div>
<div class="section" id="printing">
<h3>Printing<a class="headerlink" href="#printing" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Formatted printing in Go uses a style similar to C's <strong>printf</strong> family
but is richer and more general. The functions live in the <strong>fmt</strong>
package and have capitalized names: <strong>fmt.Printf</strong>, <strong>fmt.Fprintf</strong>,
<strong>fmt.Sprintf</strong> and so on. The string functions (<strong>Sprintf</strong> etc.)
return a string rather than filling in a provided buffer.</p>
<p>You don't need to provide a format string. For each of <strong>Printf</strong>,
<strong>Fprintf</strong> and <strong>Sprintf</strong> there is another pair of functions, for
instance <strong>Print</strong> and <strong>Println</strong>. These functions do not take a format
string but instead generate a default format for each argument. The
<strong>Println</strong> versions also insert a blank between arguments and append a
newline to the output while the <strong>Print</strong> versions add blanks only if
the operand on neither side is a string. In this example each line
produces the same output.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s2">&quot;Hello </span><span class="si">%d</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="mi">23</span><span class="p">)</span>
<span class="n">fmt</span><span class="o">.</span><span class="n">Fprint</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">Stdout</span><span class="p">,</span> <span class="s2">&quot;Hello &quot;</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s2">&quot;Hello&quot;</span><span class="p">,</span> <span class="mi">23</span><span class="p">)</span>
<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">fmt</span><span class="o">.</span><span class="n">Sprint</span><span class="p">(</span><span class="s2">&quot;Hello &quot;</span><span class="p">,</span> <span class="mi">23</span><span class="p">))</span>
</pre></div>
</div>
<p>The formatted print functions <strong>fmt.Fprint</strong> and friends take as a first
argument any object that implements the <strong>io.Writer</strong> interface; the
variables <strong>os.Stdout</strong> and <strong>os.Stderr</strong> are familiar instances.</p>
<p>Here things start to diverge from C. First, the numeric formats such as
<strong>%d</strong> do not take flags for signedness or size; instead, the printing
routines use the type of the argument to decide these properties.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">var</span> <span class="n">x</span> <span class="n">uint64</span> <span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">64</span> <span class="o">-</span> <span class="mi">1</span>
<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> </span><span class="si">%x</span><span class="s2">; </span><span class="si">%d</span><span class="s2"> </span><span class="si">%x</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">int64</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">int64</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
</pre></div>
</div>
<p>prints</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">18446744073709551615</span> <span class="n">ffffffffffffffff</span><span class="p">;</span> <span class="o">-</span><span class="mi">1</span> <span class="o">-</span><span class="mi">1</span>
</pre></div>
</div>
<p>If you just want the default conversion, such as decimal for integers,
you can use the catchall format <strong>%v</strong> (for “value”); the result is
exactly what <strong>Print</strong> and <strong>Println</strong> would produce. Moreover, that
format can print <em>any</em> value, even arrays, slices, structs, and maps.
Here is a print statement for the time zone map defined in the previous
section.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s2">&quot;%v</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">timeZone</span><span class="p">)</span>  <span class="o">//</span> <span class="ow">or</span> <span class="n">just</span> <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">timeZone</span><span class="p">)</span>
</pre></div>
</div>
<p>which gives output:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">map</span><span class="p">[</span><span class="n">CST</span><span class="p">:</span><span class="o">-</span><span class="mi">21600</span> <span class="n">EST</span><span class="p">:</span><span class="o">-</span><span class="mi">18000</span> <span class="n">MST</span><span class="p">:</span><span class="o">-</span><span class="mi">25200</span> <span class="n">PST</span><span class="p">:</span><span class="o">-</span><span class="mi">28800</span> <span class="n">UTC</span><span class="p">:</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<p>For maps, <strong>Printf</strong> and friends sort the output lexicographically by
key.</p>
<p>When printing a struct, the modified format <strong>%+v</strong> annotates the fields
of the structure with their names, and for any value the alternate
format <strong>%#v</strong> prints the value in full Go syntax.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">type</span> <span class="n">T</span> <span class="n">struct</span> <span class="p">{</span>
    <span class="n">a</span> <span class="nb">int</span>
    <span class="n">b</span> <span class="n">float64</span>
    <span class="n">c</span> <span class="n">string</span>
<span class="p">}</span>
<span class="n">t</span> <span class="p">:</span><span class="o">=</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">{</span> <span class="mi">7</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.35</span><span class="p">,</span> <span class="s2">&quot;abc</span><span class="se">\t</span><span class="s2">def&quot;</span> <span class="p">}</span>
<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s2">&quot;%v</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s2">&quot;%+v</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s2">&quot;%#v</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s2">&quot;%#v</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">timeZone</span><span class="p">)</span>
</pre></div>
</div>
<p>prints</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&amp;</span><span class="p">{</span><span class="mi">7</span> <span class="o">-</span><span class="mf">2.35</span> <span class="n">abc</span>   <span class="n">def</span><span class="p">}</span>
<span class="o">&amp;</span><span class="p">{</span><span class="n">a</span><span class="p">:</span><span class="mi">7</span> <span class="n">b</span><span class="p">:</span><span class="o">-</span><span class="mf">2.35</span> <span class="n">c</span><span class="p">:</span><span class="n">abc</span>     <span class="n">def</span><span class="p">}</span>
<span class="o">&amp;</span><span class="n">main</span><span class="o">.</span><span class="n">T</span><span class="p">{</span><span class="n">a</span><span class="p">:</span><span class="mi">7</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span><span class="o">-</span><span class="mf">2.35</span><span class="p">,</span> <span class="n">c</span><span class="p">:</span><span class="s2">&quot;abc</span><span class="se">\t</span><span class="s2">def&quot;</span><span class="p">}</span>
<span class="nb">map</span><span class="p">[</span><span class="n">string</span><span class="p">]</span><span class="nb">int</span><span class="p">{</span><span class="s2">&quot;CST&quot;</span><span class="p">:</span><span class="o">-</span><span class="mi">21600</span><span class="p">,</span> <span class="s2">&quot;EST&quot;</span><span class="p">:</span><span class="o">-</span><span class="mi">18000</span><span class="p">,</span> <span class="s2">&quot;MST&quot;</span><span class="p">:</span><span class="o">-</span><span class="mi">25200</span><span class="p">,</span> <span class="s2">&quot;PST&quot;</span><span class="p">:</span><span class="o">-</span><span class="mi">28800</span><span class="p">,</span> <span class="s2">&quot;UTC&quot;</span><span class="p">:</span><span class="mi">0</span><span class="p">}</span>
</pre></div>
</div>
<p>(Note the ampersands.) That quoted string format is also available
through <strong>%q</strong> when applied to a value of type <strong>string</strong> or <strong>[]byte</strong>.
The alternate format <strong>%#q</strong> will use backquotes instead if possible.
(The <strong>%q</strong> format also applies to integers and runes, producing a
single-quoted rune constant.) Also, <strong>%x</strong> works on strings, byte arrays
and byte slices as well as on integers, generating a long hexadecimal
string, and with a space in the format (<strong>% x</strong>) it puts spaces between
the bytes.</p>
<p>Another handy format is <strong>%T</strong>, which prints the <em>type</em> of a value.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s2">&quot;%T</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">timeZone</span><span class="p">)</span>
</pre></div>
</div>
<p>prints</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">map</span><span class="p">[</span><span class="n">string</span><span class="p">]</span><span class="nb">int</span>
</pre></div>
</div>
<p>If you want to control the default format for a custom type, all that's
required is to define a method with the signature <strong>String() string</strong> on
the type. For our simple type <strong>T</strong>, that might look like this.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">func</span> <span class="p">(</span><span class="n">t</span> <span class="o">*</span><span class="n">T</span><span class="p">)</span> <span class="n">String</span><span class="p">()</span> <span class="n">string</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">fmt</span><span class="o">.</span><span class="n">Sprintf</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2">/</span><span class="si">%g</span><span class="s2">/%q&quot;</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">c</span><span class="p">)</span>
<span class="p">}</span>
<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s2">&quot;%v</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
</pre></div>
</div>
<p>to print in the format</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">7</span><span class="o">/-</span><span class="mf">2.35</span><span class="o">/</span><span class="s2">&quot;abc</span><span class="se">\t</span><span class="s2">def&quot;</span>
</pre></div>
</div>
<p>(If you need to print <em>values</em> of type <strong>T</strong> as well as pointers to
<strong>T</strong>, the receiver for <strong>String</strong> must be of value type; this example
used a pointer because that's more efficient and idiomatic for struct
types. See the section below on <a class="reference external" href="#pointers_vs_values">pointers vs. value
receivers</a> for more information.)</p>
<p>Our <strong>String</strong> method is able to call <strong>Sprintf</strong> because the print
routines are fully reentrant and can be wrapped this way. There is one
important detail to understand about this approach, however: don't
construct a <strong>String</strong> method by calling <strong>Sprintf</strong> in a way that will
recur into your <strong>String</strong> method indefinitely. This can happen if the
<strong>Sprintf</strong> call attempts to print the receiver directly as a string,
which in turn will invoke the method again. It's a common and easy
mistake to make, as this example shows.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">type</span> <span class="n">MyString</span> <span class="n">string</span>

<span class="n">func</span> <span class="p">(</span><span class="n">m</span> <span class="n">MyString</span><span class="p">)</span> <span class="n">String</span><span class="p">()</span> <span class="n">string</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">fmt</span><span class="o">.</span><span class="n">Sprintf</span><span class="p">(</span><span class="s2">&quot;MyString=</span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="o">//</span> <span class="n">Error</span><span class="p">:</span> <span class="n">will</span> <span class="n">recur</span> <span class="n">forever</span><span class="o">.</span>
<span class="p">}</span>
</pre></div>
</div>
<p>It's also easy to fix: convert the argument to the basic string type,
which does not have the method.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">type</span> <span class="n">MyString</span> <span class="n">string</span>
<span class="n">func</span> <span class="p">(</span><span class="n">m</span> <span class="n">MyString</span><span class="p">)</span> <span class="n">String</span><span class="p">()</span> <span class="n">string</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">fmt</span><span class="o">.</span><span class="n">Sprintf</span><span class="p">(</span><span class="s2">&quot;MyString=</span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">string</span><span class="p">(</span><span class="n">m</span><span class="p">))</span> <span class="o">//</span> <span class="n">OK</span><span class="p">:</span> <span class="n">note</span> <span class="n">conversion</span><span class="o">.</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In the <a class="reference external" href="#initialization">initialization section</a> we'll see another
technique that avoids this recursion.</p>
<p>Another printing technique is to pass a print routine's arguments
directly to another such routine. The signature of <strong>Printf</strong> uses the
type <strong>...interface{}</strong> for its final argument to specify that an
arbitrary number of parameters (of arbitrary type) can appear after the
format.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">func</span> <span class="n">Printf</span><span class="p">(</span><span class="nb">format</span> <span class="n">string</span><span class="p">,</span> <span class="n">v</span> <span class="o">...</span><span class="n">interface</span><span class="p">{})</span> <span class="p">(</span><span class="n">n</span> <span class="nb">int</span><span class="p">,</span> <span class="n">err</span> <span class="n">error</span><span class="p">)</span> <span class="p">{</span>
</pre></div>
</div>
<p>Within the function <strong>Printf</strong>, <strong>v</strong> acts like a variable of type
<strong>[]interface{}</strong> but if it is passed to another variadic function, it
acts like a regular list of arguments. Here is the implementation of the
function <strong>log.Println</strong> we used above. It passes its arguments directly
to <strong>fmt.Sprintln</strong> for the actual formatting.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Println</span> <span class="n">prints</span> <span class="n">to</span> <span class="n">the</span> <span class="n">standard</span> <span class="n">logger</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">manner</span> <span class="n">of</span> <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="o">.</span>
<span class="n">func</span> <span class="n">Println</span><span class="p">(</span><span class="n">v</span> <span class="o">...</span><span class="n">interface</span><span class="p">{})</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">.</span><span class="n">Output</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">fmt</span><span class="o">.</span><span class="n">Sprintln</span><span class="p">(</span><span class="n">v</span><span class="o">...</span><span class="p">))</span>  <span class="o">//</span> <span class="n">Output</span> <span class="n">takes</span> <span class="n">parameters</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">string</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We write <strong>...</strong> after <strong>v</strong> in the nested call to <strong>Sprintln</strong> to tell
the compiler to treat <strong>v</strong> as a list of arguments; otherwise it would
just pass <strong>v</strong> as a single slice argument.</p>
<p>There's even more to printing than we've covered here. See the <strong>godoc</strong>
documentation for package <strong>fmt</strong> for the details.</p>
<p>By the way, a <strong>...</strong> parameter can be of a specific type, for instance
<strong>...int</strong> for a min function that chooses the least of a list of
integers:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">func</span> <span class="n">Min</span><span class="p">(</span><span class="n">a</span> <span class="o">...</span><span class="n">int</span><span class="p">)</span> <span class="nb">int</span> <span class="p">{</span>
    <span class="nb">min</span> <span class="p">:</span><span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="o">^</span><span class="n">uint</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">)</span>  <span class="o">//</span> <span class="n">largest</span> <span class="nb">int</span>
    <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">i</span> <span class="p">:</span><span class="o">=</span> <span class="nb">range</span> <span class="n">a</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">min</span> <span class="p">{</span>
            <span class="nb">min</span> <span class="o">=</span> <span class="n">i</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">min</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="append">
<h3>Append<a class="headerlink" href="#append" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Now we have the missing piece we needed to explain the design of the
<strong>append</strong> built-in function. The signature of <strong>append</strong> is different
from our custom <strong>Append</strong> function above. Schematically, it's like
this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">func</span> <span class="n">append</span><span class="p">(</span><span class="nb">slice</span> <span class="p">[]</span><span class="n">T</span><span class="p">,</span> <span class="n">elements</span> <span class="o">...</span><span class="n">T</span><span class="p">)</span> <span class="p">[]</span><span class="n">T</span>
</pre></div>
</div>
<p>where <em>T</em> is a placeholder for any given type. You can't actually write
a function in Go where the type <strong>T</strong> is determined by the caller.
That's why <strong>append</strong> is built in: it needs support from the compiler.</p>
<p>What <strong>append</strong> does is append the elements to the end of the slice and
return the result. The result needs to be returned because, as with our
hand-written <strong>Append</strong>, the underlying array may change. This simple
example</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="p">:</span><span class="o">=</span> <span class="p">[]</span><span class="nb">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">}</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p>prints <strong>[1 2 3 4 5 6]</strong>. So <strong>append</strong> works a little like <strong>Printf</strong>,
collecting an arbitrary number of arguments.</p>
<p>But what if we wanted to do what our <strong>Append</strong> does and append a slice
to a slice? Easy: use <strong>...</strong> at the call site, just as we did in the
call to <strong>Output</strong> above. This snippet produces identical output to the
one above.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="p">:</span><span class="o">=</span> <span class="p">[]</span><span class="nb">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">}</span>
<span class="n">y</span> <span class="p">:</span><span class="o">=</span> <span class="p">[]</span><span class="nb">int</span><span class="p">{</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">}</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">...</span><span class="p">)</span>
<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p>Without that <strong>...</strong>, it wouldn't compile because the types would be
wrong; <strong>y</strong> is not of type <strong>int</strong>.</p>
</div>
</div>
<div class="section" id="initialization">
<h2>初期化(Initialization)<a class="headerlink" href="#initialization" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Although it doesn't look superficially very different from
initialization in C or C++, initialization in Go is more powerful.
Complex structures can be built during initialization and the ordering
issues among initialized objects, even among different packages, are
handled correctly.</p>
<div class="section" id="id18">
<h3>定数<a class="headerlink" href="#id18" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Constants in Go are just that—constant. They are created at compile
time, even when defined as locals in functions, and can only be numbers,
characters (runes), strings or booleans. Because of the compile-time
restriction, the expressions that define them must be constant
expressions, evaluatable by the compiler. For instance, <strong>1&lt;&lt;3</strong> is a
constant expression, while <strong>math.Sin(math.Pi/4)</strong> is not because the
function call to <strong>math.Sin</strong> needs to happen at run time.</p>
<p>In Go, enumerated constants are created using the <strong>iota</strong> enumerator.
Since <strong>iota</strong> can be part of an expression and expressions can be
implicitly repeated, it is easy to build intricate sets of values.</p>
<p>{{code &quot;/doc/progs/eff_bytesize.go&quot; `/^type ByteSize/` `/^)/<a href="#id19"><span class="problematic" id="id20">`</span></a>}}</p>
<p>The ability to attach a method such as <strong>String</strong> to any user-defined
type makes it possible for arbitrary values to format themselves
automatically for printing. Although you'll see it most often applied to
structs, this technique is also useful for scalar types such as
floating-point types like <strong>ByteSize</strong>.</p>
<p>{{code &quot;/doc/progs/eff_bytesize.go&quot; `/^func.*ByteSize.*String/`
`/^}/<a href="#id21"><span class="problematic" id="id22">`</span></a>}}</p>
<p>The expression <strong>YB</strong> prints as <strong>1.00YB</strong>, while <strong>ByteSize(1e13)</strong>
prints as <strong>9.09TB</strong>.</p>
<p>The use here of <strong>Sprintf</strong> to implement <strong>ByteSize</strong>'s <strong>String</strong>
method is safe (avoids recurring indefinitely) not because of a
conversion but because it calls <strong>Sprintf</strong> with <strong>%f</strong>, which is not a
string format: <strong>Sprintf</strong> will only call the <strong>String</strong> method when it
wants a string, and <strong>%f</strong> wants a floating-point value.</p>
</div>
<div class="section" id="id23">
<h3>変数<a class="headerlink" href="#id23" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Variables can be initialized just like constants but the initializer can
be a general expression computed at run time.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">var</span> <span class="p">(</span>
    <span class="n">home</span>   <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">Getenv</span><span class="p">(</span><span class="s2">&quot;HOME&quot;</span><span class="p">)</span>
    <span class="n">user</span>   <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">Getenv</span><span class="p">(</span><span class="s2">&quot;USER&quot;</span><span class="p">)</span>
    <span class="n">gopath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">Getenv</span><span class="p">(</span><span class="s2">&quot;GOPATH&quot;</span><span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="init">
<span id="id24"></span><h3>init関数<a class="headerlink" href="#init" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Finally, each source file can define its own niladic <strong>init</strong> function
to set up whatever state is required. (Actually each file can have
multiple <strong>init</strong> functions.) And finally means finally: <strong>init</strong> is
called after all the variable declarations in the package have evaluated
their initializers, and those are evaluated only after all the imported
packages have been initialized.</p>
<p>Besides initializations that cannot be expressed as declarations, a
common use of <strong>init</strong> functions is to verify or repair correctness of
the program state before real execution begins.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">func</span> <span class="n">init</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">user</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span> <span class="p">{</span>
        <span class="n">log</span><span class="o">.</span><span class="n">Fatal</span><span class="p">(</span><span class="s2">&quot;$USER not set&quot;</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="n">home</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span> <span class="p">{</span>
        <span class="n">home</span> <span class="o">=</span> <span class="s2">&quot;/home/&quot;</span> <span class="o">+</span> <span class="n">user</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="n">gopath</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span> <span class="p">{</span>
        <span class="n">gopath</span> <span class="o">=</span> <span class="n">home</span> <span class="o">+</span> <span class="s2">&quot;/go&quot;</span>
    <span class="p">}</span>
    <span class="o">//</span> <span class="n">gopath</span> <span class="n">may</span> <span class="n">be</span> <span class="n">overridden</span> <span class="n">by</span> <span class="o">--</span><span class="n">gopath</span> <span class="n">flag</span> <span class="n">on</span> <span class="n">command</span> <span class="n">line</span><span class="o">.</span>
    <span class="n">flag</span><span class="o">.</span><span class="n">StringVar</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gopath</span><span class="p">,</span> <span class="s2">&quot;gopath&quot;</span><span class="p">,</span> <span class="n">gopath</span><span class="p">,</span> <span class="s2">&quot;override default GOPATH&quot;</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id25">
<h2>メソッド<a class="headerlink" href="#id25" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="vs">
<span id="pointers-vs-values"></span><h3>ポインター vs 値<a class="headerlink" href="#vs" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>As we saw with <strong>ByteSize</strong>, methods can be defined for any named type
(except a pointer or an interface); the receiver does not have to be a
struct.</p>
<p>In the discussion of slices above, we wrote an <strong>Append</strong> function. We
can define it as a method on slices instead. To do this, we first
declare a named type to which we can bind the method, and then make the
receiver for the method a value of that type.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">type</span> <span class="n">ByteSlice</span> <span class="p">[]</span><span class="n">byte</span>

<span class="n">func</span> <span class="p">(</span><span class="nb">slice</span> <span class="n">ByteSlice</span><span class="p">)</span> <span class="n">Append</span><span class="p">(</span><span class="n">data</span> <span class="p">[]</span><span class="n">byte</span><span class="p">)</span> <span class="p">[]</span><span class="n">byte</span> <span class="p">{</span>
    <span class="o">//</span> <span class="n">Body</span> <span class="n">exactly</span> <span class="n">the</span> <span class="n">same</span> <span class="k">as</span> <span class="n">the</span> <span class="n">Append</span> <span class="n">function</span> <span class="n">defined</span> <span class="n">above</span><span class="o">.</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This still requires the method to return the updated slice. We can
eliminate that clumsiness by redefining the method to take a <em>pointer</em>
to a <strong>ByteSlice</strong> as its receiver, so the method can overwrite the
caller's slice.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">func</span> <span class="p">(</span><span class="n">p</span> <span class="o">*</span><span class="n">ByteSlice</span><span class="p">)</span> <span class="n">Append</span><span class="p">(</span><span class="n">data</span> <span class="p">[]</span><span class="n">byte</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">slice</span> <span class="p">:</span><span class="o">=</span> <span class="o">*</span><span class="n">p</span>
    <span class="o">//</span> <span class="n">Body</span> <span class="k">as</span> <span class="n">above</span><span class="p">,</span> <span class="n">without</span> <span class="n">the</span> <span class="k">return</span><span class="o">.</span>
    <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="nb">slice</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In fact, we can do even better. If we modify our function so it looks
like a standard <strong>Write</strong> method, like this,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">func</span> <span class="p">(</span><span class="n">p</span> <span class="o">*</span><span class="n">ByteSlice</span><span class="p">)</span> <span class="n">Write</span><span class="p">(</span><span class="n">data</span> <span class="p">[]</span><span class="n">byte</span><span class="p">)</span> <span class="p">(</span><span class="n">n</span> <span class="nb">int</span><span class="p">,</span> <span class="n">err</span> <span class="n">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">slice</span> <span class="p">:</span><span class="o">=</span> <span class="o">*</span><span class="n">p</span>
    <span class="o">//</span> <span class="n">Again</span> <span class="k">as</span> <span class="n">above</span><span class="o">.</span>
    <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="nb">slice</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">nil</span>
<span class="p">}</span>
</pre></div>
</div>
<p>then the type <strong>*ByteSlice</strong> satisfies the standard interface
<strong>io.Writer</strong>, which is handy. For instance, we can print into one.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">var</span> <span class="n">b</span> <span class="n">ByteSlice</span>
<span class="n">fmt</span><span class="o">.</span><span class="n">Fprintf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="p">,</span> <span class="s2">&quot;This hour has </span><span class="si">%d</span><span class="s2"> days</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>
</pre></div>
</div>
<p>We pass the address of a <strong>ByteSlice</strong> because only <strong>*ByteSlice</strong>
satisfies <strong>io.Writer</strong>. The rule about pointers vs. values for
receivers is that value methods can be invoked on pointers and values,
but pointer methods can only be invoked on pointers.</p>
<p>This rule arises because pointer methods can modify the receiver;
invoking them on a value would cause the method to receive a copy of the
value, so any modifications would be discarded. The language therefore
disallows this mistake. There is a handy exception, though. When the
value is addressable, the language takes care of the common case of
invoking a pointer method on a value by inserting the address operator
automatically. In our example, the variable <strong>b</strong> is addressable, so we
can call its <strong>Write</strong> method with just <strong>b.Write</strong>. The compiler will
rewrite that to <strong>(&amp;b).Write</strong> for us.</p>
<p>By the way, the idea of using <strong>Write</strong> on a slice of bytes is central
to the implementation of <strong>bytes.Buffer</strong>.</p>
</div>
</div>
<div class="section" id="interfaces-and-types">
<span id="id26"></span><h2>インターフェースとその他の型<a class="headerlink" href="#interfaces-and-types" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="id27">
<h3>インターフェース<a class="headerlink" href="#id27" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Interfaces in Go provide a way to specify the behavior of an object: if
something can do <em>this</em>, then it can be used <em>here</em>. We've seen a couple
of simple examples already; custom printers can be implemented by a
<strong>String</strong> method while <strong>Fprintf</strong> can generate output to anything with
a <strong>Write</strong> method. Interfaces with only one or two methods are common
in Go code, and are usually given a name derived from the method, such
as <strong>io.Writer</strong> for something that implements <strong>Write</strong>.</p>
<p>A type can implement multiple interfaces. For instance, a collection can
be sorted by the routines in package <strong>sort</strong> if it implements
<strong>sort.Interface</strong>, which contains <strong>Len()</strong>, <strong>Less(i, j int) bool</strong>,
and <strong>Swap(i, j int)</strong>, and it could also have a custom formatter. In
this contrived example <strong>Sequence</strong> satisfies both.</p>
<p>{{code &quot;/doc/progs/eff_sequence.go&quot; `/^type/` &quot;$&quot;}}</p>
</div>
<div class="section" id="conversions">
<h3>Conversions<a class="headerlink" href="#conversions" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>The <strong>String</strong> method of <strong>Sequence</strong> is recreating the work that
<strong>Sprint</strong> already does for slices. (It also has complexity O(N²), which
is poor.) We can share the effort (and also speed it up) if we convert
the <strong>Sequence</strong> to a plain <strong>[]int</strong> before calling <strong>Sprint</strong>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">func</span> <span class="p">(</span><span class="n">s</span> <span class="n">Sequence</span><span class="p">)</span> <span class="n">String</span><span class="p">()</span> <span class="n">string</span> <span class="p">{</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">Copy</span><span class="p">()</span>
    <span class="n">sort</span><span class="o">.</span><span class="n">Sort</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">fmt</span><span class="o">.</span><span class="n">Sprint</span><span class="p">([]</span><span class="nb">int</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This method is another example of the conversion technique for calling
<strong>Sprintf</strong> safely from a <strong>String</strong> method. Because the two types
(<strong>Sequence</strong> and <strong>[]int</strong>) are the same if we ignore the type name,
it's legal to convert between them. The conversion doesn't create a new
value, it just temporarily acts as though the existing value has a new
type. (There are other legal conversions, such as from integer to
floating point, that do create a new value.)</p>
<p>It's an idiom in Go programs to convert the type of an expression to
access a different set of methods. As an example, we could use the
existing type <strong>sort.IntSlice</strong> to reduce the entire example to this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">type</span> <span class="n">Sequence</span> <span class="p">[]</span><span class="nb">int</span>

<span class="o">//</span> <span class="n">Method</span> <span class="k">for</span> <span class="n">printing</span> <span class="o">-</span> <span class="n">sorts</span> <span class="n">the</span> <span class="n">elements</span> <span class="n">before</span> <span class="n">printing</span>
<span class="n">func</span> <span class="p">(</span><span class="n">s</span> <span class="n">Sequence</span><span class="p">)</span> <span class="n">String</span><span class="p">()</span> <span class="n">string</span> <span class="p">{</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">Copy</span><span class="p">()</span>
    <span class="n">sort</span><span class="o">.</span><span class="n">IntSlice</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">.</span><span class="n">Sort</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">fmt</span><span class="o">.</span><span class="n">Sprint</span><span class="p">([]</span><span class="nb">int</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Now, instead of having <strong>Sequence</strong> implement multiple interfaces
(sorting and printing), we're using the ability of a data item to be
converted to multiple types (<strong>Sequence</strong>, <strong>sort.IntSlice</strong> and
<strong>[]int</strong>), each of which does some part of the job. That's more unusual
in practice but can be effective.</p>
</div>
<div class="section" id="interface-conversions-and-type-assertions">
<span id="interface-conversions"></span><h3>Interface conversions and type assertions<a class="headerlink" href="#interface-conversions-and-type-assertions" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><a class="reference external" href="#type_switch">Type switches</a> are a form of conversion: they take an
interface and, for each case in the switch, in a sense convert it to the
type of that case. Here's a simplified version of how the code under
<strong>fmt.Printf</strong> turns a value into a string using a type switch. If it's
already a string, we want the actual string value held by the interface,
while if it has a <strong>String</strong> method we want the result of calling the
method.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">type</span> <span class="n">Stringer</span> <span class="n">interface</span> <span class="p">{</span>
    <span class="n">String</span><span class="p">()</span> <span class="n">string</span>
<span class="p">}</span>

<span class="n">var</span> <span class="n">value</span> <span class="n">interface</span><span class="p">{}</span> <span class="o">//</span> <span class="n">Value</span> <span class="n">provided</span> <span class="n">by</span> <span class="n">caller</span><span class="o">.</span>
<span class="n">switch</span> <span class="nb">str</span> <span class="p">:</span><span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="p">(</span><span class="nb">type</span><span class="p">)</span> <span class="p">{</span>
<span class="n">case</span> <span class="n">string</span><span class="p">:</span>
    <span class="k">return</span> <span class="nb">str</span>
<span class="n">case</span> <span class="n">Stringer</span><span class="p">:</span>
    <span class="k">return</span> <span class="nb">str</span><span class="o">.</span><span class="n">String</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The first case finds a concrete value; the second converts the interface
into another interface. It's perfectly fine to mix types this way.</p>
<p>What if there's only one type we care about? If we know the value holds
a <strong>string</strong> and we just want to extract it? A one-case type switch
would do, but so would a <em>type assertion</em>. A type assertion takes an
interface value and extracts from it a value of the specified explicit
type. The syntax borrows from the clause opening a type switch, but with
an explicit type rather than the <strong>type</strong> keyword:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">value</span><span class="o">.</span><span class="p">(</span><span class="n">typeName</span><span class="p">)</span>
</pre></div>
</div>
<p>and the result is a new value with the static type <strong>typeName</strong>. That
type must either be the concrete type held by the interface, or a second
interface type that the value can be converted to. To extract the string
we know is in the value, we could write:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">str</span> <span class="p">:</span><span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
</pre></div>
</div>
<p>But if it turns out that the value does not contain a string, the
program will crash with a run-time error. To guard against that, use the
&quot;comma, ok&quot; idiom to test, safely, whether the value is a string:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">str</span><span class="p">,</span> <span class="n">ok</span> <span class="p">:</span><span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
<span class="k">if</span> <span class="n">ok</span> <span class="p">{</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s2">&quot;string value is: %q</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s2">&quot;value is not a string</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If the type assertion fails, <strong>str</strong> will still exist and be of type
string, but it will have the zero value, an empty string.</p>
<p>As an illustration of the capability, here's an <strong>if</strong>-<strong>else</strong>
statement that's equivalent to the type switch that opened this section.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="nb">str</span><span class="p">,</span> <span class="n">ok</span> <span class="p">:</span><span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="p">(</span><span class="n">string</span><span class="p">);</span> <span class="n">ok</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">str</span>
<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nb">str</span><span class="p">,</span> <span class="n">ok</span> <span class="p">:</span><span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="p">(</span><span class="n">Stringer</span><span class="p">);</span> <span class="n">ok</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">str</span><span class="o">.</span><span class="n">String</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="generality">
<h3>Generality<a class="headerlink" href="#generality" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>If a type exists only to implement an interface and will never have
exported methods beyond that interface, there is no need to export the
type itself. Exporting just the interface makes it clear the value has
no interesting behavior beyond what is described in the interface. It
also avoids the need to repeat the documentation on every instance of a
common method.</p>
<p>In such cases, the constructor should return an interface value rather
than the implementing type. As an example, in the hash libraries both
<strong>crc32.NewIEEE</strong> and <strong>adler32.New</strong> return the interface type
<strong>hash.Hash32</strong>. Substituting the CRC-32 algorithm for Adler-32 in a Go
program requires only changing the constructor call; the rest of the
code is unaffected by the change of algorithm.</p>
<p>A similar approach allows the streaming cipher algorithms in the various
<strong>crypto</strong> packages to be separated from the block ciphers they chain
together. The <strong>Block</strong> interface in the <strong>crypto/cipher</strong> package
specifies the behavior of a block cipher, which provides encryption of a
single block of data. Then, by analogy with the <strong>bufio</strong> package,
cipher packages that implement this interface can be used to construct
streaming ciphers, represented by the <strong>Stream</strong> interface, without
knowing the details of the block encryption.</p>
<p>The <strong>crypto/cipher</strong> interfaces look like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">type</span> <span class="n">Block</span> <span class="n">interface</span> <span class="p">{</span>
    <span class="n">BlockSize</span><span class="p">()</span> <span class="nb">int</span>
    <span class="n">Encrypt</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">src</span> <span class="p">[]</span><span class="n">byte</span><span class="p">)</span>
    <span class="n">Decrypt</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">src</span> <span class="p">[]</span><span class="n">byte</span><span class="p">)</span>
<span class="p">}</span>

<span class="nb">type</span> <span class="n">Stream</span> <span class="n">interface</span> <span class="p">{</span>
    <span class="n">XORKeyStream</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">src</span> <span class="p">[]</span><span class="n">byte</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Here's the definition of the counter mode (CTR) stream, which turns a
block cipher into a streaming cipher; notice that the block cipher's
details are abstracted away:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">NewCTR</span> <span class="n">returns</span> <span class="n">a</span> <span class="n">Stream</span> <span class="n">that</span> <span class="n">encrypts</span><span class="o">/</span><span class="n">decrypts</span> <span class="n">using</span> <span class="n">the</span> <span class="n">given</span> <span class="n">Block</span> <span class="ow">in</span>
<span class="o">//</span> <span class="n">counter</span> <span class="n">mode</span><span class="o">.</span> <span class="n">The</span> <span class="n">length</span> <span class="n">of</span> <span class="n">iv</span> <span class="n">must</span> <span class="n">be</span> <span class="n">the</span> <span class="n">same</span> <span class="k">as</span> <span class="n">the</span> <span class="n">Block</span><span class="s1">&#39;s block size.</span>
<span class="n">func</span> <span class="n">NewCTR</span><span class="p">(</span><span class="n">block</span> <span class="n">Block</span><span class="p">,</span> <span class="n">iv</span> <span class="p">[]</span><span class="n">byte</span><span class="p">)</span> <span class="n">Stream</span>
</pre></div>
</div>
<p><strong>NewCTR</strong> applies not just to one specific encryption algorithm and
data source but to any implementation of the <strong>Block</strong> interface and any
<strong>Stream</strong>. Because they return interface values, replacing CTR
encryption with other encryption modes is a localized change. The
constructor calls must be edited, but because the surrounding code must
treat the result only as a <strong>Stream</strong>, it won't notice the difference.</p>
</div>
<div class="section" id="interface-methods">
<span id="id28"></span><h3>インターフェースとメソッド<a class="headerlink" href="#interface-methods" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Since almost anything can have methods attached, almost anything can
satisfy an interface. One illustrative example is in the <strong>http</strong>
package, which defines the <strong>Handler</strong> interface. Any object that
implements <strong>Handler</strong> can serve HTTP requests.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">type</span> <span class="n">Handler</span> <span class="n">interface</span> <span class="p">{</span>
    <span class="n">ServeHTTP</span><span class="p">(</span><span class="n">ResponseWriter</span><span class="p">,</span> <span class="o">*</span><span class="n">Request</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong>ResponseWriter</strong> is itself an interface that provides access to the
methods needed to return the response to the client. Those methods
include the standard <strong>Write</strong> method, so an <strong>http.ResponseWriter</strong> can
be used wherever an <strong>io.Writer</strong> can be used. <strong>Request</strong> is a struct
containing a parsed representation of the request from the client.</p>
<p>For brevity, let's ignore POSTs and assume HTTP requests are always
GETs; that simplification does not affect the way the handlers are set
up. Here's a trivial but complete implementation of a handler to count
the number of times the page is visited.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Simple</span> <span class="n">counter</span> <span class="n">server</span><span class="o">.</span>
<span class="nb">type</span> <span class="n">Counter</span> <span class="n">struct</span> <span class="p">{</span>
    <span class="n">n</span> <span class="nb">int</span>
<span class="p">}</span>

<span class="n">func</span> <span class="p">(</span><span class="n">ctr</span> <span class="o">*</span><span class="n">Counter</span><span class="p">)</span> <span class="n">ServeHTTP</span><span class="p">(</span><span class="n">w</span> <span class="n">http</span><span class="o">.</span><span class="n">ResponseWriter</span><span class="p">,</span> <span class="n">req</span> <span class="o">*</span><span class="n">http</span><span class="o">.</span><span class="n">Request</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ctr</span><span class="o">.</span><span class="n">n</span><span class="o">++</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Fprintf</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="s2">&quot;counter = </span><span class="si">%d</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">ctr</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>(Keeping with our theme, note how <strong>Fprintf</strong> can print to an
<strong>http.ResponseWriter</strong>.) For reference, here's how to attach such a
server to a node on the URL tree.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="s2">&quot;net/http&quot;</span>
<span class="o">...</span>
<span class="n">ctr</span> <span class="p">:</span><span class="o">=</span> <span class="n">new</span><span class="p">(</span><span class="n">Counter</span><span class="p">)</span>
<span class="n">http</span><span class="o">.</span><span class="n">Handle</span><span class="p">(</span><span class="s2">&quot;/counter&quot;</span><span class="p">,</span> <span class="n">ctr</span><span class="p">)</span>
</pre></div>
</div>
<p>But why make <strong>Counter</strong> a struct? An integer is all that's needed. (The
receiver needs to be a pointer so the increment is visible to the
caller.)</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Simpler</span> <span class="n">counter</span> <span class="n">server</span><span class="o">.</span>
<span class="nb">type</span> <span class="n">Counter</span> <span class="nb">int</span>

<span class="n">func</span> <span class="p">(</span><span class="n">ctr</span> <span class="o">*</span><span class="n">Counter</span><span class="p">)</span> <span class="n">ServeHTTP</span><span class="p">(</span><span class="n">w</span> <span class="n">http</span><span class="o">.</span><span class="n">ResponseWriter</span><span class="p">,</span> <span class="n">req</span> <span class="o">*</span><span class="n">http</span><span class="o">.</span><span class="n">Request</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">*</span><span class="n">ctr</span><span class="o">++</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Fprintf</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="s2">&quot;counter = </span><span class="si">%d</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">ctr</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>What if your program has some internal state that needs to be notified
that a page has been visited? Tie a channel to the web page.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">A</span> <span class="n">channel</span> <span class="n">that</span> <span class="n">sends</span> <span class="n">a</span> <span class="n">notification</span> <span class="n">on</span> <span class="n">each</span> <span class="n">visit</span><span class="o">.</span>
<span class="o">//</span> <span class="p">(</span><span class="n">Probably</span> <span class="n">want</span> <span class="n">the</span> <span class="n">channel</span> <span class="n">to</span> <span class="n">be</span> <span class="n">buffered</span><span class="o">.</span><span class="p">)</span>
<span class="nb">type</span> <span class="n">Chan</span> <span class="n">chan</span> <span class="o">*</span><span class="n">http</span><span class="o">.</span><span class="n">Request</span>

<span class="n">func</span> <span class="p">(</span><span class="n">ch</span> <span class="n">Chan</span><span class="p">)</span> <span class="n">ServeHTTP</span><span class="p">(</span><span class="n">w</span> <span class="n">http</span><span class="o">.</span><span class="n">ResponseWriter</span><span class="p">,</span> <span class="n">req</span> <span class="o">*</span><span class="n">http</span><span class="o">.</span><span class="n">Request</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ch</span> <span class="o">&lt;-</span> <span class="n">req</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Fprint</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="s2">&quot;notification sent&quot;</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Finally, let's say we wanted to present on <strong>/args</strong> the arguments used
when invoking the server binary. It's easy to write a function to print
the arguments.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">func</span> <span class="n">ArgServer</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">Args</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>How do we turn that into an HTTP server? We could make <strong>ArgServer</strong> a
method of some type whose value we ignore, but there's a cleaner way.
Since we can define a method for any type except pointers and
interfaces, we can write a method for a function. The <strong>http</strong> package
contains this code:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">The</span> <span class="n">HandlerFunc</span> <span class="nb">type</span> <span class="ow">is</span> <span class="n">an</span> <span class="n">adapter</span> <span class="n">to</span> <span class="n">allow</span> <span class="n">the</span> <span class="n">use</span> <span class="n">of</span>
<span class="o">//</span> <span class="n">ordinary</span> <span class="n">functions</span> <span class="k">as</span> <span class="n">HTTP</span> <span class="n">handlers</span><span class="o">.</span>  <span class="n">If</span> <span class="n">f</span> <span class="ow">is</span> <span class="n">a</span> <span class="n">function</span>
<span class="o">//</span> <span class="k">with</span> <span class="n">the</span> <span class="n">appropriate</span> <span class="n">signature</span><span class="p">,</span> <span class="n">HandlerFunc</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="ow">is</span> <span class="n">a</span>
<span class="o">//</span> <span class="n">Handler</span> <span class="nb">object</span> <span class="n">that</span> <span class="n">calls</span> <span class="n">f</span><span class="o">.</span>
<span class="nb">type</span> <span class="n">HandlerFunc</span> <span class="n">func</span><span class="p">(</span><span class="n">ResponseWriter</span><span class="p">,</span> <span class="o">*</span><span class="n">Request</span><span class="p">)</span>

<span class="o">//</span> <span class="n">ServeHTTP</span> <span class="n">calls</span> <span class="n">f</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">req</span><span class="p">)</span><span class="o">.</span>
<span class="n">func</span> <span class="p">(</span><span class="n">f</span> <span class="n">HandlerFunc</span><span class="p">)</span> <span class="n">ServeHTTP</span><span class="p">(</span><span class="n">w</span> <span class="n">ResponseWriter</span><span class="p">,</span> <span class="n">req</span> <span class="o">*</span><span class="n">Request</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">f</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">req</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong>HandlerFunc</strong> is a type with a method, <strong>ServeHTTP</strong>, so values of
that type can serve HTTP requests. Look at the implementation of the
method: the receiver is a function, <strong>f</strong>, and the method calls <strong>f</strong>.
That may seem odd but it's not that different from, say, the receiver
being a channel and the method sending on the channel.</p>
<p>To make <strong>ArgServer</strong> into an HTTP server, we first modify it to have
the right signature.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Argument</span> <span class="n">server</span><span class="o">.</span>
<span class="n">func</span> <span class="n">ArgServer</span><span class="p">(</span><span class="n">w</span> <span class="n">http</span><span class="o">.</span><span class="n">ResponseWriter</span><span class="p">,</span> <span class="n">req</span> <span class="o">*</span><span class="n">http</span><span class="o">.</span><span class="n">Request</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Fprintln</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">Args</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong>ArgServer</strong> now has same signature as <strong>HandlerFunc</strong>, so it can be
converted to that type to access its methods, just as we converted
<strong>Sequence</strong> to <strong>IntSlice</strong> to access <strong>IntSlice.Sort</strong>. The code to
set it up is concise:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">http</span><span class="o">.</span><span class="n">Handle</span><span class="p">(</span><span class="s2">&quot;/args&quot;</span><span class="p">,</span> <span class="n">http</span><span class="o">.</span><span class="n">HandlerFunc</span><span class="p">(</span><span class="n">ArgServer</span><span class="p">))</span>
</pre></div>
</div>
<p>When someone visits the page <strong>/args</strong>, the handler installed at that
page has value <strong>ArgServer</strong> and type <strong>HandlerFunc</strong>. The HTTP server
will invoke the method <strong>ServeHTTP</strong> of that type, with <strong>ArgServer</strong> as
the receiver, which will in turn call <strong>ArgServer</strong> (via the invocation
<strong>f(w, req)</strong> inside <strong>HandlerFunc.ServeHTTP</strong>). The arguments will then
be displayed.</p>
<p>In this section we have made an HTTP server from a struct, an integer, a
channel, and a function, all because interfaces are just sets of
methods, which can be defined for (almost) any type.</p>
</div>
</div>
<div class="section" id="blank">
<span id="id29"></span><h2>空白の識別子<a class="headerlink" href="#blank" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>We've mentioned the blank identifier a couple of times now, in the
context of <strong>`for</strong> <strong>range</strong> loops &lt;#for&gt;`__ and <a class="reference external" href="#maps">maps</a>. The
blank identifier can be assigned or declared with any value of any type,
with the value discarded harmlessly. It's a bit like writing to the Unix
<strong>/dev/null</strong> file: it represents a write-only value to be used as a
place-holder where a variable is needed but the actual value is
irrelevant. It has uses beyond those we've seen already.</p>
<div class="section" id="the-blank-identifier-in-multiple-assignment">
<span id="blank-assign"></span><h3>The blank identifier in multiple assignment<a class="headerlink" href="#the-blank-identifier-in-multiple-assignment" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>The use of a blank identifier in a <strong>for</strong> <strong>range</strong> loop is a special
case of a general situation: multiple assignment.</p>
<p>If an assignment requires multiple values on the left side, but one of
the values will not be used by the program, a blank identifier on the
left-hand-side of the assignment avoids the need to create a dummy
variable and makes it clear that the value is to be discarded. For
instance, when calling a function that returns a value and an error, but
only the error is important, use the blank identifier to discard the
irrelevant value.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">_</span><span class="p">,</span> <span class="n">err</span> <span class="p">:</span><span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">Stat</span><span class="p">(</span><span class="n">path</span><span class="p">);</span> <span class="n">os</span><span class="o">.</span><span class="n">IsNotExist</span><span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> does not exist</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Occasionally you'll see code that discards the error value in order to
ignore the error; this is terrible practice. Always check error returns;
they're provided for a reason.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>// Bad! This code will crash if path does not exist.
fi, _ := os.Stat(path)
if fi.IsDir() {
    fmt.Printf(&quot;%s is a directory\n&quot;, path)
}
</pre></div>
</div>
</div>
<div class="section" id="unused-imports-and-variables">
<span id="blank-unused"></span><h3>Unused imports and variables<a class="headerlink" href="#unused-imports-and-variables" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>It is an error to import a package or to declare a variable without
using it. Unused imports bloat the program and slow compilation, while a
variable that is initialized but not used is at least a wasted
computation and perhaps indicative of a larger bug. When a program is
under active development, however, unused imports and variables often
arise and it can be annoying to delete them just to have the compilation
proceed, only to have them be needed again later. The blank identifier
provides a workaround.</p>
<p>This half-written program has two unused imports (<strong>fmt</strong> and <strong>io</strong>)
and an unused variable (<strong>fd</strong>), so it will not compile, but it would be
nice to see if the code so far is correct.</p>
<p>{{code &quot;/doc/progs/eff_unused1.go&quot; `/package/` `$`}}</p>
<p>To silence complaints about the unused imports, use a blank identifier
to refer to a symbol from the imported package. Similarly, assigning the
unused variable <strong>fd</strong> to the blank identifier will silence the unused
variable error. This version of the program does compile.</p>
<p>{{code &quot;/doc/progs/eff_unused2.go&quot; `/package/` `$`}}</p>
<p>By convention, the global declarations to silence import errors should
come right after the imports and be commented, both to make them easy to
find and as a reminder to clean things up later.</p>
</div>
<div class="section" id="import-for-side-effect">
<span id="blank-import"></span><h3>Import for side effect<a class="headerlink" href="#import-for-side-effect" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>An unused import like <strong>fmt</strong> or <strong>io</strong> in the previous example should
eventually be used or removed: blank assignments identify code as a work
in progress. But sometimes it is useful to import a package only for its
side effects, without any explicit use. For example, during its <strong>init</strong>
function, the <strong>net/http/pprof</strong> package registers HTTP handlers that
provide debugging information. It has an exported API, but most clients
need only the handler registration and access the data through a web
page. To import the package only for its side effects, rename the
package to the blank identifier:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">_</span> <span class="s2">&quot;net/http/pprof&quot;</span>
</pre></div>
</div>
<p>This form of import makes clear that the package is being imported for
its side effects, because there is no other possible use of the package:
in this file, it doesn't have a name. (If it did, and we didn't use that
name, the compiler would reject the program.)</p>
</div>
<div class="section" id="interface-checks">
<span id="blank-implements"></span><h3>Interface checks<a class="headerlink" href="#interface-checks" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>As we saw in the discussion of <a class="reference external" href="#interfaces_and_types">interfaces</a>
above, a type need not declare explicitly that it implements an
interface. Instead, a type implements the interface just by implementing
the interface's methods. In practice, most interface conversions are
static and therefore checked at compile time. For example, passing an
<strong>*os.File</strong> to a function expecting an <strong>io.Reader</strong> will not compile
unless <strong>*os.File</strong> implements the <strong>io.Reader</strong> interface.</p>
<p>Some interface checks do happen at run-time, though. One instance is in
the <strong>encoding/json</strong> package, which defines a <strong>Marshaler</strong> interface.
When the JSON encoder receives a value that implements that interface,
the encoder invokes the value's marshaling method to convert it to JSON
instead of doing the standard conversion. The encoder checks this
property at run time with a <a class="reference external" href="#interface_conversions">type assertion</a>
like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">m</span><span class="p">,</span> <span class="n">ok</span> <span class="p">:</span><span class="o">=</span> <span class="n">val</span><span class="o">.</span><span class="p">(</span><span class="n">json</span><span class="o">.</span><span class="n">Marshaler</span><span class="p">)</span>
</pre></div>
</div>
<p>If it's necessary only to ask whether a type implements an interface,
without actually using the interface itself, perhaps as part of an error
check, use the blank identifier to ignore the type-asserted value:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">_</span><span class="p">,</span> <span class="n">ok</span> <span class="p">:</span><span class="o">=</span> <span class="n">val</span><span class="o">.</span><span class="p">(</span><span class="n">json</span><span class="o">.</span><span class="n">Marshaler</span><span class="p">);</span> <span class="n">ok</span> <span class="p">{</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s2">&quot;value %v of type %T implements json.Marshaler</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>One place this situation arises is when it is necessary to guarantee
within the package implementing the type that it actually satisfies the
interface. If a type—for example, <strong>json.RawMessage</strong>—needs a custom
JSON representation, it should implement <strong>json.Marshaler</strong>, but there
are no static conversions that would cause the compiler to verify this
automatically. If the type inadvertently fails to satisfy the interface,
the JSON encoder will still work, but will not use the custom
implementation. To guarantee that the implementation is correct, a
global declaration using the blank identifier can be used in the
package:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">var</span> <span class="n">_</span> <span class="n">json</span><span class="o">.</span><span class="n">Marshaler</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">RawMessage</span><span class="p">)(</span><span class="n">nil</span><span class="p">)</span>
</pre></div>
</div>
<p>In this declaration, the assignment involving a conversion of a
<strong>*RawMessage</strong> to a <strong>Marshaler</strong> requires that <strong>*RawMessage</strong>
implements <strong>Marshaler</strong>, and that property will be checked at compile
time. Should the <strong>json.Marshaler</strong> interface change, this package will
no longer compile and we will be on notice that it needs to be updated.</p>
<p>The appearance of the blank identifier in this construct indicates that
the declaration exists only for the type checking, not to create a
variable. Don't do this for every type that satisfies an interface,
though. By convention, such declarations are only used when there are no
static conversions already present in the code, which is a rare event.</p>
</div>
</div>
<div class="section" id="id30">
<h2>埋め込み<a class="headerlink" href="#id30" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Go does not provide the typical, type-driven notion of subclassing, but
it does have the ability to “borrow” pieces of an implementation by
<em>embedding</em> types within a struct or interface.</p>
<p>Interface embedding is very simple. We've mentioned the <strong>io.Reader</strong>
and <strong>io.Writer</strong> interfaces before; here are their definitions.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">type</span> <span class="n">Reader</span> <span class="n">interface</span> <span class="p">{</span>
    <span class="n">Read</span><span class="p">(</span><span class="n">p</span> <span class="p">[]</span><span class="n">byte</span><span class="p">)</span> <span class="p">(</span><span class="n">n</span> <span class="nb">int</span><span class="p">,</span> <span class="n">err</span> <span class="n">error</span><span class="p">)</span>
<span class="p">}</span>

<span class="nb">type</span> <span class="n">Writer</span> <span class="n">interface</span> <span class="p">{</span>
    <span class="n">Write</span><span class="p">(</span><span class="n">p</span> <span class="p">[]</span><span class="n">byte</span><span class="p">)</span> <span class="p">(</span><span class="n">n</span> <span class="nb">int</span><span class="p">,</span> <span class="n">err</span> <span class="n">error</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The <strong>io</strong> package also exports several other interfaces that specify
objects that can implement several such methods. For instance, there is
<strong>io.ReadWriter</strong>, an interface containing both <strong>Read</strong> and <strong>Write</strong>.
We could specify <strong>io.ReadWriter</strong> by listing the two methods
explicitly, but it's easier and more evocative to embed the two
interfaces to form the new one, like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">ReadWriter</span> <span class="ow">is</span> <span class="n">the</span> <span class="n">interface</span> <span class="n">that</span> <span class="n">combines</span> <span class="n">the</span> <span class="n">Reader</span> <span class="ow">and</span> <span class="n">Writer</span> <span class="n">interfaces</span><span class="o">.</span>
<span class="nb">type</span> <span class="n">ReadWriter</span> <span class="n">interface</span> <span class="p">{</span>
    <span class="n">Reader</span>
    <span class="n">Writer</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This says just what it looks like: A <strong>ReadWriter</strong> can do what a
<strong>Reader</strong> does <em>and</em> what a <strong>Writer</strong> does; it is a union of the
embedded interfaces (which must be disjoint sets of methods). Only
interfaces can be embedded within interfaces.</p>
<p>The same basic idea applies to structs, but with more far-reaching
implications. The <strong>bufio</strong> package has two struct types,
<strong>bufio.Reader</strong> and <strong>bufio.Writer</strong>, each of which of course
implements the analogous interfaces from package <strong>io</strong>. And <strong>bufio</strong>
also implements a buffered reader/writer, which it does by combining a
reader and a writer into one struct using embedding: it lists the types
within the struct but does not give them field names.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">ReadWriter</span> <span class="n">stores</span> <span class="n">pointers</span> <span class="n">to</span> <span class="n">a</span> <span class="n">Reader</span> <span class="ow">and</span> <span class="n">a</span> <span class="n">Writer</span><span class="o">.</span>
<span class="o">//</span> <span class="n">It</span> <span class="n">implements</span> <span class="n">io</span><span class="o">.</span><span class="n">ReadWriter</span><span class="o">.</span>
<span class="nb">type</span> <span class="n">ReadWriter</span> <span class="n">struct</span> <span class="p">{</span>
    <span class="o">*</span><span class="n">Reader</span>  <span class="o">//</span> <span class="o">*</span><span class="n">bufio</span><span class="o">.</span><span class="n">Reader</span>
    <span class="o">*</span><span class="n">Writer</span>  <span class="o">//</span> <span class="o">*</span><span class="n">bufio</span><span class="o">.</span><span class="n">Writer</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The embedded elements are pointers to structs and of course must be
initialized to point to valid structs before they can be used. The
<strong>ReadWriter</strong> struct could be written as</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">type</span> <span class="n">ReadWriter</span> <span class="n">struct</span> <span class="p">{</span>
    <span class="n">reader</span> <span class="o">*</span><span class="n">Reader</span>
    <span class="n">writer</span> <span class="o">*</span><span class="n">Writer</span>
<span class="p">}</span>
</pre></div>
</div>
<p>but then to promote the methods of the fields and to satisfy the <strong>io</strong>
interfaces, we would also need to provide forwarding methods, like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">func</span> <span class="p">(</span><span class="n">rw</span> <span class="o">*</span><span class="n">ReadWriter</span><span class="p">)</span> <span class="n">Read</span><span class="p">(</span><span class="n">p</span> <span class="p">[]</span><span class="n">byte</span><span class="p">)</span> <span class="p">(</span><span class="n">n</span> <span class="nb">int</span><span class="p">,</span> <span class="n">err</span> <span class="n">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">rw</span><span class="o">.</span><span class="n">reader</span><span class="o">.</span><span class="n">Read</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>By embedding the structs directly, we avoid this bookkeeping. The
methods of embedded types come along for free, which means that
<strong>bufio.ReadWriter</strong> not only has the methods of <strong>bufio.Reader</strong> and
<strong>bufio.Writer</strong>, it also satisfies all three interfaces: <strong>io.Reader</strong>,
<strong>io.Writer</strong>, and <strong>io.ReadWriter</strong>.</p>
<p>There's an important way in which embedding differs from subclassing.
When we embed a type, the methods of that type become methods of the
outer type, but when they are invoked the receiver of the method is the
inner type, not the outer one. In our example, when the <strong>Read</strong> method
of a <strong>bufio.ReadWriter</strong> is invoked, it has exactly the same effect as
the forwarding method written out above; the receiver is the <strong>reader</strong>
field of the <strong>ReadWriter</strong>, not the <strong>ReadWriter</strong> itself.</p>
<p>Embedding can also be a simple convenience. This example shows an
embedded field alongside a regular, named field.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">type</span> <span class="n">Job</span> <span class="n">struct</span> <span class="p">{</span>
    <span class="n">Command</span> <span class="n">string</span>
    <span class="o">*</span><span class="n">log</span><span class="o">.</span><span class="n">Logger</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The <strong>Job</strong> type now has the <strong>Print</strong>, <strong>Printf</strong>, <strong>Println</strong> and
other methods of <strong>*log.Logger</strong>. We could have given the <strong>Logger</strong> a
field name, of course, but it's not necessary to do so. And now, once
initialized, we can log to the <strong>Job</strong>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">job</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s2">&quot;starting now...&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>The <strong>Logger</strong> is a regular field of the <strong>Job</strong> struct, so we can
initialize it in the usual way inside the constructor for <strong>Job</strong>, like
this,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">func</span> <span class="n">NewJob</span><span class="p">(</span><span class="n">command</span> <span class="n">string</span><span class="p">,</span> <span class="n">logger</span> <span class="o">*</span><span class="n">log</span><span class="o">.</span><span class="n">Logger</span><span class="p">)</span> <span class="o">*</span><span class="n">Job</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="n">Job</span><span class="p">{</span><span class="n">command</span><span class="p">,</span> <span class="n">logger</span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>or with a composite literal,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">job</span> <span class="p">:</span><span class="o">=</span> <span class="o">&amp;</span><span class="n">Job</span><span class="p">{</span><span class="n">command</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">New</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">Stderr</span><span class="p">,</span> <span class="s2">&quot;Job: &quot;</span><span class="p">,</span> <span class="n">log</span><span class="o">.</span><span class="n">Ldate</span><span class="p">)}</span>
</pre></div>
</div>
<p>If we need to refer to an embedded field directly, the type name of the
field, ignoring the package qualifier, serves as a field name, as it did
in the <strong>Read</strong> method of our <strong>ReadWriter</strong> struct. Here, if we needed
to access the <strong>*log.Logger</strong> of a <strong>Job</strong> variable <strong>job</strong>, we would
write <strong>job.Logger</strong>, which would be useful if we wanted to refine the
methods of <strong>Logger</strong>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">func</span> <span class="p">(</span><span class="n">job</span> <span class="o">*</span><span class="n">Job</span><span class="p">)</span> <span class="n">Printf</span><span class="p">(</span><span class="nb">format</span> <span class="n">string</span><span class="p">,</span> <span class="n">args</span> <span class="o">...</span><span class="n">interface</span><span class="p">{})</span> <span class="p">{</span>
    <span class="n">job</span><span class="o">.</span><span class="n">Logger</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s2">&quot;%q: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">job</span><span class="o">.</span><span class="n">Command</span><span class="p">,</span> <span class="n">fmt</span><span class="o">.</span><span class="n">Sprintf</span><span class="p">(</span><span class="nb">format</span><span class="p">,</span> <span class="n">args</span><span class="o">...</span><span class="p">))</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Embedding types introduces the problem of name conflicts but the rules
to resolve them are simple. First, a field or method <strong>X</strong> hides any
other item <strong>X</strong> in a more deeply nested part of the type. If
<strong>log.Logger</strong> contained a field or method called <strong>Command</strong>, the
<strong>Command</strong> field of <strong>Job</strong> would dominate it.</p>
<p>Second, if the same name appears at the same nesting level, it is
usually an error; it would be erroneous to embed <strong>log.Logger</strong> if the
<strong>Job</strong> struct contained another field or method called <strong>Logger</strong>.
However, if the duplicate name is never mentioned in the program outside
the type definition, it is OK. This qualification provides some
protection against changes made to types embedded from outside; there is
no problem if a field is added that conflicts with another field in
another subtype if neither field is ever used.</p>
</div>
<div class="section" id="id31">
<h2>並行処理<a class="headerlink" href="#id31" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="sharing">
<span id="id32"></span><h3>通信による共有<a class="headerlink" href="#sharing" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Concurrent programming is a large topic and there is space only for some
Go-specific highlights here.</p>
<p>Concurrent programming in many environments is made difficult by the
subtleties required to implement correct access to shared variables. Go
encourages a different approach in which shared values are passed around
on channels and, in fact, never actively shared by separate threads of
execution. Only one goroutine has access to the value at any given time.
Data races cannot occur, by design. To encourage this way of thinking we
have reduced it to a slogan:</p>
<blockquote>
<div><p>Do not communicate by sharing memory; instead, share memory by
communicating.</p>
</div></blockquote>
<p>This approach can be taken too far. Reference counts may be best done by
putting a mutex around an integer variable, for instance. But as a
high-level approach, using channels to control access makes it easier to
write clear, correct programs.</p>
<p>One way to think about this model is to consider a typical
single-threaded program running on one CPU. It has no need for
synchronization primitives. Now run another such instance; it too needs
no synchronization. Now let those two communicate; if the communication
is the synchronizer, there's still no need for other synchronization.
Unix pipelines, for example, fit this model perfectly. Although Go's
approach to concurrency originates in Hoare's Communicating Sequential
Processes (CSP), it can also be seen as a type-safe generalization of
Unix pipes.</p>
</div>
<div class="section" id="id33">
<h3>ゴルーチン<a class="headerlink" href="#id33" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>They're called <em>goroutines</em> because the existing terms—threads,
coroutines, processes, and so on—convey inaccurate connotations. A
goroutine has a simple model: it is a function executing concurrently
with other goroutines in the same address space. It is lightweight,
costing little more than the allocation of stack space. And the stacks
start small, so they are cheap, and grow by allocating (and freeing)
heap storage as required.</p>
<p>Goroutines are multiplexed onto multiple OS threads so if one should
block, such as while waiting for I/O, others continue to run. Their
design hides many of the complexities of thread creation and management.</p>
<p>Prefix a function or method call with the <strong>go</strong> keyword to run the call
in a new goroutine. When the call completes, the goroutine exits,
silently. (The effect is similar to the Unix shell's <strong>&amp;</strong> notation for
running a command in the background.)</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">go</span> <span class="nb">list</span><span class="o">.</span><span class="n">Sort</span><span class="p">()</span>  <span class="o">//</span> <span class="n">run</span> <span class="nb">list</span><span class="o">.</span><span class="n">Sort</span> <span class="n">concurrently</span><span class="p">;</span> <span class="n">don</span><span class="s1">&#39;t wait for it.</span>
</pre></div>
</div>
<p>A function literal can be handy in a goroutine invocation.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">func</span> <span class="n">Announce</span><span class="p">(</span><span class="n">message</span> <span class="n">string</span><span class="p">,</span> <span class="n">delay</span> <span class="n">time</span><span class="o">.</span><span class="n">Duration</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">go</span> <span class="n">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="n">delay</span><span class="p">)</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
    <span class="p">}()</span>  <span class="o">//</span> <span class="n">Note</span> <span class="n">the</span> <span class="n">parentheses</span> <span class="o">-</span> <span class="n">must</span> <span class="n">call</span> <span class="n">the</span> <span class="n">function</span><span class="o">.</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In Go, function literals are closures: the implementation makes sure the
variables referred to by the function survive as long as they are
active.</p>
<p>These examples aren't too practical because the functions have no way of
signaling completion. For that, we need channels.</p>
</div>
<div class="section" id="id34">
<h3>チャンネル<a class="headerlink" href="#id34" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Like maps, channels are allocated with <strong>make</strong>, and the resulting value
acts as a reference to an underlying data structure. If an optional
integer parameter is provided, it sets the buffer size for the channel.
The default is zero, for an unbuffered or synchronous channel.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ci</span> <span class="p">:</span><span class="o">=</span> <span class="n">make</span><span class="p">(</span><span class="n">chan</span> <span class="nb">int</span><span class="p">)</span>            <span class="o">//</span> <span class="n">unbuffered</span> <span class="n">channel</span> <span class="n">of</span> <span class="n">integers</span>
<span class="n">cj</span> <span class="p">:</span><span class="o">=</span> <span class="n">make</span><span class="p">(</span><span class="n">chan</span> <span class="nb">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>         <span class="o">//</span> <span class="n">unbuffered</span> <span class="n">channel</span> <span class="n">of</span> <span class="n">integers</span>
<span class="n">cs</span> <span class="p">:</span><span class="o">=</span> <span class="n">make</span><span class="p">(</span><span class="n">chan</span> <span class="o">*</span><span class="n">os</span><span class="o">.</span><span class="n">File</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>  <span class="o">//</span> <span class="n">buffered</span> <span class="n">channel</span> <span class="n">of</span> <span class="n">pointers</span> <span class="n">to</span> <span class="n">Files</span>
</pre></div>
</div>
<p>Unbuffered channels combine communication—the exchange of a value—with
synchronization—guaranteeing that two calculations (goroutines) are in a
known state.</p>
<p>There are lots of nice idioms using channels. Here's one to get us
started. In the previous section we launched a sort in the background. A
channel can allow the launching goroutine to wait for the sort to
complete.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">c</span> <span class="p">:</span><span class="o">=</span> <span class="n">make</span><span class="p">(</span><span class="n">chan</span> <span class="nb">int</span><span class="p">)</span>  <span class="o">//</span> <span class="n">Allocate</span> <span class="n">a</span> <span class="n">channel</span><span class="o">.</span>
<span class="o">//</span> <span class="n">Start</span> <span class="n">the</span> <span class="n">sort</span> <span class="ow">in</span> <span class="n">a</span> <span class="n">goroutine</span><span class="p">;</span> <span class="n">when</span> <span class="n">it</span> <span class="n">completes</span><span class="p">,</span> <span class="n">signal</span> <span class="n">on</span> <span class="n">the</span> <span class="n">channel</span><span class="o">.</span>
<span class="n">go</span> <span class="n">func</span><span class="p">()</span> <span class="p">{</span>
    <span class="nb">list</span><span class="o">.</span><span class="n">Sort</span><span class="p">()</span>
    <span class="n">c</span> <span class="o">&lt;-</span> <span class="mi">1</span>  <span class="o">//</span> <span class="n">Send</span> <span class="n">a</span> <span class="n">signal</span><span class="p">;</span> <span class="n">value</span> <span class="n">does</span> <span class="ow">not</span> <span class="n">matter</span><span class="o">.</span>
<span class="p">}()</span>
<span class="n">doSomethingForAWhile</span><span class="p">()</span>
<span class="o">&lt;-</span><span class="n">c</span>   <span class="o">//</span> <span class="n">Wait</span> <span class="k">for</span> <span class="n">sort</span> <span class="n">to</span> <span class="n">finish</span><span class="p">;</span> <span class="n">discard</span> <span class="n">sent</span> <span class="n">value</span><span class="o">.</span>
</pre></div>
</div>
<p>Receivers always block until there is data to receive. If the channel is
unbuffered, the sender blocks until the receiver has received the value.
If the channel has a buffer, the sender blocks only until the value has
been copied to the buffer; if the buffer is full, this means waiting
until some receiver has retrieved a value.</p>
<p>A buffered channel can be used like a semaphore, for instance to limit
throughput. In this example, incoming requests are passed to <strong>handle</strong>,
which sends a value into the channel, processes the request, and then
receives a value from the channel to ready the “semaphore” for the next
consumer. The capacity of the channel buffer limits the number of
simultaneous calls to <strong>process</strong>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">var</span> <span class="n">sem</span> <span class="o">=</span> <span class="n">make</span><span class="p">(</span><span class="n">chan</span> <span class="nb">int</span><span class="p">,</span> <span class="n">MaxOutstanding</span><span class="p">)</span>

<span class="n">func</span> <span class="n">handle</span><span class="p">(</span><span class="n">r</span> <span class="o">*</span><span class="n">Request</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">sem</span> <span class="o">&lt;-</span> <span class="mi">1</span>    <span class="o">//</span> <span class="n">Wait</span> <span class="k">for</span> <span class="n">active</span> <span class="n">queue</span> <span class="n">to</span> <span class="n">drain</span><span class="o">.</span>
    <span class="n">process</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>  <span class="o">//</span> <span class="n">May</span> <span class="n">take</span> <span class="n">a</span> <span class="n">long</span> <span class="n">time</span><span class="o">.</span>
    <span class="o">&lt;-</span><span class="n">sem</span>       <span class="o">//</span> <span class="n">Done</span><span class="p">;</span> <span class="n">enable</span> <span class="nb">next</span> <span class="n">request</span> <span class="n">to</span> <span class="n">run</span><span class="o">.</span>
<span class="p">}</span>

<span class="n">func</span> <span class="n">Serve</span><span class="p">(</span><span class="n">queue</span> <span class="n">chan</span> <span class="o">*</span><span class="n">Request</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">{</span>
        <span class="n">req</span> <span class="p">:</span><span class="o">=</span> <span class="o">&lt;-</span><span class="n">queue</span>
        <span class="n">go</span> <span class="n">handle</span><span class="p">(</span><span class="n">req</span><span class="p">)</span>  <span class="o">//</span> <span class="n">Don</span><span class="s1">&#39;t wait for handle to finish.</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Once <strong>MaxOutstanding</strong> handlers are executing <strong>process</strong>, any more
will block trying to send into the filled channel buffer, until one of
the existing handlers finishes and receives from the buffer.</p>
<p>This design has a problem, though: <strong>Serve</strong> creates a new goroutine for
every incoming request, even though only <strong>MaxOutstanding</strong> of them can
run at any moment. As a result, the program can consume unlimited
resources if the requests come in too fast. We can address that
deficiency by changing <strong>Serve</strong> to gate the creation of the goroutines.
Here's an obvious solution, but beware it has a bug we'll fix
subsequently:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">func</span> <span class="n">Serve</span><span class="p">(</span><span class="n">queue</span> <span class="n">chan</span> <span class="o">*</span><span class="n">Request</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="n">req</span> <span class="p">:</span><span class="o">=</span> <span class="nb">range</span> <span class="n">queue</span> <span class="p">{</span>
        <span class="n">sem</span> <span class="o">&lt;-</span> <span class="mi">1</span>
        <span class="n">go</span> <span class="n">func</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">process</span><span class="p">(</span><span class="n">req</span><span class="p">)</span> <span class="o">//</span> <span class="n">Buggy</span><span class="p">;</span> <span class="n">see</span> <span class="n">explanation</span> <span class="n">below</span><span class="o">.</span>
            <span class="o">&lt;-</span><span class="n">sem</span>
        <span class="p">}()</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The bug is that in a Go <strong>for</strong> loop, the loop variable is reused for
each iteration, so the <strong>req</strong> variable is shared across all goroutines.
That's not what we want. We need to make sure that <strong>req</strong> is unique for
each goroutine. Here's one way to do that, passing the value of <strong>req</strong>
as an argument to the closure in the goroutine:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">func</span> <span class="n">Serve</span><span class="p">(</span><span class="n">queue</span> <span class="n">chan</span> <span class="o">*</span><span class="n">Request</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="n">req</span> <span class="p">:</span><span class="o">=</span> <span class="nb">range</span> <span class="n">queue</span> <span class="p">{</span>
        <span class="n">sem</span> <span class="o">&lt;-</span> <span class="mi">1</span>
        <span class="n">go</span> <span class="n">func</span><span class="p">(</span><span class="n">req</span> <span class="o">*</span><span class="n">Request</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">process</span><span class="p">(</span><span class="n">req</span><span class="p">)</span>
            <span class="o">&lt;-</span><span class="n">sem</span>
        <span class="p">}(</span><span class="n">req</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Compare this version with the previous to see the difference in how the
closure is declared and run. Another solution is just to create a new
variable with the same name, as in this example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">func</span> <span class="n">Serve</span><span class="p">(</span><span class="n">queue</span> <span class="n">chan</span> <span class="o">*</span><span class="n">Request</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="n">req</span> <span class="p">:</span><span class="o">=</span> <span class="nb">range</span> <span class="n">queue</span> <span class="p">{</span>
        <span class="n">req</span> <span class="p">:</span><span class="o">=</span> <span class="n">req</span> <span class="o">//</span> <span class="n">Create</span> <span class="n">new</span> <span class="n">instance</span> <span class="n">of</span> <span class="n">req</span> <span class="k">for</span> <span class="n">the</span> <span class="n">goroutine</span><span class="o">.</span>
        <span class="n">sem</span> <span class="o">&lt;-</span> <span class="mi">1</span>
        <span class="n">go</span> <span class="n">func</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">process</span><span class="p">(</span><span class="n">req</span><span class="p">)</span>
            <span class="o">&lt;-</span><span class="n">sem</span>
        <span class="p">}()</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>It may seem odd to write</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">req</span> <span class="p">:</span><span class="o">=</span> <span class="n">req</span>
</pre></div>
</div>
<p>but it's legal and idiomatic in Go to do this. You get a fresh version
of the variable with the same name, deliberately shadowing the loop
variable locally but unique to each goroutine.</p>
<p>Going back to the general problem of writing the server, another
approach that manages resources well is to start a fixed number of
<strong>handle</strong> goroutines all reading from the request channel. The number
of goroutines limits the number of simultaneous calls to <strong>process</strong>.
This <strong>Serve</strong> function also accepts a channel on which it will be told
to exit; after launching the goroutines it blocks receiving from that
channel.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">func</span> <span class="n">handle</span><span class="p">(</span><span class="n">queue</span> <span class="n">chan</span> <span class="o">*</span><span class="n">Request</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="n">r</span> <span class="p">:</span><span class="o">=</span> <span class="nb">range</span> <span class="n">queue</span> <span class="p">{</span>
        <span class="n">process</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">func</span> <span class="n">Serve</span><span class="p">(</span><span class="n">clientRequests</span> <span class="n">chan</span> <span class="o">*</span><span class="n">Request</span><span class="p">,</span> <span class="n">quit</span> <span class="n">chan</span> <span class="nb">bool</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">//</span> <span class="n">Start</span> <span class="n">handlers</span>
    <span class="k">for</span> <span class="n">i</span> <span class="p">:</span><span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MaxOutstanding</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="n">go</span> <span class="n">handle</span><span class="p">(</span><span class="n">clientRequests</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="o">&lt;-</span><span class="n">quit</span>  <span class="o">//</span> <span class="n">Wait</span> <span class="n">to</span> <span class="n">be</span> <span class="n">told</span> <span class="n">to</span> <span class="n">exit</span><span class="o">.</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="channels-of-channels">
<span id="chan-of-chan"></span><h3>Channels of channels<a class="headerlink" href="#channels-of-channels" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>One of the most important properties of Go is that a channel is a
first-class value that can be allocated and passed around like any
other. A common use of this property is to implement safe, parallel
demultiplexing.</p>
<p>In the example in the previous section, <strong>handle</strong> was an idealized
handler for a request but we didn't define the type it was handling. If
that type includes a channel on which to reply, each client can provide
its own path for the answer. Here's a schematic definition of type
<strong>Request</strong>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">type</span> <span class="n">Request</span> <span class="n">struct</span> <span class="p">{</span>
    <span class="n">args</span>        <span class="p">[]</span><span class="nb">int</span>
    <span class="n">f</span>           <span class="n">func</span><span class="p">([]</span><span class="nb">int</span><span class="p">)</span> <span class="nb">int</span>
    <span class="n">resultChan</span>  <span class="n">chan</span> <span class="nb">int</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The client provides a function and its arguments, as well as a channel
inside the request object on which to receive the answer.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">func</span> <span class="nb">sum</span><span class="p">(</span><span class="n">a</span> <span class="p">[]</span><span class="nb">int</span><span class="p">)</span> <span class="p">(</span><span class="n">s</span> <span class="nb">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">v</span> <span class="p">:</span><span class="o">=</span> <span class="nb">range</span> <span class="n">a</span> <span class="p">{</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="n">v</span>
    <span class="p">}</span>
    <span class="k">return</span>
<span class="p">}</span>

<span class="n">request</span> <span class="p">:</span><span class="o">=</span> <span class="o">&amp;</span><span class="n">Request</span><span class="p">{[]</span><span class="nb">int</span><span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">},</span> <span class="nb">sum</span><span class="p">,</span> <span class="n">make</span><span class="p">(</span><span class="n">chan</span> <span class="nb">int</span><span class="p">)}</span>
<span class="o">//</span> <span class="n">Send</span> <span class="n">request</span>
<span class="n">clientRequests</span> <span class="o">&lt;-</span> <span class="n">request</span>
<span class="o">//</span> <span class="n">Wait</span> <span class="k">for</span> <span class="n">response</span><span class="o">.</span>
<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s2">&quot;answer: </span><span class="si">%d</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="o">&lt;-</span><span class="n">request</span><span class="o">.</span><span class="n">resultChan</span><span class="p">)</span>
</pre></div>
</div>
<p>On the server side, the handler function is the only thing that changes.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">func</span> <span class="n">handle</span><span class="p">(</span><span class="n">queue</span> <span class="n">chan</span> <span class="o">*</span><span class="n">Request</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="n">req</span> <span class="p">:</span><span class="o">=</span> <span class="nb">range</span> <span class="n">queue</span> <span class="p">{</span>
        <span class="n">req</span><span class="o">.</span><span class="n">resultChan</span> <span class="o">&lt;-</span> <span class="n">req</span><span class="o">.</span><span class="n">f</span><span class="p">(</span><span class="n">req</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>There's clearly a lot more to do to make it realistic, but this code is
a framework for a rate-limited, parallel, non-blocking RPC system, and
there's not a mutex in sight.</p>
</div>
<div class="section" id="parallelization">
<span id="parallel"></span><h3>Parallelization<a class="headerlink" href="#parallelization" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Another application of these ideas is to parallelize a calculation
across multiple CPU cores. If the calculation can be broken into
separate pieces that can execute independently, it can be parallelized,
with a channel to signal when each piece completes.</p>
<p>Let's say we have an expensive operation to perform on a vector of
items, and that the value of the operation on each item is independent,
as in this idealized example.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">type</span> <span class="n">Vector</span> <span class="p">[]</span><span class="n">float64</span>

<span class="o">//</span> <span class="n">Apply</span> <span class="n">the</span> <span class="n">operation</span> <span class="n">to</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">...</span> <span class="n">up</span> <span class="n">to</span> <span class="n">v</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span>
<span class="n">func</span> <span class="p">(</span><span class="n">v</span> <span class="n">Vector</span><span class="p">)</span> <span class="n">DoSome</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">n</span> <span class="nb">int</span><span class="p">,</span> <span class="n">u</span> <span class="n">Vector</span><span class="p">,</span> <span class="n">c</span> <span class="n">chan</span> <span class="nb">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">u</span><span class="o">.</span><span class="n">Op</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="p">}</span>
    <span class="n">c</span> <span class="o">&lt;-</span> <span class="mi">1</span>    <span class="o">//</span> <span class="n">signal</span> <span class="n">that</span> <span class="n">this</span> <span class="n">piece</span> <span class="ow">is</span> <span class="n">done</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We launch the pieces independently in a loop, one per CPU. They can
complete in any order but it doesn't matter; we just count the
completion signals by draining the channel after launching all the
goroutines.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">const</span> <span class="n">numCPU</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">//</span> <span class="n">number</span> <span class="n">of</span> <span class="n">CPU</span> <span class="n">cores</span>

<span class="n">func</span> <span class="p">(</span><span class="n">v</span> <span class="n">Vector</span><span class="p">)</span> <span class="n">DoAll</span><span class="p">(</span><span class="n">u</span> <span class="n">Vector</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">c</span> <span class="p">:</span><span class="o">=</span> <span class="n">make</span><span class="p">(</span><span class="n">chan</span> <span class="nb">int</span><span class="p">,</span> <span class="n">numCPU</span><span class="p">)</span>  <span class="o">//</span> <span class="n">Buffering</span> <span class="n">optional</span> <span class="n">but</span> <span class="n">sensible</span><span class="o">.</span>
    <span class="k">for</span> <span class="n">i</span> <span class="p">:</span><span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numCPU</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="n">go</span> <span class="n">v</span><span class="o">.</span><span class="n">DoSome</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="o">/</span><span class="n">numCPU</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="o">/</span><span class="n">numCPU</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="o">//</span> <span class="n">Drain</span> <span class="n">the</span> <span class="n">channel</span><span class="o">.</span>
    <span class="k">for</span> <span class="n">i</span> <span class="p">:</span><span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numCPU</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="o">&lt;-</span><span class="n">c</span>    <span class="o">//</span> <span class="n">wait</span> <span class="k">for</span> <span class="n">one</span> <span class="n">task</span> <span class="n">to</span> <span class="n">complete</span>
    <span class="p">}</span>
    <span class="o">//</span> <span class="n">All</span> <span class="n">done</span><span class="o">.</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Rather than create a constant value for numCPU, we can ask the runtime
what value is appropriate. The function <strong>runtime.NumCPU</strong> returns the
number of hardware CPU cores in the machine, so we could write</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">var</span> <span class="n">numCPU</span> <span class="o">=</span> <span class="n">runtime</span><span class="o">.</span><span class="n">NumCPU</span><span class="p">()</span>
</pre></div>
</div>
<p>There is also a function <strong>runtime.GOMAXPROCS</strong>, which reports (or sets)
the user-specified number of cores that a Go program can have running
simultaneously. It defaults to the value of <strong>runtime.NumCPU</strong> but can
be overridden by setting the similarly named shell environment variable
or by calling the function with a positive number. Calling it with zero
just queries the value. Therefore if we want to honor the user's
resource request, we should write</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">var</span> <span class="n">numCPU</span> <span class="o">=</span> <span class="n">runtime</span><span class="o">.</span><span class="n">GOMAXPROCS</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>Be sure not to confuse the ideas of concurrency—structuring a program as
independently executing components—and parallelism—executing
calculations in parallel for efficiency on multiple CPUs. Although the
concurrency features of Go can make some problems easy to structure as
parallel computations, Go is a concurrent language, not a parallel one,
and not all parallelization problems fit Go's model. For a discussion of
the distinction, see the talk cited in <a class="reference external" href="//blog.golang.org/2013/01/concurrency-is-not-parallelism.html">this blog
post</a>.</p>
</div>
<div class="section" id="a-leaky-buffer">
<span id="leaky-buffer"></span><h3>A leaky buffer<a class="headerlink" href="#a-leaky-buffer" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>The tools of concurrent programming can even make non-concurrent ideas
easier to express. Here's an example abstracted from an RPC package. The
client goroutine loops receiving data from some source, perhaps a
network. To avoid allocating and freeing buffers, it keeps a free list,
and uses a buffered channel to represent it. If the channel is empty, a
new buffer gets allocated. Once the message buffer is ready, it's sent
to the server on <strong>serverChan</strong>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">var</span> <span class="n">freeList</span> <span class="o">=</span> <span class="n">make</span><span class="p">(</span><span class="n">chan</span> <span class="o">*</span><span class="n">Buffer</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="n">var</span> <span class="n">serverChan</span> <span class="o">=</span> <span class="n">make</span><span class="p">(</span><span class="n">chan</span> <span class="o">*</span><span class="n">Buffer</span><span class="p">)</span>

<span class="n">func</span> <span class="n">client</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">{</span>
        <span class="n">var</span> <span class="n">b</span> <span class="o">*</span><span class="n">Buffer</span>
        <span class="o">//</span> <span class="n">Grab</span> <span class="n">a</span> <span class="n">buffer</span> <span class="k">if</span> <span class="n">available</span><span class="p">;</span> <span class="n">allocate</span> <span class="k">if</span> <span class="ow">not</span><span class="o">.</span>
        <span class="n">select</span> <span class="p">{</span>
        <span class="n">case</span> <span class="n">b</span> <span class="o">=</span> <span class="o">&lt;-</span><span class="n">freeList</span><span class="p">:</span>
            <span class="o">//</span> <span class="n">Got</span> <span class="n">one</span><span class="p">;</span> <span class="n">nothing</span> <span class="n">more</span> <span class="n">to</span> <span class="n">do</span><span class="o">.</span>
        <span class="n">default</span><span class="p">:</span>
            <span class="o">//</span> <span class="kc">None</span> <span class="n">free</span><span class="p">,</span> <span class="n">so</span> <span class="n">allocate</span> <span class="n">a</span> <span class="n">new</span> <span class="n">one</span><span class="o">.</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">new</span><span class="p">(</span><span class="n">Buffer</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="n">load</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>              <span class="o">//</span> <span class="n">Read</span> <span class="nb">next</span> <span class="n">message</span> <span class="kn">from</span> <span class="nn">the</span> <span class="n">net</span><span class="o">.</span>
        <span class="n">serverChan</span> <span class="o">&lt;-</span> <span class="n">b</span>      <span class="o">//</span> <span class="n">Send</span> <span class="n">to</span> <span class="n">server</span><span class="o">.</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The server loop receives each message from the client, processes it, and
returns the buffer to the free list.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">func</span> <span class="n">server</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">{</span>
        <span class="n">b</span> <span class="p">:</span><span class="o">=</span> <span class="o">&lt;-</span><span class="n">serverChan</span>    <span class="o">//</span> <span class="n">Wait</span> <span class="k">for</span> <span class="n">work</span><span class="o">.</span>
        <span class="n">process</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="o">//</span> <span class="n">Reuse</span> <span class="n">buffer</span> <span class="k">if</span> <span class="n">there</span><span class="s1">&#39;s room.</span>
        <span class="n">select</span> <span class="p">{</span>
        <span class="n">case</span> <span class="n">freeList</span> <span class="o">&lt;-</span> <span class="n">b</span><span class="p">:</span>
            <span class="o">//</span> <span class="n">Buffer</span> <span class="n">on</span> <span class="n">free</span> <span class="nb">list</span><span class="p">;</span> <span class="n">nothing</span> <span class="n">more</span> <span class="n">to</span> <span class="n">do</span><span class="o">.</span>
        <span class="n">default</span><span class="p">:</span>
            <span class="o">//</span> <span class="n">Free</span> <span class="nb">list</span> <span class="n">full</span><span class="p">,</span> <span class="n">just</span> <span class="n">carry</span> <span class="n">on</span><span class="o">.</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The client attempts to retrieve a buffer from <strong>freeList</strong>; if none is
available, it allocates a fresh one. The server's send to <strong>freeList</strong>
puts <strong>b</strong> back on the free list unless the list is full, in which case
the buffer is dropped on the floor to be reclaimed by the garbage
collector. (The <strong>default</strong> clauses in the <strong>select</strong> statements execute
when no other case is ready, meaning that the <strong>selects</strong> never block.)
This implementation builds a leaky bucket free list in just a few lines,
relying on the buffered channel and the garbage collector for
bookkeeping.</p>
</div>
</div>
<div class="section" id="id35">
<h2>エラー<a class="headerlink" href="#id35" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Library routines must often return some sort of error indication to the
caller. As mentioned earlier, Go's multivalue return makes it easy to
return a detailed error description alongside the normal return value.
It is good style to use this feature to provide detailed error
information. For example, as we'll see, <strong>os.Open</strong> doesn't just return
a <strong>nil</strong> pointer on failure, it also returns an error value that
describes what went wrong.</p>
<p>By convention, errors have type <strong>error</strong>, a simple built-in interface.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">type</span> <span class="n">error</span> <span class="n">interface</span> <span class="p">{</span>
    <span class="n">Error</span><span class="p">()</span> <span class="n">string</span>
<span class="p">}</span>
</pre></div>
</div>
<p>A library writer is free to implement this interface with a richer model
under the covers, making it possible not only to see the error but also
to provide some context. As mentioned, alongside the usual <strong>*os.File</strong>
return value, <strong>os.Open</strong> also returns an error value. If the file is
opened successfully, the error will be <strong>nil</strong>, but when there is a
problem, it will hold an <strong>os.PathError</strong>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">PathError</span> <span class="n">records</span> <span class="n">an</span> <span class="n">error</span> <span class="ow">and</span> <span class="n">the</span> <span class="n">operation</span> <span class="ow">and</span>
<span class="o">//</span> <span class="n">file</span> <span class="n">path</span> <span class="n">that</span> <span class="n">caused</span> <span class="n">it</span><span class="o">.</span>
<span class="nb">type</span> <span class="n">PathError</span> <span class="n">struct</span> <span class="p">{</span>
    <span class="n">Op</span> <span class="n">string</span>    <span class="o">//</span> <span class="s2">&quot;open&quot;</span><span class="p">,</span> <span class="s2">&quot;unlink&quot;</span><span class="p">,</span> <span class="n">etc</span><span class="o">.</span>
    <span class="n">Path</span> <span class="n">string</span>  <span class="o">//</span> <span class="n">The</span> <span class="n">associated</span> <span class="n">file</span><span class="o">.</span>
    <span class="n">Err</span> <span class="n">error</span>    <span class="o">//</span> <span class="n">Returned</span> <span class="n">by</span> <span class="n">the</span> <span class="n">system</span> <span class="n">call</span><span class="o">.</span>
<span class="p">}</span>

<span class="n">func</span> <span class="p">(</span><span class="n">e</span> <span class="o">*</span><span class="n">PathError</span><span class="p">)</span> <span class="n">Error</span><span class="p">()</span> <span class="n">string</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">e</span><span class="o">.</span><span class="n">Op</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span> <span class="o">+</span> <span class="n">e</span><span class="o">.</span><span class="n">Path</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="n">e</span><span class="o">.</span><span class="n">Err</span><span class="o">.</span><span class="n">Error</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong>PathError</strong>'s <strong>Error</strong> generates a string like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">open</span> <span class="o">/</span><span class="n">etc</span><span class="o">/</span><span class="n">passwx</span><span class="p">:</span> <span class="n">no</span> <span class="n">such</span> <span class="n">file</span> <span class="ow">or</span> <span class="n">directory</span>
</pre></div>
</div>
<p>Such an error, which includes the problematic file name, the operation,
and the operating system error it triggered, is useful even if printed
far from the call that caused it; it is much more informative than the
plain &quot;no such file or directory&quot;.</p>
<p>When feasible, error strings should identify their origin, such as by
having a prefix naming the operation or package that generated the
error. For example, in package <strong>image</strong>, the string representation for
a decoding error due to an unknown format is &quot;image: unknown format&quot;.</p>
<p>Callers that care about the precise error details can use a type switch
or a type assertion to look for specific errors and extract details. For
<strong>PathErrors</strong> this might include examining the internal <strong>Err</strong> field
for recoverable failures.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="k">try</span> <span class="p">:</span><span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="k">try</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="k">try</span><span class="o">++</span> <span class="p">{</span>
    <span class="n">file</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">Create</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">err</span> <span class="o">==</span> <span class="n">nil</span> <span class="p">{</span>
        <span class="k">return</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="n">e</span><span class="p">,</span> <span class="n">ok</span> <span class="p">:</span><span class="o">=</span> <span class="n">err</span><span class="o">.</span><span class="p">(</span><span class="o">*</span><span class="n">os</span><span class="o">.</span><span class="n">PathError</span><span class="p">);</span> <span class="n">ok</span> <span class="o">&amp;&amp;</span> <span class="n">e</span><span class="o">.</span><span class="n">Err</span> <span class="o">==</span> <span class="n">syscall</span><span class="o">.</span><span class="n">ENOSPC</span> <span class="p">{</span>
        <span class="n">deleteTempFiles</span><span class="p">()</span>  <span class="o">//</span> <span class="n">Recover</span> <span class="n">some</span> <span class="n">space</span><span class="o">.</span>
        <span class="k">continue</span>
    <span class="p">}</span>
    <span class="k">return</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The second <strong>if</strong> statement here is another <a class="reference external" href="#interface_conversions">type
assertion</a>. If it fails, <strong>ok</strong> will be
false, and <strong>e</strong> will be <strong>nil</strong>. If it succeeds, <strong>ok</strong> will be true,
which means the error was of type <strong>*os.PathError</strong>, and then so is
<strong>e</strong>, which we can examine for more information about the error.</p>
<div class="section" id="panic">
<h3>Panic<a class="headerlink" href="#panic" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>The usual way to report an error to a caller is to return an <strong>error</strong>
as an extra return value. The canonical <strong>Read</strong> method is a well-known
instance; it returns a byte count and an <strong>error</strong>. But what if the
error is unrecoverable? Sometimes the program simply cannot continue.</p>
<p>For this purpose, there is a built-in function <strong>panic</strong> that in effect
creates a run-time error that will stop the program (but see the next
section). The function takes a single argument of arbitrary type—often a
string—to be printed as the program dies. It's also a way to indicate
that something impossible has happened, such as exiting an infinite
loop.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">A</span> <span class="n">toy</span> <span class="n">implementation</span> <span class="n">of</span> <span class="n">cube</span> <span class="n">root</span> <span class="n">using</span> <span class="n">Newton</span><span class="s1">&#39;s method.</span>
<span class="n">func</span> <span class="n">CubeRoot</span><span class="p">(</span><span class="n">x</span> <span class="n">float64</span><span class="p">)</span> <span class="n">float64</span> <span class="p">{</span>
    <span class="n">z</span> <span class="p">:</span><span class="o">=</span> <span class="n">x</span><span class="o">/</span><span class="mi">3</span>   <span class="o">//</span> <span class="n">Arbitrary</span> <span class="n">initial</span> <span class="n">value</span>
    <span class="k">for</span> <span class="n">i</span> <span class="p">:</span><span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mf">1e6</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="n">prevz</span> <span class="p">:</span><span class="o">=</span> <span class="n">z</span>
        <span class="n">z</span> <span class="o">-=</span> <span class="p">(</span><span class="n">z</span><span class="o">*</span><span class="n">z</span><span class="o">*</span><span class="n">z</span><span class="o">-</span><span class="n">x</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">z</span><span class="o">*</span><span class="n">z</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">veryClose</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">prevz</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">z</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="o">//</span> <span class="n">A</span> <span class="n">million</span> <span class="n">iterations</span> <span class="n">has</span> <span class="ow">not</span> <span class="n">converged</span><span class="p">;</span> <span class="n">something</span> <span class="ow">is</span> <span class="n">wrong</span><span class="o">.</span>
    <span class="n">panic</span><span class="p">(</span><span class="n">fmt</span><span class="o">.</span><span class="n">Sprintf</span><span class="p">(</span><span class="s2">&quot;CubeRoot(</span><span class="si">%g</span><span class="s2">) did not converge&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This is only an example but real library functions should avoid
<strong>panic</strong>. If the problem can be masked or worked around, it's always
better to let things continue to run rather than taking down the whole
program. One possible counterexample is during initialization: if the
library truly cannot set itself up, it might be reasonable to panic, so
to speak.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">var</span> <span class="n">user</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">Getenv</span><span class="p">(</span><span class="s2">&quot;USER&quot;</span><span class="p">)</span>

<span class="n">func</span> <span class="n">init</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">user</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span> <span class="p">{</span>
        <span class="n">panic</span><span class="p">(</span><span class="s2">&quot;no value for $USER&quot;</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="recover">
<h3>Recover<a class="headerlink" href="#recover" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>When <strong>panic</strong> is called, including implicitly for run-time errors such
as indexing a slice out of bounds or failing a type assertion, it
immediately stops execution of the current function and begins unwinding
the stack of the goroutine, running any deferred functions along the
way. If that unwinding reaches the top of the goroutine's stack, the
program dies. However, it is possible to use the built-in function
<strong>recover</strong> to regain control of the goroutine and resume normal
execution.</p>
<p>A call to <strong>recover</strong> stops the unwinding and returns the argument
passed to <strong>panic</strong>. Because the only code that runs while unwinding is
inside deferred functions, <strong>recover</strong> is only useful inside deferred
functions.</p>
<p>One application of <strong>recover</strong> is to shut down a failing goroutine
inside a server without killing the other executing goroutines.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">func</span> <span class="n">server</span><span class="p">(</span><span class="n">workChan</span> <span class="o">&lt;-</span><span class="n">chan</span> <span class="o">*</span><span class="n">Work</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="n">work</span> <span class="p">:</span><span class="o">=</span> <span class="nb">range</span> <span class="n">workChan</span> <span class="p">{</span>
        <span class="n">go</span> <span class="n">safelyDo</span><span class="p">(</span><span class="n">work</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">func</span> <span class="n">safelyDo</span><span class="p">(</span><span class="n">work</span> <span class="o">*</span><span class="n">Work</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">defer</span> <span class="n">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">err</span> <span class="p">:</span><span class="o">=</span> <span class="n">recover</span><span class="p">();</span> <span class="n">err</span> <span class="o">!=</span> <span class="n">nil</span> <span class="p">{</span>
            <span class="n">log</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s2">&quot;work failed:&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}()</span>
    <span class="n">do</span><span class="p">(</span><span class="n">work</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In this example, if <strong>do(work)</strong> panics, the result will be logged and
the goroutine will exit cleanly without disturbing the others. There's
no need to do anything else in the deferred closure; calling <strong>recover</strong>
handles the condition completely.</p>
<p>Because <strong>recover</strong> always returns <strong>nil</strong> unless called directly from a
deferred function, deferred code can call library routines that
themselves use <strong>panic</strong> and <strong>recover</strong> without failing. As an example,
the deferred function in <strong>safelyDo</strong> might call a logging function
before calling <strong>recover</strong>, and that logging code would run unaffected
by the panicking state.</p>
<p>With our recovery pattern in place, the <strong>do</strong> function (and anything it
calls) can get out of any bad situation cleanly by calling <strong>panic</strong>. We
can use that idea to simplify error handling in complex software. Let's
look at an idealized version of a <strong>regexp</strong> package, which reports
parsing errors by calling <strong>panic</strong> with a local error type. Here's the
definition of <strong>Error</strong>, an <strong>error</strong> method, and the <strong>Compile</strong>
function.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Error</span> <span class="ow">is</span> <span class="n">the</span> <span class="nb">type</span> <span class="n">of</span> <span class="n">a</span> <span class="n">parse</span> <span class="n">error</span><span class="p">;</span> <span class="n">it</span> <span class="n">satisfies</span> <span class="n">the</span> <span class="n">error</span> <span class="n">interface</span><span class="o">.</span>
<span class="nb">type</span> <span class="n">Error</span> <span class="n">string</span>
<span class="n">func</span> <span class="p">(</span><span class="n">e</span> <span class="n">Error</span><span class="p">)</span> <span class="n">Error</span><span class="p">()</span> <span class="n">string</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">string</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
<span class="p">}</span>

<span class="o">//</span> <span class="n">error</span> <span class="ow">is</span> <span class="n">a</span> <span class="n">method</span> <span class="n">of</span> <span class="o">*</span><span class="n">Regexp</span> <span class="n">that</span> <span class="n">reports</span> <span class="n">parsing</span> <span class="n">errors</span> <span class="n">by</span>
<span class="o">//</span> <span class="n">panicking</span> <span class="k">with</span> <span class="n">an</span> <span class="n">Error</span><span class="o">.</span>
<span class="n">func</span> <span class="p">(</span><span class="n">regexp</span> <span class="o">*</span><span class="n">Regexp</span><span class="p">)</span> <span class="n">error</span><span class="p">(</span><span class="n">err</span> <span class="n">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">panic</span><span class="p">(</span><span class="n">Error</span><span class="p">(</span><span class="n">err</span><span class="p">))</span>
<span class="p">}</span>

<span class="o">//</span> <span class="n">Compile</span> <span class="n">returns</span> <span class="n">a</span> <span class="n">parsed</span> <span class="n">representation</span> <span class="n">of</span> <span class="n">the</span> <span class="n">regular</span> <span class="n">expression</span><span class="o">.</span>
<span class="n">func</span> <span class="n">Compile</span><span class="p">(</span><span class="nb">str</span> <span class="n">string</span><span class="p">)</span> <span class="p">(</span><span class="n">regexp</span> <span class="o">*</span><span class="n">Regexp</span><span class="p">,</span> <span class="n">err</span> <span class="n">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">regexp</span> <span class="o">=</span> <span class="n">new</span><span class="p">(</span><span class="n">Regexp</span><span class="p">)</span>
    <span class="o">//</span> <span class="n">doParse</span> <span class="n">will</span> <span class="n">panic</span> <span class="k">if</span> <span class="n">there</span> <span class="ow">is</span> <span class="n">a</span> <span class="n">parse</span> <span class="n">error</span><span class="o">.</span>
    <span class="n">defer</span> <span class="n">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">e</span> <span class="p">:</span><span class="o">=</span> <span class="n">recover</span><span class="p">();</span> <span class="n">e</span> <span class="o">!=</span> <span class="n">nil</span> <span class="p">{</span>
            <span class="n">regexp</span> <span class="o">=</span> <span class="n">nil</span>    <span class="o">//</span> <span class="n">Clear</span> <span class="k">return</span> <span class="n">value</span><span class="o">.</span>
            <span class="n">err</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="p">(</span><span class="n">Error</span><span class="p">)</span> <span class="o">//</span> <span class="n">Will</span> <span class="n">re</span><span class="o">-</span><span class="n">panic</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">a</span> <span class="n">parse</span> <span class="n">error</span><span class="o">.</span>
        <span class="p">}</span>
    <span class="p">}()</span>
    <span class="k">return</span> <span class="n">regexp</span><span class="o">.</span><span class="n">doParse</span><span class="p">(</span><span class="nb">str</span><span class="p">),</span> <span class="n">nil</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If <strong>doParse</strong> panics, the recovery block will set the return value to
<strong>nil</strong>—deferred functions can modify named return values. It will then
check, in the assignment to <strong>err</strong>, that the problem was a parse error
by asserting that it has the local type <strong>Error</strong>. If it does not, the
type assertion will fail, causing a run-time error that continues the
stack unwinding as though nothing had interrupted it. This check means
that if something unexpected happens, such as an index out of bounds,
the code will fail even though we are using <strong>panic</strong> and <strong>recover</strong> to
handle parse errors.</p>
<p>With error handling in place, the <strong>error</strong> method (because it's a
method bound to a type, it's fine, even natural, for it to have the same
name as the builtin <strong>error</strong> type) makes it easy to report parse errors
without worrying about unwinding the parse stack by hand:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">pos</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="n">re</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;&#39;*&#39; illegal at start of expression&quot;</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Useful though this pattern is, it should be used only within a package.
<strong>Parse</strong> turns its internal <strong>panic</strong> calls into <strong>error</strong> values; it
does not expose <strong>panics</strong> to its client. That is a good rule to follow.</p>
<p>By the way, this re-panic idiom changes the panic value if an actual
error occurs. However, both the original and new failures will be
presented in the crash report, so the root cause of the problem will
still be visible. Thus this simple re-panic approach is usually
sufficient—it's a crash after all—but if you want to display only the
original value, you can write a little more code to filter unexpected
problems and re-panic with the original error. That's left as an
exercise for the reader.</p>
</div>
</div>
<div class="section" id="web">
<span id="web-server"></span><h2>Webサーバー<a class="headerlink" href="#web" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>完全なGoのプログラムであるWebサーバを仕上げて終わりにしましょう。これは実際には一種の中継サーバです。Googleは <strong>chart.apis.google.com</strong> としてデータをチャートおよびグラフに自動的にフォーマットするサービスを提供しています。ただし、データをクエリとしてURLに送信する必要があるため、インタラクティブに使用することは困難です。ここでのプログラムはデータの1形式へのよりよいインターフェースを提供します。短いテキストを与えると、チャートサーバを呼び出し、テキストをエンコードする二次元のQRコードを生成します。その画像を携帯電話のカメラで取得して、たとえばURLとして解釈し、携帯電話の小さなキーボードにURLを入力する手間を省くことができます。</p>
<p>ここに完全なプログラムがあります。以下に従って説明します。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

import (
	&quot;flag&quot;
	&quot;html/template&quot;
	&quot;log&quot;
	&quot;net/http&quot;
)

var addr = flag.String(&quot;addr&quot;, &quot;:1718&quot;, &quot;http service address&quot;) // Q=17, R=18

var templ = template.Must(template.New(&quot;qr&quot;).Parse(templateStr))

func main() {
	flag.Parse()
	http.Handle(&quot;/&quot;, http.HandlerFunc(QR))
	err := http.ListenAndServe(*addr, nil)
	if err != nil {
		log.Fatal(&quot;ListenAndServe:&quot;, err)
	}
}

func QR(w http.ResponseWriter, req *http.Request) {
	templ.Execute(w, req.FormValue(&quot;s&quot;))
}

const templateStr = `
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;QR Link Generator&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
{{if .}}
&lt;img src=&quot;http://chart.apis.google.com/chart?chs=300x300&amp;cht=qr&amp;choe=UTF-8&amp;chl={{.}}&quot; /&gt;
&lt;br&gt;
{{.}}
&lt;br&gt;
&lt;br&gt;
{{end}}
&lt;form action=&quot;/&quot; name=f method=&quot;GET&quot;&gt;
	&lt;input maxLength=1024 size=70 name=s value=&quot;&quot; title=&quot;Text to QR Encode&quot;&gt;
	&lt;input type=submit value=&quot;Show QR&quot; name=qr&gt;
&lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
`
</pre></div>
</div>
<p>mainまでの部分は簡単に理解できるはずです。 1つのフラグは、サーバーのデフォルトHTTPポートを設定します。 テンプレート変数templは、面白いことが起こる場所です。 ページを表示するためにサーバーによって実行されるHTMLテンプレートを作成します。 それについてはすぐに説明します。</p>
<p>メイン関数はフラグを解析し、上で説明したメカニズムを使用して、関数 <code class="docutils literal notranslate"><span class="pre">QR</span></code> をサーバーのルートパスにバインドします。 次に、サーバーを起動するために <code class="docutils literal notranslate"><span class="pre">http.ListenAndServe</span></code> が呼び出されます。 サーバーの実行中はブロックされます。</p>
<p><code class="docutils literal notranslate"><span class="pre">QR</span></code> はフォームデータを含むリクエストを受信し、 <code class="docutils literal notranslate"><span class="pre">s</span></code> という名前のフォーム値のデータに対してテンプレートを実行します。</p>
<p>テンプレートパッケージ <code class="docutils literal notranslate"><span class="pre">html/template</span></code> は強力です。 このプログラムは、その機能に触れています。 本質的に、 <code class="docutils literal notranslate"><span class="pre">templ.Execute</span></code> に渡されるデータ項目（この場合はフォーム値）から派生した要素を置き換えることにより、HTMLテキストを即座に書き換えます。 テンプレートテキスト（templateStr）内で、二重括弧で区切られた部分はテンプレートアクションを示します。 <code class="docutils literal notranslate"><span class="pre">{{if</span> <span class="pre">.}}</span></code> から <code class="docutils literal notranslate"><span class="pre">{{end}}</span></code> の部分は、<code class="docutils literal notranslate"><span class="pre">.</span></code> と呼ばれる現在のデータ項目が空でない場合のみ実行されます。つまり、文字列が空の場合、テンプレートのこの部分は抑制されます。</p>
<p>2つのスニペット <code class="docutils literal notranslate"><span class="pre">{{.}}</span></code> は、テンプレートに提示されたデータ（クエリ文字列）をWebページに表示することを示しています。 HTMLテンプレートパッケージは、適切なエスケープを自動的に提供するため、テキストを安全に表示できます。</p>
<p>テンプレート文字列の残りの部分は、ページが読み込まれたときに表示するHTMLです。 説明が速すぎる場合は、テンプレートパッケージの <a href="#id36"><span class="problematic" id="id37">`</span></a>ドキュメント &lt;/pkg/html/template/&gt;`_で詳細を確認してください。</p>
<p>数行のコードといくつかのデータ駆動型HTMLテキストの便利なWebサーバーをあなたは持っています。 Goは、数行で多くのことを実行できるほど強力です。</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">目次</a></h3>
  <ul>
<li><a class="reference internal" href="#">Effective Go</a><ul>
<li><a class="reference internal" href="#id1">イントロダクション</a><ul>
<li><a class="reference internal" href="#id3">例</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id5">フォーマット</a></li>
<li><a class="reference internal" href="#id6">コメント</a></li>
<li><a class="reference internal" href="#id7">命名</a><ul>
<li><a class="reference internal" href="#id8">パッケージ名</a></li>
<li><a class="reference internal" href="#getters">ゲッター</a></li>
<li><a class="reference internal" href="#id10">インターフェース名</a></li>
<li><a class="reference internal" href="#mixedcaps">MixedCaps</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id11">セミコロン</a></li>
<li><a class="reference internal" href="#control-structures">制御構造(Control structures)</a><ul>
<li><a class="reference internal" href="#if">If</a></li>
<li><a class="reference internal" href="#redeclaration-and-reassignment">Redeclaration and reassignment</a></li>
<li><a class="reference internal" href="#for">For</a></li>
<li><a class="reference internal" href="#switch">Switch</a></li>
<li><a class="reference internal" href="#type-switch">Type switch</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id13">関数</a><ul>
<li><a class="reference internal" href="#multiple-returns">多値返却</a></li>
<li><a class="reference internal" href="#named-result-parameters">名前付き結果変数(Named result parameters)</a></li>
<li><a class="reference internal" href="#defer">Defer</a></li>
</ul>
</li>
<li><a class="reference internal" href="#data">データ(Data)</a><ul>
<li><a class="reference internal" href="#allocation-with-new">Allocation with <strong>new</strong></a></li>
<li><a class="reference internal" href="#constructors-and-composite-literals">Constructors and composite literals</a></li>
<li><a class="reference internal" href="#allocation-with-make">Allocation with <strong>make</strong></a></li>
<li><a class="reference internal" href="#id15">配列</a></li>
<li><a class="reference internal" href="#id16">スライス</a></li>
<li><a class="reference internal" href="#two-dimensional-slices">Two-dimensional slices</a></li>
<li><a class="reference internal" href="#maps">Maps</a></li>
<li><a class="reference internal" href="#printing">Printing</a></li>
<li><a class="reference internal" href="#append">Append</a></li>
</ul>
</li>
<li><a class="reference internal" href="#initialization">初期化(Initialization)</a><ul>
<li><a class="reference internal" href="#id18">定数</a></li>
<li><a class="reference internal" href="#id23">変数</a></li>
<li><a class="reference internal" href="#init">init関数</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id25">メソッド</a><ul>
<li><a class="reference internal" href="#vs">ポインター vs 値</a></li>
</ul>
</li>
<li><a class="reference internal" href="#interfaces-and-types">インターフェースとその他の型</a><ul>
<li><a class="reference internal" href="#id27">インターフェース</a></li>
<li><a class="reference internal" href="#conversions">Conversions</a></li>
<li><a class="reference internal" href="#interface-conversions-and-type-assertions">Interface conversions and type assertions</a></li>
<li><a class="reference internal" href="#generality">Generality</a></li>
<li><a class="reference internal" href="#interface-methods">インターフェースとメソッド</a></li>
</ul>
</li>
<li><a class="reference internal" href="#blank">空白の識別子</a><ul>
<li><a class="reference internal" href="#the-blank-identifier-in-multiple-assignment">The blank identifier in multiple assignment</a></li>
<li><a class="reference internal" href="#unused-imports-and-variables">Unused imports and variables</a></li>
<li><a class="reference internal" href="#import-for-side-effect">Import for side effect</a></li>
<li><a class="reference internal" href="#interface-checks">Interface checks</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id30">埋め込み</a></li>
<li><a class="reference internal" href="#id31">並行処理</a><ul>
<li><a class="reference internal" href="#sharing">通信による共有</a></li>
<li><a class="reference internal" href="#id33">ゴルーチン</a></li>
<li><a class="reference internal" href="#id34">チャンネル</a></li>
<li><a class="reference internal" href="#channels-of-channels">Channels of channels</a></li>
<li><a class="reference internal" href="#parallelization">Parallelization</a></li>
<li><a class="reference internal" href="#a-leaky-buffer">A leaky buffer</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id35">エラー</a><ul>
<li><a class="reference internal" href="#panic">Panic</a></li>
<li><a class="reference internal" href="#recover">Recover</a></li>
</ul>
</li>
<li><a class="reference internal" href="#web">Webサーバー</a></li>
</ul>
</li>
</ul>

  <h4>前のトピックへ</h4>
  <p class="topless"><a href="../index.html"
                        title="前の章へ">Effective Go</a></p>
  <div role="note" aria-label="source link">
    <h3>このページ</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/documents/effective_go_ja.rst.txt"
            rel="nofollow">ソースコードを表示</a></li>
    </ul>
   </div><div>
    <h4>Page Info</h4>
    <p>
        <ul>
            <li>英数記号: 70023</li>
            <li>非アスキー: 3128</li>
            <li>合計文字数: 73151</li>
            <li>半角換算: 76279</li>
            <li>全角換算: 38139.5</li>
        </ul>
    </p>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">クイック検索</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="検索" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="総合索引"
             >索引</a></li>
        <li class="right" >
          <a href="../index.html" title="Effective Go"
             >前へ</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">Effective Go  ドキュメント</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2020, d-tsuji.
      このドキュメントは <a href="http://sphinx-doc.org/">Sphinx</a> 2.3.1 で生成しました。
    </div>
  </body>
</html>